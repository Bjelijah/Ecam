/* soapC.c
   Generated by gSOAP 2.8.4 from HomeMCUService.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.4 2013-03-07 01:53:34 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__VideoStandard:
		return soap_in_ns1__VideoStandard(soap, NULL, NULL, "ns1:VideoStandard");
	case SOAP_TYPE_ns1__RateType:
		return soap_in_ns1__RateType(soap, NULL, NULL, "ns1:RateType");
	case SOAP_TYPE_ns1__FrameSize:
		return soap_in_ns1__FrameSize(soap, NULL, NULL, "ns1:FrameSize");
	case SOAP_TYPE_ns1__PTZPreset:
		return soap_in_ns1__PTZPreset(soap, NULL, NULL, "ns1:PTZPreset");
	case SOAP_TYPE_ns1__PTZLens:
		return soap_in_ns1__PTZLens(soap, NULL, NULL, "ns1:PTZLens");
	case SOAP_TYPE_ns1__PTZDirection:
		return soap_in_ns1__PTZDirection(soap, NULL, NULL, "ns1:PTZDirection");
	case SOAP_TYPE_ns1__PwdType:
		return soap_in_ns1__PwdType(soap, NULL, NULL, "ns1:PwdType");
	case SOAP_TYPE_ns1__StreamType:
		return soap_in_ns1__StreamType(soap, NULL, NULL, "ns1:StreamType");
	case SOAP_TYPE_ns1__AuxiliaryState:
		return soap_in_ns1__AuxiliaryState(soap, NULL, NULL, "ns1:AuxiliaryState");
	case SOAP_TYPE_ns1__AuxiliaryType:
		return soap_in_ns1__AuxiliaryType(soap, NULL, NULL, "ns1:AuxiliaryType");
	case SOAP_TYPE_ns1__DeliveryType:
		return soap_in_ns1__DeliveryType(soap, NULL, NULL, "ns1:DeliveryType");
	case SOAP_TYPE_ns1__MCUResult:
		return soap_in_ns1__MCUResult(soap, NULL, NULL, "ns1:MCUResult");
	case SOAP_TYPE_ns1__CountryAbbr2ISO3166:
		return soap_in_ns1__CountryAbbr2ISO3166(soap, NULL, NULL, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__VODRecord:
		return soap_in_ns1__VODRecord(soap, NULL, NULL, "ns1:VODRecord");
	case SOAP_TYPE_ns1__PrivacyMaskRegion:
		return soap_in_ns1__PrivacyMaskRegion(soap, NULL, NULL, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_ns1__VMDGrid:
		return soap_in_ns1__VMDGrid(soap, NULL, NULL, "ns1:VMDGrid");
	case SOAP_TYPE_ns1__DevLog:
		return soap_in_ns1__DevLog(soap, NULL, NULL, "ns1:DevLog");
	case SOAP_TYPE_ns1__ArrayOfDevLog:
		return soap_in_ns1__ArrayOfDevLog(soap, NULL, NULL, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_ns1__PuLog:
		return soap_in_ns1__PuLog(soap, NULL, NULL, "ns1:PuLog");
	case SOAP_TYPE_ns1__ArrayOfPuLog:
		return soap_in_ns1__ArrayOfPuLog(soap, NULL, NULL, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_ns1__Device:
		return soap_in_ns1__Device(soap, NULL, NULL, "ns1:Device");
	case SOAP_TYPE_ns1__ArrayOfDevice:
		return soap_in_ns1__ArrayOfDevice(soap, NULL, NULL, "ns1:ArrayOfDevice");
	case SOAP_TYPE_ns1__Dev:
		return soap_in_ns1__Dev(soap, NULL, NULL, "ns1:Dev");
	case SOAP_TYPE_ns1__ArrayOfDev:
		return soap_in_ns1__ArrayOfDev(soap, NULL, NULL, "ns1:ArrayOfDev");
	case SOAP_TYPE_ns1__NodeDetails:
		return soap_in_ns1__NodeDetails(soap, NULL, NULL, "ns1:NodeDetails");
	case SOAP_TYPE_ns1__ArrayOfNodeDetails:
		return soap_in_ns1__ArrayOfNodeDetails(soap, NULL, NULL, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes:
		return soap_in_PointerTo_ns1__vodSearchRes(soap, NULL, NULL, "ns1:vodSearchRes");
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq:
		return soap_in_PointerTo_ns1__vodSearchReq(soap, NULL, NULL, "ns1:vodSearchReq");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes:
		return soap_in_PointerTo_ns1__getVODUrlRes(soap, NULL, NULL, "ns1:getVODUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq:
		return soap_in_PointerTo_ns1__getVODUrlReq(soap, NULL, NULL, "ns1:getVODUrlReq");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes:
		return soap_in_PointerTo_ns1__getPlayUrlRes(soap, NULL, NULL, "ns1:getPlayUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq:
		return soap_in_PointerTo_ns1__getPlayUrlReq(soap, NULL, NULL, "ns1:getPlayUrlReq");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes:
		return soap_in_PointerTo_ns1__setPrivacyMaskParamRes(soap, NULL, NULL, "ns1:setPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq:
		return soap_in_PointerTo_ns1__setPrivacyMaskParamReq(soap, NULL, NULL, "ns1:setPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes:
		return soap_in_PointerTo_ns1__getPrivacyMaskParamRes(soap, NULL, NULL, "ns1:getPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq:
		return soap_in_PointerTo_ns1__getPrivacyMaskParamReq(soap, NULL, NULL, "ns1:getPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes:
		return soap_in_PointerTo_ns1__setVMDParamRes(soap, NULL, NULL, "ns1:setVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq:
		return soap_in_PointerTo_ns1__setVMDParamReq(soap, NULL, NULL, "ns1:setVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes:
		return soap_in_PointerTo_ns1__getVMDParamRes(soap, NULL, NULL, "ns1:getVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq:
		return soap_in_PointerTo_ns1__getVMDParamReq(soap, NULL, NULL, "ns1:getVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setTimeRes:
		return soap_in_PointerTo_ns1__setTimeRes(soap, NULL, NULL, "ns1:setTimeRes");
	case SOAP_TYPE_PointerTo_ns1__setTimeReq:
		return soap_in_PointerTo_ns1__setTimeReq(soap, NULL, NULL, "ns1:setTimeReq");
	case SOAP_TYPE_PointerTo_ns1__getTimeRes:
		return soap_in_PointerTo_ns1__getTimeRes(soap, NULL, NULL, "ns1:getTimeRes");
	case SOAP_TYPE_PointerTo_ns1__getTimeReq:
		return soap_in_PointerTo_ns1__getTimeReq(soap, NULL, NULL, "ns1:getTimeReq");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes:
		return soap_in_PointerTo_ns1__setOSDParamRes(soap, NULL, NULL, "ns1:setOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq:
		return soap_in_PointerTo_ns1__setOSDParamReq(soap, NULL, NULL, "ns1:setOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes:
		return soap_in_PointerTo_ns1__getOSDParamRes(soap, NULL, NULL, "ns1:getOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq:
		return soap_in_PointerTo_ns1__getOSDParamReq(soap, NULL, NULL, "ns1:getOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes:
		return soap_in_PointerTo_ns1__setVideoParamRes(soap, NULL, NULL, "ns1:setVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq:
		return soap_in_PointerTo_ns1__setVideoParamReq(soap, NULL, NULL, "ns1:setVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes:
		return soap_in_PointerTo_ns1__getVideoParamRes(soap, NULL, NULL, "ns1:getVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq:
		return soap_in_PointerTo_ns1__getVideoParamReq(soap, NULL, NULL, "ns1:getVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes:
		return soap_in_PointerTo_ns1__queryDevLogRes(soap, NULL, NULL, "ns1:queryDevLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq:
		return soap_in_PointerTo_ns1__queryDevLogReq(soap, NULL, NULL, "ns1:queryDevLogReq");
	case SOAP_TYPE_PointerTo_ns1__queryLogRes:
		return soap_in_PointerTo_ns1__queryLogRes(soap, NULL, NULL, "ns1:queryLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryLogReq:
		return soap_in_PointerTo_ns1__queryLogReq(soap, NULL, NULL, "ns1:queryLogReq");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes:
		return soap_in_PointerTo_ns1__upgradeDevVerRes(soap, NULL, NULL, "ns1:upgradeDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq:
		return soap_in_PointerTo_ns1__upgradeDevVerReq(soap, NULL, NULL, "ns1:upgradeDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes:
		return soap_in_PointerTo_ns1__getDevVerRes(soap, NULL, NULL, "ns1:getDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq:
		return soap_in_PointerTo_ns1__getDevVerReq(soap, NULL, NULL, "ns1:getDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__rebootRes:
		return soap_in_PointerTo_ns1__rebootRes(soap, NULL, NULL, "ns1:rebootRes");
	case SOAP_TYPE_PointerTo_ns1__rebootReq:
		return soap_in_PointerTo_ns1__rebootReq(soap, NULL, NULL, "ns1:rebootReq");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes:
		return soap_in_PointerTo_ns1__setCodingParamRes(soap, NULL, NULL, "ns1:setCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq:
		return soap_in_PointerTo_ns1__setCodingParamReq(soap, NULL, NULL, "ns1:setCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes:
		return soap_in_PointerTo_ns1__getCodingParamRes(soap, NULL, NULL, "ns1:getCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq:
		return soap_in_PointerTo_ns1__getCodingParamReq(soap, NULL, NULL, "ns1:getCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__presetControlRes:
		return soap_in_PointerTo_ns1__presetControlRes(soap, NULL, NULL, "ns1:presetControlRes");
	case SOAP_TYPE_PointerTo_ns1__presetControlReq:
		return soap_in_PointerTo_ns1__presetControlReq(soap, NULL, NULL, "ns1:presetControlReq");
	case SOAP_TYPE_PointerTo_ns1__lensControlRes:
		return soap_in_PointerTo_ns1__lensControlRes(soap, NULL, NULL, "ns1:lensControlRes");
	case SOAP_TYPE_PointerTo_ns1__lensControlReq:
		return soap_in_PointerTo_ns1__lensControlReq(soap, NULL, NULL, "ns1:lensControlReq");
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes:
		return soap_in_PointerTo_ns1__ptzControlRes(soap, NULL, NULL, "ns1:ptzControlRes");
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq:
		return soap_in_PointerTo_ns1__ptzControlReq(soap, NULL, NULL, "ns1:ptzControlReq");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes:
		return soap_in_PointerTo_ns1__nullifyDeviceRes(soap, NULL, NULL, "ns1:nullifyDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq:
		return soap_in_PointerTo_ns1__nullifyDeviceReq(soap, NULL, NULL, "ns1:nullifyDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes:
		return soap_in_PointerTo_ns1__addDeviceRes(soap, NULL, NULL, "ns1:addDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq:
		return soap_in_PointerTo_ns1__addDeviceReq(soap, NULL, NULL, "ns1:addDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes:
		return soap_in_PointerTo_ns1__updateChannelNameRes(soap, NULL, NULL, "ns1:updateChannelNameRes");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq:
		return soap_in_PointerTo_ns1__updateChannelNameReq(soap, NULL, NULL, "ns1:updateChannelNameReq");
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes:
		return soap_in_PointerTo_ns1__userLogoutRes(soap, NULL, NULL, "ns1:userLogoutRes");
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq:
		return soap_in_PointerTo_ns1__userLogoutReq(soap, NULL, NULL, "ns1:userLogoutReq");
	case SOAP_TYPE_PointerTo_ns1__userLoginRes:
		return soap_in_PointerTo_ns1__userLoginRes(soap, NULL, NULL, "ns1:userLoginRes");
	case SOAP_TYPE_PointerTo_ns1__userLoginReq:
		return soap_in_PointerTo_ns1__userLoginReq(soap, NULL, NULL, "ns1:userLoginReq");
	case SOAP_TYPE_PointerTo_ns1__byeRes:
		return soap_in_PointerTo_ns1__byeRes(soap, NULL, NULL, "ns1:byeRes");
	case SOAP_TYPE_PointerTo_ns1__byeReq:
		return soap_in_PointerTo_ns1__byeReq(soap, NULL, NULL, "ns1:byeReq");
	case SOAP_TYPE_PointerTo_ns1__inviteRes:
		return soap_in_PointerTo_ns1__inviteRes(soap, NULL, NULL, "ns1:inviteRes");
	case SOAP_TYPE_PointerTo_ns1__inviteReq:
		return soap_in_PointerTo_ns1__inviteReq(soap, NULL, NULL, "ns1:inviteReq");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes:
		return soap_in_PointerTo_ns1__setAuxiliaryRes(soap, NULL, NULL, "ns1:setAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq:
		return soap_in_PointerTo_ns1__setAuxiliaryReq(soap, NULL, NULL, "ns1:setAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes:
		return soap_in_PointerTo_ns1__getAuxiliaryRes(soap, NULL, NULL, "ns1:getAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq:
		return soap_in_PointerTo_ns1__getAuxiliaryReq(soap, NULL, NULL, "ns1:getAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes:
		return soap_in_PointerTo_ns1__getBackPasswordRes(soap, NULL, NULL, "ns1:getBackPasswordRes");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq:
		return soap_in_PointerTo_ns1__getBackPasswordReq(soap, NULL, NULL, "ns1:getBackPasswordReq");
	case SOAP_TYPE_PointerTo_ns1__getAccountRes:
		return soap_in_PointerTo_ns1__getAccountRes(soap, NULL, NULL, "ns1:getAccountRes");
	case SOAP_TYPE_PointerTo_ns1__getAccountReq:
		return soap_in_PointerTo_ns1__getAccountReq(soap, NULL, NULL, "ns1:getAccountReq");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes:
		return soap_in_PointerTo_ns1__updateAppleTokenRes(soap, NULL, NULL, "ns1:updateAppleTokenRes");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq:
		return soap_in_PointerTo_ns1__updateAppleTokenReq(soap, NULL, NULL, "ns1:updateAppleTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes:
		return soap_in_PointerTo_ns1__queryDeviceRes(soap, NULL, NULL, "ns1:queryDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq:
		return soap_in_PointerTo_ns1__queryDeviceReq(soap, NULL, NULL, "ns1:queryDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes:
		return soap_in_PointerTo_ns1__updatePasswordRes(soap, NULL, NULL, "ns1:updatePasswordRes");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq:
		return soap_in_PointerTo_ns1__updatePasswordReq(soap, NULL, NULL, "ns1:updatePasswordReq");
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes:
		return soap_in_PointerTo_ns1__updateAccountRes(soap, NULL, NULL, "ns1:updateAccountRes");
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq:
		return soap_in_PointerTo_ns1__updateAccountReq(soap, NULL, NULL, "ns1:updateAccountReq");
	case SOAP_TYPE_PointerTo_ns1__createAccountRes:
		return soap_in_PointerTo_ns1__createAccountRes(soap, NULL, NULL, "ns1:createAccountRes");
	case SOAP_TYPE_PointerTo_ns1__createAccountReq:
		return soap_in_PointerTo_ns1__createAccountReq(soap, NULL, NULL, "ns1:createAccountReq");
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes_Any:
		return soap_in_PointerTo_ns1__vodSearchRes_Any(soap, NULL, NULL, "ns1:vodSearchRes-Any");
	case SOAP_TYPE_PointerTons1__VODRecord:
		return soap_in_PointerTons1__VODRecord(soap, NULL, NULL, "ns1:VODRecord");
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq_Any:
		return soap_in_PointerTo_ns1__vodSearchReq_Any(soap, NULL, NULL, "ns1:vodSearchReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes_Any:
		return soap_in_PointerTo_ns1__getVODUrlRes_Any(soap, NULL, NULL, "ns1:getVODUrlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq_Any:
		return soap_in_PointerTo_ns1__getVODUrlReq_Any(soap, NULL, NULL, "ns1:getVODUrlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes_Any:
		return soap_in_PointerTo_ns1__getPlayUrlRes_Any(soap, NULL, NULL, "ns1:getPlayUrlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq_Any:
		return soap_in_PointerTo_ns1__getPlayUrlReq_Any(soap, NULL, NULL, "ns1:getPlayUrlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes_Any:
		return soap_in_PointerTo_ns1__setPrivacyMaskParamRes_Any(soap, NULL, NULL, "ns1:setPrivacyMaskParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq_Any:
		return soap_in_PointerTo_ns1__setPrivacyMaskParamReq_Any(soap, NULL, NULL, "ns1:setPrivacyMaskParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes_Any:
		return soap_in_PointerTo_ns1__getPrivacyMaskParamRes_Any(soap, NULL, NULL, "ns1:getPrivacyMaskParamRes-Any");
	case SOAP_TYPE_PointerTons1__PrivacyMaskRegion:
		return soap_in_PointerTons1__PrivacyMaskRegion(soap, NULL, NULL, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq_Any:
		return soap_in_PointerTo_ns1__getPrivacyMaskParamReq_Any(soap, NULL, NULL, "ns1:getPrivacyMaskParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes_Any:
		return soap_in_PointerTo_ns1__setVMDParamRes_Any(soap, NULL, NULL, "ns1:setVMDParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq_Any:
		return soap_in_PointerTo_ns1__setVMDParamReq_Any(soap, NULL, NULL, "ns1:setVMDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes_Any:
		return soap_in_PointerTo_ns1__getVMDParamRes_Any(soap, NULL, NULL, "ns1:getVMDParamRes-Any");
	case SOAP_TYPE_PointerTons1__VMDGrid:
		return soap_in_PointerTons1__VMDGrid(soap, NULL, NULL, "ns1:VMDGrid");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq_Any:
		return soap_in_PointerTo_ns1__getVMDParamReq_Any(soap, NULL, NULL, "ns1:getVMDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setTimeRes_Any:
		return soap_in_PointerTo_ns1__setTimeRes_Any(soap, NULL, NULL, "ns1:setTimeRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setTimeReq_Any:
		return soap_in_PointerTo_ns1__setTimeReq_Any(soap, NULL, NULL, "ns1:setTimeReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getTimeRes_Any:
		return soap_in_PointerTo_ns1__getTimeRes_Any(soap, NULL, NULL, "ns1:getTimeRes-Any");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTo_ns1__getTimeReq_Any:
		return soap_in_PointerTo_ns1__getTimeReq_Any(soap, NULL, NULL, "ns1:getTimeReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes_Any:
		return soap_in_PointerTo_ns1__setOSDParamRes_Any(soap, NULL, NULL, "ns1:setOSDParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq_Any:
		return soap_in_PointerTo_ns1__setOSDParamReq_Any(soap, NULL, NULL, "ns1:setOSDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes_Any:
		return soap_in_PointerTo_ns1__getOSDParamRes_Any(soap, NULL, NULL, "ns1:getOSDParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq_Any:
		return soap_in_PointerTo_ns1__getOSDParamReq_Any(soap, NULL, NULL, "ns1:getOSDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes_Any:
		return soap_in_PointerTo_ns1__setVideoParamRes_Any(soap, NULL, NULL, "ns1:setVideoParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq_Any:
		return soap_in_PointerTo_ns1__setVideoParamReq_Any(soap, NULL, NULL, "ns1:setVideoParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes_Any:
		return soap_in_PointerTo_ns1__getVideoParamRes_Any(soap, NULL, NULL, "ns1:getVideoParamRes-Any");
	case SOAP_TYPE_PointerTons1__VideoStandard:
		return soap_in_PointerTons1__VideoStandard(soap, NULL, NULL, "ns1:VideoStandard");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq_Any:
		return soap_in_PointerTo_ns1__getVideoParamReq_Any(soap, NULL, NULL, "ns1:getVideoParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes_Any:
		return soap_in_PointerTo_ns1__queryDevLogRes_Any(soap, NULL, NULL, "ns1:queryDevLogRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfDevLog:
		return soap_in_PointerTons1__ArrayOfDevLog(soap, NULL, NULL, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq_Any:
		return soap_in_PointerTo_ns1__queryDevLogReq_Any(soap, NULL, NULL, "ns1:queryDevLogReq-Any");
	case SOAP_TYPE_PointerTo_ns1__queryLogRes_Any:
		return soap_in_PointerTo_ns1__queryLogRes_Any(soap, NULL, NULL, "ns1:queryLogRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfPuLog:
		return soap_in_PointerTons1__ArrayOfPuLog(soap, NULL, NULL, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_PointerTo_ns1__queryLogReq_Any:
		return soap_in_PointerTo_ns1__queryLogReq_Any(soap, NULL, NULL, "ns1:queryLogReq-Any");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes_Any:
		return soap_in_PointerTo_ns1__upgradeDevVerRes_Any(soap, NULL, NULL, "ns1:upgradeDevVerRes-Any");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq_Any:
		return soap_in_PointerTo_ns1__upgradeDevVerReq_Any(soap, NULL, NULL, "ns1:upgradeDevVerReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes_Any:
		return soap_in_PointerTo_ns1__getDevVerRes_Any(soap, NULL, NULL, "ns1:getDevVerRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq_Any:
		return soap_in_PointerTo_ns1__getDevVerReq_Any(soap, NULL, NULL, "ns1:getDevVerReq-Any");
	case SOAP_TYPE_PointerTo_ns1__rebootRes_Any:
		return soap_in_PointerTo_ns1__rebootRes_Any(soap, NULL, NULL, "ns1:rebootRes-Any");
	case SOAP_TYPE_PointerTo_ns1__rebootReq_Any:
		return soap_in_PointerTo_ns1__rebootReq_Any(soap, NULL, NULL, "ns1:rebootReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes_Any:
		return soap_in_PointerTo_ns1__setCodingParamRes_Any(soap, NULL, NULL, "ns1:setCodingParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq_Any:
		return soap_in_PointerTo_ns1__setCodingParamReq_Any(soap, NULL, NULL, "ns1:setCodingParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes_Any:
		return soap_in_PointerTo_ns1__getCodingParamRes_Any(soap, NULL, NULL, "ns1:getCodingParamRes-Any");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__RateType:
		return soap_in_PointerTons1__RateType(soap, NULL, NULL, "ns1:RateType");
	case SOAP_TYPE_PointerTons1__FrameSize:
		return soap_in_PointerTons1__FrameSize(soap, NULL, NULL, "ns1:FrameSize");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq_Any:
		return soap_in_PointerTo_ns1__getCodingParamReq_Any(soap, NULL, NULL, "ns1:getCodingParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__presetControlRes_Any:
		return soap_in_PointerTo_ns1__presetControlRes_Any(soap, NULL, NULL, "ns1:presetControlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__presetControlReq_Any:
		return soap_in_PointerTo_ns1__presetControlReq_Any(soap, NULL, NULL, "ns1:presetControlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__lensControlRes_Any:
		return soap_in_PointerTo_ns1__lensControlRes_Any(soap, NULL, NULL, "ns1:lensControlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__lensControlReq_Any:
		return soap_in_PointerTo_ns1__lensControlReq_Any(soap, NULL, NULL, "ns1:lensControlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes_Any:
		return soap_in_PointerTo_ns1__ptzControlRes_Any(soap, NULL, NULL, "ns1:ptzControlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq_Any:
		return soap_in_PointerTo_ns1__ptzControlReq_Any(soap, NULL, NULL, "ns1:ptzControlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes_Any:
		return soap_in_PointerTo_ns1__nullifyDeviceRes_Any(soap, NULL, NULL, "ns1:nullifyDeviceRes-Any");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq_Any:
		return soap_in_PointerTo_ns1__nullifyDeviceReq_Any(soap, NULL, NULL, "ns1:nullifyDeviceReq-Any");
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes_Any:
		return soap_in_PointerTo_ns1__addDeviceRes_Any(soap, NULL, NULL, "ns1:addDeviceRes-Any");
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq_Any:
		return soap_in_PointerTo_ns1__addDeviceReq_Any(soap, NULL, NULL, "ns1:addDeviceReq-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfDevice:
		return soap_in_PointerTons1__ArrayOfDevice(soap, NULL, NULL, "ns1:ArrayOfDevice");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes_Any:
		return soap_in_PointerTo_ns1__updateChannelNameRes_Any(soap, NULL, NULL, "ns1:updateChannelNameRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq_Any:
		return soap_in_PointerTo_ns1__updateChannelNameReq_Any(soap, NULL, NULL, "ns1:updateChannelNameReq-Any");
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes_Any:
		return soap_in_PointerTo_ns1__userLogoutRes_Any(soap, NULL, NULL, "ns1:userLogoutRes-Any");
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq_Any:
		return soap_in_PointerTo_ns1__userLogoutReq_Any(soap, NULL, NULL, "ns1:userLogoutReq-Any");
	case SOAP_TYPE_PointerTo_ns1__userLoginRes_Any:
		return soap_in_PointerTo_ns1__userLoginRes_Any(soap, NULL, NULL, "ns1:userLoginRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfDev:
		return soap_in_PointerTons1__ArrayOfDev(soap, NULL, NULL, "ns1:ArrayOfDev");
	case SOAP_TYPE_PointerTo_ns1__userLoginReq_Any:
		return soap_in_PointerTo_ns1__userLoginReq_Any(soap, NULL, NULL, "ns1:userLoginReq-Any");
	case SOAP_TYPE_PointerTo_ns1__byeRes_Any:
		return soap_in_PointerTo_ns1__byeRes_Any(soap, NULL, NULL, "ns1:byeRes-Any");
	case SOAP_TYPE_PointerTo_ns1__byeReq_Any:
		return soap_in_PointerTo_ns1__byeReq_Any(soap, NULL, NULL, "ns1:byeReq-Any");
	case SOAP_TYPE_PointerTo_ns1__inviteRes_Any:
		return soap_in_PointerTo_ns1__inviteRes_Any(soap, NULL, NULL, "ns1:inviteRes-Any");
	case SOAP_TYPE_PointerTo_ns1__inviteReq_Any:
		return soap_in_PointerTo_ns1__inviteReq_Any(soap, NULL, NULL, "ns1:inviteReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes_Any:
		return soap_in_PointerTo_ns1__setAuxiliaryRes_Any(soap, NULL, NULL, "ns1:setAuxiliaryRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq_Any:
		return soap_in_PointerTo_ns1__setAuxiliaryReq_Any(soap, NULL, NULL, "ns1:setAuxiliaryReq-Any");
	case SOAP_TYPE_PointerTons1__AuxiliaryType:
		return soap_in_PointerTons1__AuxiliaryType(soap, NULL, NULL, "ns1:AuxiliaryType");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes_Any:
		return soap_in_PointerTo_ns1__getAuxiliaryRes_Any(soap, NULL, NULL, "ns1:getAuxiliaryRes-Any");
	case SOAP_TYPE_PointerTons1__AuxiliaryState:
		return soap_in_PointerTons1__AuxiliaryState(soap, NULL, NULL, "ns1:AuxiliaryState");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq_Any:
		return soap_in_PointerTo_ns1__getAuxiliaryReq_Any(soap, NULL, NULL, "ns1:getAuxiliaryReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes_Any:
		return soap_in_PointerTo_ns1__getBackPasswordRes_Any(soap, NULL, NULL, "ns1:getBackPasswordRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq_Any:
		return soap_in_PointerTo_ns1__getBackPasswordReq_Any(soap, NULL, NULL, "ns1:getBackPasswordReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getAccountRes_Any:
		return soap_in_PointerTo_ns1__getAccountRes_Any(soap, NULL, NULL, "ns1:getAccountRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getAccountReq_Any:
		return soap_in_PointerTo_ns1__getAccountReq_Any(soap, NULL, NULL, "ns1:getAccountReq-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes_Any:
		return soap_in_PointerTo_ns1__updateAppleTokenRes_Any(soap, NULL, NULL, "ns1:updateAppleTokenRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq_Any:
		return soap_in_PointerTo_ns1__updateAppleTokenReq_Any(soap, NULL, NULL, "ns1:updateAppleTokenReq-Any");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes_Any:
		return soap_in_PointerTo_ns1__queryDeviceRes_Any(soap, NULL, NULL, "ns1:queryDeviceRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfNodeDetails:
		return soap_in_PointerTons1__ArrayOfNodeDetails(soap, NULL, NULL, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq_Any:
		return soap_in_PointerTo_ns1__queryDeviceReq_Any(soap, NULL, NULL, "ns1:queryDeviceReq-Any");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes_Any:
		return soap_in_PointerTo_ns1__updatePasswordRes_Any(soap, NULL, NULL, "ns1:updatePasswordRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq_Any:
		return soap_in_PointerTo_ns1__updatePasswordReq_Any(soap, NULL, NULL, "ns1:updatePasswordReq-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes_Any:
		return soap_in_PointerTo_ns1__updateAccountRes_Any(soap, NULL, NULL, "ns1:updateAccountRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq_Any:
		return soap_in_PointerTo_ns1__updateAccountReq_Any(soap, NULL, NULL, "ns1:updateAccountReq-Any");
	case SOAP_TYPE_PointerTo_ns1__createAccountRes_Any:
		return soap_in_PointerTo_ns1__createAccountRes_Any(soap, NULL, NULL, "ns1:createAccountRes-Any");
	case SOAP_TYPE_PointerTo_ns1__createAccountReq_Any:
		return soap_in_PointerTo_ns1__createAccountReq_Any(soap, NULL, NULL, "ns1:createAccountReq-Any");
	case SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166:
		return soap_in_PointerTons1__CountryAbbr2ISO3166(soap, NULL, NULL, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTo_ns1__VODRecord_Any:
		return soap_in_PointerTo_ns1__VODRecord_Any(soap, NULL, NULL, "ns1:VODRecord-Any");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTo_ns1__PrivacyMaskRegion_Any:
		return soap_in_PointerTo_ns1__PrivacyMaskRegion_Any(soap, NULL, NULL, "ns1:PrivacyMaskRegion-Any");
	case SOAP_TYPE_PointerTo_ns1__VMDGrid_Any:
		return soap_in_PointerTo_ns1__VMDGrid_Any(soap, NULL, NULL, "ns1:VMDGrid-Any");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__DevLog_Any:
		return soap_in_PointerTo_ns1__DevLog_Any(soap, NULL, NULL, "ns1:DevLog-Any");
	case SOAP_TYPE_PointerTons1__DevLog:
		return soap_in_PointerTons1__DevLog(soap, NULL, NULL, "ns1:DevLog");
	case SOAP_TYPE_PointerTo_ns1__PuLog_Any:
		return soap_in_PointerTo_ns1__PuLog_Any(soap, NULL, NULL, "ns1:PuLog-Any");
	case SOAP_TYPE_PointerTons1__PuLog:
		return soap_in_PointerTons1__PuLog(soap, NULL, NULL, "ns1:PuLog");
	case SOAP_TYPE_PointerTo_ns1__Device_Any:
		return soap_in_PointerTo_ns1__Device_Any(soap, NULL, NULL, "ns1:Device-Any");
	case SOAP_TYPE_PointerTons1__Device:
		return soap_in_PointerTons1__Device(soap, NULL, NULL, "ns1:Device");
	case SOAP_TYPE_PointerTo_ns1__Dev_Any:
		return soap_in_PointerTo_ns1__Dev_Any(soap, NULL, NULL, "ns1:Dev-Any");
	case SOAP_TYPE_PointerTons1__Dev:
		return soap_in_PointerTons1__Dev(soap, NULL, NULL, "ns1:Dev");
	case SOAP_TYPE_PointerTo_ns1__NodeDetails_Any:
		return soap_in_PointerTo_ns1__NodeDetails_Any(soap, NULL, NULL, "ns1:NodeDetails-Any");
	case SOAP_TYPE_PointerTons1__NodeDetails:
		return soap_in_PointerTons1__NodeDetails(soap, NULL, NULL, "ns1:NodeDetails");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VideoStandard"))
		{	*type = SOAP_TYPE_ns1__VideoStandard;
			return soap_in_ns1__VideoStandard(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RateType"))
		{	*type = SOAP_TYPE_ns1__RateType;
			return soap_in_ns1__RateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FrameSize"))
		{	*type = SOAP_TYPE_ns1__FrameSize;
			return soap_in_ns1__FrameSize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZPreset"))
		{	*type = SOAP_TYPE_ns1__PTZPreset;
			return soap_in_ns1__PTZPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZLens"))
		{	*type = SOAP_TYPE_ns1__PTZLens;
			return soap_in_ns1__PTZLens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PTZDirection"))
		{	*type = SOAP_TYPE_ns1__PTZDirection;
			return soap_in_ns1__PTZDirection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PwdType"))
		{	*type = SOAP_TYPE_ns1__PwdType;
			return soap_in_ns1__PwdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StreamType"))
		{	*type = SOAP_TYPE_ns1__StreamType;
			return soap_in_ns1__StreamType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuxiliaryState"))
		{	*type = SOAP_TYPE_ns1__AuxiliaryState;
			return soap_in_ns1__AuxiliaryState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuxiliaryType"))
		{	*type = SOAP_TYPE_ns1__AuxiliaryType;
			return soap_in_ns1__AuxiliaryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeliveryType"))
		{	*type = SOAP_TYPE_ns1__DeliveryType;
			return soap_in_ns1__DeliveryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MCUResult"))
		{	*type = SOAP_TYPE_ns1__MCUResult;
			return soap_in_ns1__MCUResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryAbbr2ISO3166"))
		{	*type = SOAP_TYPE_ns1__CountryAbbr2ISO3166;
			return soap_in_ns1__CountryAbbr2ISO3166(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VODRecord"))
		{	*type = SOAP_TYPE_ns1__VODRecord;
			return soap_in_ns1__VODRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrivacyMaskRegion"))
		{	*type = SOAP_TYPE_ns1__PrivacyMaskRegion;
			return soap_in_ns1__PrivacyMaskRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VMDGrid"))
		{	*type = SOAP_TYPE_ns1__VMDGrid;
			return soap_in_ns1__VMDGrid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DevLog"))
		{	*type = SOAP_TYPE_ns1__DevLog;
			return soap_in_ns1__DevLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDevLog"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDevLog;
			return soap_in_ns1__ArrayOfDevLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PuLog"))
		{	*type = SOAP_TYPE_ns1__PuLog;
			return soap_in_ns1__PuLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfPuLog"))
		{	*type = SOAP_TYPE_ns1__ArrayOfPuLog;
			return soap_in_ns1__ArrayOfPuLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Device"))
		{	*type = SOAP_TYPE_ns1__Device;
			return soap_in_ns1__Device(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDevice"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDevice;
			return soap_in_ns1__ArrayOfDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Dev"))
		{	*type = SOAP_TYPE_ns1__Dev;
			return soap_in_ns1__Dev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDev"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDev;
			return soap_in_ns1__ArrayOfDev(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NodeDetails"))
		{	*type = SOAP_TYPE_ns1__NodeDetails;
			return soap_in_ns1__NodeDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfNodeDetails"))
		{	*type = SOAP_TYPE_ns1__ArrayOfNodeDetails;
			return soap_in_ns1__ArrayOfNodeDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:vodSearchRes-Any"))
		{	*type = SOAP_TYPE__ns1__vodSearchRes_Any;
			return soap_in__ns1__vodSearchRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vodSearchRes"))
		{	*type = SOAP_TYPE__ns1__vodSearchRes;
			return soap_in__ns1__vodSearchRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vodSearchReq-Any"))
		{	*type = SOAP_TYPE__ns1__vodSearchReq_Any;
			return soap_in__ns1__vodSearchReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:vodSearchReq"))
		{	*type = SOAP_TYPE__ns1__vodSearchReq;
			return soap_in__ns1__vodSearchReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVODUrlRes-Any"))
		{	*type = SOAP_TYPE__ns1__getVODUrlRes_Any;
			return soap_in__ns1__getVODUrlRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVODUrlRes"))
		{	*type = SOAP_TYPE__ns1__getVODUrlRes;
			return soap_in__ns1__getVODUrlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVODUrlReq-Any"))
		{	*type = SOAP_TYPE__ns1__getVODUrlReq_Any;
			return soap_in__ns1__getVODUrlReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVODUrlReq"))
		{	*type = SOAP_TYPE__ns1__getVODUrlReq;
			return soap_in__ns1__getVODUrlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPlayUrlRes-Any"))
		{	*type = SOAP_TYPE__ns1__getPlayUrlRes_Any;
			return soap_in__ns1__getPlayUrlRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPlayUrlRes"))
		{	*type = SOAP_TYPE__ns1__getPlayUrlRes;
			return soap_in__ns1__getPlayUrlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPlayUrlReq-Any"))
		{	*type = SOAP_TYPE__ns1__getPlayUrlReq_Any;
			return soap_in__ns1__getPlayUrlReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPlayUrlReq"))
		{	*type = SOAP_TYPE__ns1__getPlayUrlReq;
			return soap_in__ns1__getPlayUrlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPrivacyMaskParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any;
			return soap_in__ns1__setPrivacyMaskParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPrivacyMaskParamRes"))
		{	*type = SOAP_TYPE__ns1__setPrivacyMaskParamRes;
			return soap_in__ns1__setPrivacyMaskParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPrivacyMaskParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any;
			return soap_in__ns1__setPrivacyMaskParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPrivacyMaskParamReq"))
		{	*type = SOAP_TYPE__ns1__setPrivacyMaskParamReq;
			return soap_in__ns1__setPrivacyMaskParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrivacyMaskParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any;
			return soap_in__ns1__getPrivacyMaskParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrivacyMaskParamRes"))
		{	*type = SOAP_TYPE__ns1__getPrivacyMaskParamRes;
			return soap_in__ns1__getPrivacyMaskParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrivacyMaskParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any;
			return soap_in__ns1__getPrivacyMaskParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPrivacyMaskParamReq"))
		{	*type = SOAP_TYPE__ns1__getPrivacyMaskParamReq;
			return soap_in__ns1__getPrivacyMaskParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVMDParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__setVMDParamRes_Any;
			return soap_in__ns1__setVMDParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVMDParamRes"))
		{	*type = SOAP_TYPE__ns1__setVMDParamRes;
			return soap_in__ns1__setVMDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVMDParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__setVMDParamReq_Any;
			return soap_in__ns1__setVMDParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVMDParamReq"))
		{	*type = SOAP_TYPE__ns1__setVMDParamReq;
			return soap_in__ns1__setVMDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVMDParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__getVMDParamRes_Any;
			return soap_in__ns1__getVMDParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVMDParamRes"))
		{	*type = SOAP_TYPE__ns1__getVMDParamRes;
			return soap_in__ns1__getVMDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVMDParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__getVMDParamReq_Any;
			return soap_in__ns1__getVMDParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVMDParamReq"))
		{	*type = SOAP_TYPE__ns1__getVMDParamReq;
			return soap_in__ns1__getVMDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setTimeRes-Any"))
		{	*type = SOAP_TYPE__ns1__setTimeRes_Any;
			return soap_in__ns1__setTimeRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setTimeRes"))
		{	*type = SOAP_TYPE__ns1__setTimeRes;
			return soap_in__ns1__setTimeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setTimeReq-Any"))
		{	*type = SOAP_TYPE__ns1__setTimeReq_Any;
			return soap_in__ns1__setTimeReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setTimeReq"))
		{	*type = SOAP_TYPE__ns1__setTimeReq;
			return soap_in__ns1__setTimeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimeRes-Any"))
		{	*type = SOAP_TYPE__ns1__getTimeRes_Any;
			return soap_in__ns1__getTimeRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimeRes"))
		{	*type = SOAP_TYPE__ns1__getTimeRes;
			return soap_in__ns1__getTimeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimeReq-Any"))
		{	*type = SOAP_TYPE__ns1__getTimeReq_Any;
			return soap_in__ns1__getTimeReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTimeReq"))
		{	*type = SOAP_TYPE__ns1__getTimeReq;
			return soap_in__ns1__getTimeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setOSDParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__setOSDParamRes_Any;
			return soap_in__ns1__setOSDParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setOSDParamRes"))
		{	*type = SOAP_TYPE__ns1__setOSDParamRes;
			return soap_in__ns1__setOSDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setOSDParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__setOSDParamReq_Any;
			return soap_in__ns1__setOSDParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setOSDParamReq"))
		{	*type = SOAP_TYPE__ns1__setOSDParamReq;
			return soap_in__ns1__setOSDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOSDParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__getOSDParamRes_Any;
			return soap_in__ns1__getOSDParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOSDParamRes"))
		{	*type = SOAP_TYPE__ns1__getOSDParamRes;
			return soap_in__ns1__getOSDParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOSDParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__getOSDParamReq_Any;
			return soap_in__ns1__getOSDParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOSDParamReq"))
		{	*type = SOAP_TYPE__ns1__getOSDParamReq;
			return soap_in__ns1__getOSDParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVideoParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__setVideoParamRes_Any;
			return soap_in__ns1__setVideoParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVideoParamRes"))
		{	*type = SOAP_TYPE__ns1__setVideoParamRes;
			return soap_in__ns1__setVideoParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVideoParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__setVideoParamReq_Any;
			return soap_in__ns1__setVideoParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setVideoParamReq"))
		{	*type = SOAP_TYPE__ns1__setVideoParamReq;
			return soap_in__ns1__setVideoParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVideoParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__getVideoParamRes_Any;
			return soap_in__ns1__getVideoParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVideoParamRes"))
		{	*type = SOAP_TYPE__ns1__getVideoParamRes;
			return soap_in__ns1__getVideoParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVideoParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__getVideoParamReq_Any;
			return soap_in__ns1__getVideoParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVideoParamReq"))
		{	*type = SOAP_TYPE__ns1__getVideoParamReq;
			return soap_in__ns1__getVideoParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDevLogRes-Any"))
		{	*type = SOAP_TYPE__ns1__queryDevLogRes_Any;
			return soap_in__ns1__queryDevLogRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDevLogRes"))
		{	*type = SOAP_TYPE__ns1__queryDevLogRes;
			return soap_in__ns1__queryDevLogRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDevLogReq-Any"))
		{	*type = SOAP_TYPE__ns1__queryDevLogReq_Any;
			return soap_in__ns1__queryDevLogReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDevLogReq"))
		{	*type = SOAP_TYPE__ns1__queryDevLogReq;
			return soap_in__ns1__queryDevLogReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLogRes-Any"))
		{	*type = SOAP_TYPE__ns1__queryLogRes_Any;
			return soap_in__ns1__queryLogRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLogRes"))
		{	*type = SOAP_TYPE__ns1__queryLogRes;
			return soap_in__ns1__queryLogRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLogReq-Any"))
		{	*type = SOAP_TYPE__ns1__queryLogReq_Any;
			return soap_in__ns1__queryLogReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryLogReq"))
		{	*type = SOAP_TYPE__ns1__queryLogReq;
			return soap_in__ns1__queryLogReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upgradeDevVerRes-Any"))
		{	*type = SOAP_TYPE__ns1__upgradeDevVerRes_Any;
			return soap_in__ns1__upgradeDevVerRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upgradeDevVerRes"))
		{	*type = SOAP_TYPE__ns1__upgradeDevVerRes;
			return soap_in__ns1__upgradeDevVerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upgradeDevVerReq-Any"))
		{	*type = SOAP_TYPE__ns1__upgradeDevVerReq_Any;
			return soap_in__ns1__upgradeDevVerReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:upgradeDevVerReq"))
		{	*type = SOAP_TYPE__ns1__upgradeDevVerReq;
			return soap_in__ns1__upgradeDevVerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDevVerRes-Any"))
		{	*type = SOAP_TYPE__ns1__getDevVerRes_Any;
			return soap_in__ns1__getDevVerRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDevVerRes"))
		{	*type = SOAP_TYPE__ns1__getDevVerRes;
			return soap_in__ns1__getDevVerRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDevVerReq-Any"))
		{	*type = SOAP_TYPE__ns1__getDevVerReq_Any;
			return soap_in__ns1__getDevVerReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDevVerReq"))
		{	*type = SOAP_TYPE__ns1__getDevVerReq;
			return soap_in__ns1__getDevVerReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rebootRes-Any"))
		{	*type = SOAP_TYPE__ns1__rebootRes_Any;
			return soap_in__ns1__rebootRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rebootRes"))
		{	*type = SOAP_TYPE__ns1__rebootRes;
			return soap_in__ns1__rebootRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rebootReq-Any"))
		{	*type = SOAP_TYPE__ns1__rebootReq_Any;
			return soap_in__ns1__rebootReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rebootReq"))
		{	*type = SOAP_TYPE__ns1__rebootReq;
			return soap_in__ns1__rebootReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCodingParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__setCodingParamRes_Any;
			return soap_in__ns1__setCodingParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCodingParamRes"))
		{	*type = SOAP_TYPE__ns1__setCodingParamRes;
			return soap_in__ns1__setCodingParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCodingParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__setCodingParamReq_Any;
			return soap_in__ns1__setCodingParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCodingParamReq"))
		{	*type = SOAP_TYPE__ns1__setCodingParamReq;
			return soap_in__ns1__setCodingParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCodingParamRes-Any"))
		{	*type = SOAP_TYPE__ns1__getCodingParamRes_Any;
			return soap_in__ns1__getCodingParamRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCodingParamRes"))
		{	*type = SOAP_TYPE__ns1__getCodingParamRes;
			return soap_in__ns1__getCodingParamRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCodingParamReq-Any"))
		{	*type = SOAP_TYPE__ns1__getCodingParamReq_Any;
			return soap_in__ns1__getCodingParamReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCodingParamReq"))
		{	*type = SOAP_TYPE__ns1__getCodingParamReq;
			return soap_in__ns1__getCodingParamReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:presetControlRes-Any"))
		{	*type = SOAP_TYPE__ns1__presetControlRes_Any;
			return soap_in__ns1__presetControlRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:presetControlRes"))
		{	*type = SOAP_TYPE__ns1__presetControlRes;
			return soap_in__ns1__presetControlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:presetControlReq-Any"))
		{	*type = SOAP_TYPE__ns1__presetControlReq_Any;
			return soap_in__ns1__presetControlReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:presetControlReq"))
		{	*type = SOAP_TYPE__ns1__presetControlReq;
			return soap_in__ns1__presetControlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lensControlRes-Any"))
		{	*type = SOAP_TYPE__ns1__lensControlRes_Any;
			return soap_in__ns1__lensControlRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lensControlRes"))
		{	*type = SOAP_TYPE__ns1__lensControlRes;
			return soap_in__ns1__lensControlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lensControlReq-Any"))
		{	*type = SOAP_TYPE__ns1__lensControlReq_Any;
			return soap_in__ns1__lensControlReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lensControlReq"))
		{	*type = SOAP_TYPE__ns1__lensControlReq;
			return soap_in__ns1__lensControlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptzControlRes-Any"))
		{	*type = SOAP_TYPE__ns1__ptzControlRes_Any;
			return soap_in__ns1__ptzControlRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptzControlRes"))
		{	*type = SOAP_TYPE__ns1__ptzControlRes;
			return soap_in__ns1__ptzControlRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptzControlReq-Any"))
		{	*type = SOAP_TYPE__ns1__ptzControlReq_Any;
			return soap_in__ns1__ptzControlReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptzControlReq"))
		{	*type = SOAP_TYPE__ns1__ptzControlReq;
			return soap_in__ns1__ptzControlReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceRes-Any"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceRes_Any;
			return soap_in__ns1__nullifyDeviceRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceRes"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceRes;
			return soap_in__ns1__nullifyDeviceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceReq-Any"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceReq_Any;
			return soap_in__ns1__nullifyDeviceReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:nullifyDeviceReq"))
		{	*type = SOAP_TYPE__ns1__nullifyDeviceReq;
			return soap_in__ns1__nullifyDeviceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceRes-Any"))
		{	*type = SOAP_TYPE__ns1__addDeviceRes_Any;
			return soap_in__ns1__addDeviceRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceRes"))
		{	*type = SOAP_TYPE__ns1__addDeviceRes;
			return soap_in__ns1__addDeviceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceReq-Any"))
		{	*type = SOAP_TYPE__ns1__addDeviceReq_Any;
			return soap_in__ns1__addDeviceReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceReq"))
		{	*type = SOAP_TYPE__ns1__addDeviceReq;
			return soap_in__ns1__addDeviceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateChannelNameRes-Any"))
		{	*type = SOAP_TYPE__ns1__updateChannelNameRes_Any;
			return soap_in__ns1__updateChannelNameRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateChannelNameRes"))
		{	*type = SOAP_TYPE__ns1__updateChannelNameRes;
			return soap_in__ns1__updateChannelNameRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateChannelNameReq-Any"))
		{	*type = SOAP_TYPE__ns1__updateChannelNameReq_Any;
			return soap_in__ns1__updateChannelNameReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateChannelNameReq"))
		{	*type = SOAP_TYPE__ns1__updateChannelNameReq;
			return soap_in__ns1__updateChannelNameReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogoutRes-Any"))
		{	*type = SOAP_TYPE__ns1__userLogoutRes_Any;
			return soap_in__ns1__userLogoutRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogoutRes"))
		{	*type = SOAP_TYPE__ns1__userLogoutRes;
			return soap_in__ns1__userLogoutRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogoutReq-Any"))
		{	*type = SOAP_TYPE__ns1__userLogoutReq_Any;
			return soap_in__ns1__userLogoutReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogoutReq"))
		{	*type = SOAP_TYPE__ns1__userLogoutReq;
			return soap_in__ns1__userLogoutReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginRes-Any"))
		{	*type = SOAP_TYPE__ns1__userLoginRes_Any;
			return soap_in__ns1__userLoginRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginRes"))
		{	*type = SOAP_TYPE__ns1__userLoginRes;
			return soap_in__ns1__userLoginRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginReq-Any"))
		{	*type = SOAP_TYPE__ns1__userLoginReq_Any;
			return soap_in__ns1__userLoginReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginReq"))
		{	*type = SOAP_TYPE__ns1__userLoginReq;
			return soap_in__ns1__userLoginReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:byeRes-Any"))
		{	*type = SOAP_TYPE__ns1__byeRes_Any;
			return soap_in__ns1__byeRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:byeRes"))
		{	*type = SOAP_TYPE__ns1__byeRes;
			return soap_in__ns1__byeRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:byeReq-Any"))
		{	*type = SOAP_TYPE__ns1__byeReq_Any;
			return soap_in__ns1__byeReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:byeReq"))
		{	*type = SOAP_TYPE__ns1__byeReq;
			return soap_in__ns1__byeReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteRes-Any"))
		{	*type = SOAP_TYPE__ns1__inviteRes_Any;
			return soap_in__ns1__inviteRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteRes"))
		{	*type = SOAP_TYPE__ns1__inviteRes;
			return soap_in__ns1__inviteRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteReq-Any"))
		{	*type = SOAP_TYPE__ns1__inviteReq_Any;
			return soap_in__ns1__inviteReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:inviteReq"))
		{	*type = SOAP_TYPE__ns1__inviteReq;
			return soap_in__ns1__inviteReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAuxiliaryRes-Any"))
		{	*type = SOAP_TYPE__ns1__setAuxiliaryRes_Any;
			return soap_in__ns1__setAuxiliaryRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAuxiliaryRes"))
		{	*type = SOAP_TYPE__ns1__setAuxiliaryRes;
			return soap_in__ns1__setAuxiliaryRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAuxiliaryReq-Any"))
		{	*type = SOAP_TYPE__ns1__setAuxiliaryReq_Any;
			return soap_in__ns1__setAuxiliaryReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setAuxiliaryReq"))
		{	*type = SOAP_TYPE__ns1__setAuxiliaryReq;
			return soap_in__ns1__setAuxiliaryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuxiliaryRes-Any"))
		{	*type = SOAP_TYPE__ns1__getAuxiliaryRes_Any;
			return soap_in__ns1__getAuxiliaryRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuxiliaryRes"))
		{	*type = SOAP_TYPE__ns1__getAuxiliaryRes;
			return soap_in__ns1__getAuxiliaryRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuxiliaryReq-Any"))
		{	*type = SOAP_TYPE__ns1__getAuxiliaryReq_Any;
			return soap_in__ns1__getAuxiliaryReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAuxiliaryReq"))
		{	*type = SOAP_TYPE__ns1__getAuxiliaryReq;
			return soap_in__ns1__getAuxiliaryReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBackPasswordRes-Any"))
		{	*type = SOAP_TYPE__ns1__getBackPasswordRes_Any;
			return soap_in__ns1__getBackPasswordRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBackPasswordRes"))
		{	*type = SOAP_TYPE__ns1__getBackPasswordRes;
			return soap_in__ns1__getBackPasswordRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBackPasswordReq-Any"))
		{	*type = SOAP_TYPE__ns1__getBackPasswordReq_Any;
			return soap_in__ns1__getBackPasswordReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBackPasswordReq"))
		{	*type = SOAP_TYPE__ns1__getBackPasswordReq;
			return soap_in__ns1__getBackPasswordReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountRes-Any"))
		{	*type = SOAP_TYPE__ns1__getAccountRes_Any;
			return soap_in__ns1__getAccountRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountRes"))
		{	*type = SOAP_TYPE__ns1__getAccountRes;
			return soap_in__ns1__getAccountRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountReq-Any"))
		{	*type = SOAP_TYPE__ns1__getAccountReq_Any;
			return soap_in__ns1__getAccountReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountReq"))
		{	*type = SOAP_TYPE__ns1__getAccountReq;
			return soap_in__ns1__getAccountReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAppleTokenRes-Any"))
		{	*type = SOAP_TYPE__ns1__updateAppleTokenRes_Any;
			return soap_in__ns1__updateAppleTokenRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAppleTokenRes"))
		{	*type = SOAP_TYPE__ns1__updateAppleTokenRes;
			return soap_in__ns1__updateAppleTokenRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAppleTokenReq-Any"))
		{	*type = SOAP_TYPE__ns1__updateAppleTokenReq_Any;
			return soap_in__ns1__updateAppleTokenReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAppleTokenReq"))
		{	*type = SOAP_TYPE__ns1__updateAppleTokenReq;
			return soap_in__ns1__updateAppleTokenReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceRes-Any"))
		{	*type = SOAP_TYPE__ns1__queryDeviceRes_Any;
			return soap_in__ns1__queryDeviceRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceRes"))
		{	*type = SOAP_TYPE__ns1__queryDeviceRes;
			return soap_in__ns1__queryDeviceRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceReq-Any"))
		{	*type = SOAP_TYPE__ns1__queryDeviceReq_Any;
			return soap_in__ns1__queryDeviceReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryDeviceReq"))
		{	*type = SOAP_TYPE__ns1__queryDeviceReq;
			return soap_in__ns1__queryDeviceReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePasswordRes-Any"))
		{	*type = SOAP_TYPE__ns1__updatePasswordRes_Any;
			return soap_in__ns1__updatePasswordRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePasswordRes"))
		{	*type = SOAP_TYPE__ns1__updatePasswordRes;
			return soap_in__ns1__updatePasswordRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePasswordReq-Any"))
		{	*type = SOAP_TYPE__ns1__updatePasswordReq_Any;
			return soap_in__ns1__updatePasswordReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePasswordReq"))
		{	*type = SOAP_TYPE__ns1__updatePasswordReq;
			return soap_in__ns1__updatePasswordReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountRes-Any"))
		{	*type = SOAP_TYPE__ns1__updateAccountRes_Any;
			return soap_in__ns1__updateAccountRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountRes"))
		{	*type = SOAP_TYPE__ns1__updateAccountRes;
			return soap_in__ns1__updateAccountRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountReq-Any"))
		{	*type = SOAP_TYPE__ns1__updateAccountReq_Any;
			return soap_in__ns1__updateAccountReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateAccountReq"))
		{	*type = SOAP_TYPE__ns1__updateAccountReq;
			return soap_in__ns1__updateAccountReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createAccountRes-Any"))
		{	*type = SOAP_TYPE__ns1__createAccountRes_Any;
			return soap_in__ns1__createAccountRes_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createAccountRes"))
		{	*type = SOAP_TYPE__ns1__createAccountRes;
			return soap_in__ns1__createAccountRes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createAccountReq-Any"))
		{	*type = SOAP_TYPE__ns1__createAccountReq_Any;
			return soap_in__ns1__createAccountReq_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createAccountReq"))
		{	*type = SOAP_TYPE__ns1__createAccountReq;
			return soap_in__ns1__createAccountReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VODRecord-Any"))
		{	*type = SOAP_TYPE__ns1__VODRecord_Any;
			return soap_in__ns1__VODRecord_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrivacyMaskRegion-Any"))
		{	*type = SOAP_TYPE__ns1__PrivacyMaskRegion_Any;
			return soap_in__ns1__PrivacyMaskRegion_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VMDGrid-Any"))
		{	*type = SOAP_TYPE__ns1__VMDGrid_Any;
			return soap_in__ns1__VMDGrid_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DevLog-Any"))
		{	*type = SOAP_TYPE__ns1__DevLog_Any;
			return soap_in__ns1__DevLog_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PuLog-Any"))
		{	*type = SOAP_TYPE__ns1__PuLog_Any;
			return soap_in__ns1__PuLog_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Device-Any"))
		{	*type = SOAP_TYPE__ns1__Device_Any;
			return soap_in__ns1__Device_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Dev-Any"))
		{	*type = SOAP_TYPE__ns1__Dev_Any;
			return soap_in__ns1__Dev_Any(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NodeDetails-Any"))
		{	*type = SOAP_TYPE__ns1__NodeDetails_Any;
			return soap_in__ns1__NodeDetails_Any(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__VideoStandard:
		return soap_out_ns1__VideoStandard(soap, tag, id, (const enum ns1__VideoStandard *)ptr, "ns1:VideoStandard");
	case SOAP_TYPE_ns1__RateType:
		return soap_out_ns1__RateType(soap, tag, id, (const enum ns1__RateType *)ptr, "ns1:RateType");
	case SOAP_TYPE_ns1__FrameSize:
		return soap_out_ns1__FrameSize(soap, tag, id, (const enum ns1__FrameSize *)ptr, "ns1:FrameSize");
	case SOAP_TYPE_ns1__PTZPreset:
		return soap_out_ns1__PTZPreset(soap, tag, id, (const enum ns1__PTZPreset *)ptr, "ns1:PTZPreset");
	case SOAP_TYPE_ns1__PTZLens:
		return soap_out_ns1__PTZLens(soap, tag, id, (const enum ns1__PTZLens *)ptr, "ns1:PTZLens");
	case SOAP_TYPE_ns1__PTZDirection:
		return soap_out_ns1__PTZDirection(soap, tag, id, (const enum ns1__PTZDirection *)ptr, "ns1:PTZDirection");
	case SOAP_TYPE_ns1__PwdType:
		return soap_out_ns1__PwdType(soap, tag, id, (const enum ns1__PwdType *)ptr, "ns1:PwdType");
	case SOAP_TYPE_ns1__StreamType:
		return soap_out_ns1__StreamType(soap, tag, id, (const enum ns1__StreamType *)ptr, "ns1:StreamType");
	case SOAP_TYPE_ns1__AuxiliaryState:
		return soap_out_ns1__AuxiliaryState(soap, tag, id, (const enum ns1__AuxiliaryState *)ptr, "ns1:AuxiliaryState");
	case SOAP_TYPE_ns1__AuxiliaryType:
		return soap_out_ns1__AuxiliaryType(soap, tag, id, (const enum ns1__AuxiliaryType *)ptr, "ns1:AuxiliaryType");
	case SOAP_TYPE_ns1__DeliveryType:
		return soap_out_ns1__DeliveryType(soap, tag, id, (const enum ns1__DeliveryType *)ptr, "ns1:DeliveryType");
	case SOAP_TYPE_ns1__MCUResult:
		return soap_out_ns1__MCUResult(soap, tag, id, (const enum ns1__MCUResult *)ptr, "ns1:MCUResult");
	case SOAP_TYPE_ns1__CountryAbbr2ISO3166:
		return soap_out_ns1__CountryAbbr2ISO3166(soap, tag, id, (const enum ns1__CountryAbbr2ISO3166 *)ptr, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__vodSearchRes_Any:
		return soap_out__ns1__vodSearchRes_Any(soap, "ns1:vodSearchRes-Any", id, (const struct _ns1__vodSearchRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__vodSearchRes:
		return soap_out__ns1__vodSearchRes(soap, "ns1:vodSearchRes", id, (const struct _ns1__vodSearchRes *)ptr, NULL);
	case SOAP_TYPE__ns1__vodSearchReq_Any:
		return soap_out__ns1__vodSearchReq_Any(soap, "ns1:vodSearchReq-Any", id, (const struct _ns1__vodSearchReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__vodSearchReq:
		return soap_out__ns1__vodSearchReq(soap, "ns1:vodSearchReq", id, (const struct _ns1__vodSearchReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getVODUrlRes_Any:
		return soap_out__ns1__getVODUrlRes_Any(soap, "ns1:getVODUrlRes-Any", id, (const struct _ns1__getVODUrlRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getVODUrlRes:
		return soap_out__ns1__getVODUrlRes(soap, "ns1:getVODUrlRes", id, (const struct _ns1__getVODUrlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getVODUrlReq_Any:
		return soap_out__ns1__getVODUrlReq_Any(soap, "ns1:getVODUrlReq-Any", id, (const struct _ns1__getVODUrlReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getVODUrlReq:
		return soap_out__ns1__getVODUrlReq(soap, "ns1:getVODUrlReq", id, (const struct _ns1__getVODUrlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getPlayUrlRes_Any:
		return soap_out__ns1__getPlayUrlRes_Any(soap, "ns1:getPlayUrlRes-Any", id, (const struct _ns1__getPlayUrlRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getPlayUrlRes:
		return soap_out__ns1__getPlayUrlRes(soap, "ns1:getPlayUrlRes", id, (const struct _ns1__getPlayUrlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getPlayUrlReq_Any:
		return soap_out__ns1__getPlayUrlReq_Any(soap, "ns1:getPlayUrlReq-Any", id, (const struct _ns1__getPlayUrlReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getPlayUrlReq:
		return soap_out__ns1__getPlayUrlReq(soap, "ns1:getPlayUrlReq", id, (const struct _ns1__getPlayUrlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any:
		return soap_out__ns1__setPrivacyMaskParamRes_Any(soap, "ns1:setPrivacyMaskParamRes-Any", id, (const struct _ns1__setPrivacyMaskParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setPrivacyMaskParamRes:
		return soap_out__ns1__setPrivacyMaskParamRes(soap, "ns1:setPrivacyMaskParamRes", id, (const struct _ns1__setPrivacyMaskParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any:
		return soap_out__ns1__setPrivacyMaskParamReq_Any(soap, "ns1:setPrivacyMaskParamReq-Any", id, (const struct _ns1__setPrivacyMaskParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setPrivacyMaskParamReq:
		return soap_out__ns1__setPrivacyMaskParamReq(soap, "ns1:setPrivacyMaskParamReq", id, (const struct _ns1__setPrivacyMaskParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any:
		return soap_out__ns1__getPrivacyMaskParamRes_Any(soap, "ns1:getPrivacyMaskParamRes-Any", id, (const struct _ns1__getPrivacyMaskParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getPrivacyMaskParamRes:
		return soap_out__ns1__getPrivacyMaskParamRes(soap, "ns1:getPrivacyMaskParamRes", id, (const struct _ns1__getPrivacyMaskParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any:
		return soap_out__ns1__getPrivacyMaskParamReq_Any(soap, "ns1:getPrivacyMaskParamReq-Any", id, (const struct _ns1__getPrivacyMaskParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getPrivacyMaskParamReq:
		return soap_out__ns1__getPrivacyMaskParamReq(soap, "ns1:getPrivacyMaskParamReq", id, (const struct _ns1__getPrivacyMaskParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setVMDParamRes_Any:
		return soap_out__ns1__setVMDParamRes_Any(soap, "ns1:setVMDParamRes-Any", id, (const struct _ns1__setVMDParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setVMDParamRes:
		return soap_out__ns1__setVMDParamRes(soap, "ns1:setVMDParamRes", id, (const struct _ns1__setVMDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setVMDParamReq_Any:
		return soap_out__ns1__setVMDParamReq_Any(soap, "ns1:setVMDParamReq-Any", id, (const struct _ns1__setVMDParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setVMDParamReq:
		return soap_out__ns1__setVMDParamReq(soap, "ns1:setVMDParamReq", id, (const struct _ns1__setVMDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getVMDParamRes_Any:
		return soap_out__ns1__getVMDParamRes_Any(soap, "ns1:getVMDParamRes-Any", id, (const struct _ns1__getVMDParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getVMDParamRes:
		return soap_out__ns1__getVMDParamRes(soap, "ns1:getVMDParamRes", id, (const struct _ns1__getVMDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getVMDParamReq_Any:
		return soap_out__ns1__getVMDParamReq_Any(soap, "ns1:getVMDParamReq-Any", id, (const struct _ns1__getVMDParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getVMDParamReq:
		return soap_out__ns1__getVMDParamReq(soap, "ns1:getVMDParamReq", id, (const struct _ns1__getVMDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setTimeRes_Any:
		return soap_out__ns1__setTimeRes_Any(soap, "ns1:setTimeRes-Any", id, (const struct _ns1__setTimeRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setTimeRes:
		return soap_out__ns1__setTimeRes(soap, "ns1:setTimeRes", id, (const struct _ns1__setTimeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setTimeReq_Any:
		return soap_out__ns1__setTimeReq_Any(soap, "ns1:setTimeReq-Any", id, (const struct _ns1__setTimeReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setTimeReq:
		return soap_out__ns1__setTimeReq(soap, "ns1:setTimeReq", id, (const struct _ns1__setTimeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getTimeRes_Any:
		return soap_out__ns1__getTimeRes_Any(soap, "ns1:getTimeRes-Any", id, (const struct _ns1__getTimeRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getTimeRes:
		return soap_out__ns1__getTimeRes(soap, "ns1:getTimeRes", id, (const struct _ns1__getTimeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getTimeReq_Any:
		return soap_out__ns1__getTimeReq_Any(soap, "ns1:getTimeReq-Any", id, (const struct _ns1__getTimeReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getTimeReq:
		return soap_out__ns1__getTimeReq(soap, "ns1:getTimeReq", id, (const struct _ns1__getTimeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setOSDParamRes_Any:
		return soap_out__ns1__setOSDParamRes_Any(soap, "ns1:setOSDParamRes-Any", id, (const struct _ns1__setOSDParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setOSDParamRes:
		return soap_out__ns1__setOSDParamRes(soap, "ns1:setOSDParamRes", id, (const struct _ns1__setOSDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setOSDParamReq_Any:
		return soap_out__ns1__setOSDParamReq_Any(soap, "ns1:setOSDParamReq-Any", id, (const struct _ns1__setOSDParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setOSDParamReq:
		return soap_out__ns1__setOSDParamReq(soap, "ns1:setOSDParamReq", id, (const struct _ns1__setOSDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getOSDParamRes_Any:
		return soap_out__ns1__getOSDParamRes_Any(soap, "ns1:getOSDParamRes-Any", id, (const struct _ns1__getOSDParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getOSDParamRes:
		return soap_out__ns1__getOSDParamRes(soap, "ns1:getOSDParamRes", id, (const struct _ns1__getOSDParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getOSDParamReq_Any:
		return soap_out__ns1__getOSDParamReq_Any(soap, "ns1:getOSDParamReq-Any", id, (const struct _ns1__getOSDParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getOSDParamReq:
		return soap_out__ns1__getOSDParamReq(soap, "ns1:getOSDParamReq", id, (const struct _ns1__getOSDParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setVideoParamRes_Any:
		return soap_out__ns1__setVideoParamRes_Any(soap, "ns1:setVideoParamRes-Any", id, (const struct _ns1__setVideoParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setVideoParamRes:
		return soap_out__ns1__setVideoParamRes(soap, "ns1:setVideoParamRes", id, (const struct _ns1__setVideoParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setVideoParamReq_Any:
		return soap_out__ns1__setVideoParamReq_Any(soap, "ns1:setVideoParamReq-Any", id, (const struct _ns1__setVideoParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setVideoParamReq:
		return soap_out__ns1__setVideoParamReq(soap, "ns1:setVideoParamReq", id, (const struct _ns1__setVideoParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getVideoParamRes_Any:
		return soap_out__ns1__getVideoParamRes_Any(soap, "ns1:getVideoParamRes-Any", id, (const struct _ns1__getVideoParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getVideoParamRes:
		return soap_out__ns1__getVideoParamRes(soap, "ns1:getVideoParamRes", id, (const struct _ns1__getVideoParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getVideoParamReq_Any:
		return soap_out__ns1__getVideoParamReq_Any(soap, "ns1:getVideoParamReq-Any", id, (const struct _ns1__getVideoParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getVideoParamReq:
		return soap_out__ns1__getVideoParamReq(soap, "ns1:getVideoParamReq", id, (const struct _ns1__getVideoParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDevLogRes_Any:
		return soap_out__ns1__queryDevLogRes_Any(soap, "ns1:queryDevLogRes-Any", id, (const struct _ns1__queryDevLogRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDevLogRes:
		return soap_out__ns1__queryDevLogRes(soap, "ns1:queryDevLogRes", id, (const struct _ns1__queryDevLogRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDevLogReq_Any:
		return soap_out__ns1__queryDevLogReq_Any(soap, "ns1:queryDevLogReq-Any", id, (const struct _ns1__queryDevLogReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDevLogReq:
		return soap_out__ns1__queryDevLogReq(soap, "ns1:queryDevLogReq", id, (const struct _ns1__queryDevLogReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryLogRes_Any:
		return soap_out__ns1__queryLogRes_Any(soap, "ns1:queryLogRes-Any", id, (const struct _ns1__queryLogRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__queryLogRes:
		return soap_out__ns1__queryLogRes(soap, "ns1:queryLogRes", id, (const struct _ns1__queryLogRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryLogReq_Any:
		return soap_out__ns1__queryLogReq_Any(soap, "ns1:queryLogReq-Any", id, (const struct _ns1__queryLogReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__queryLogReq:
		return soap_out__ns1__queryLogReq(soap, "ns1:queryLogReq", id, (const struct _ns1__queryLogReq *)ptr, NULL);
	case SOAP_TYPE__ns1__upgradeDevVerRes_Any:
		return soap_out__ns1__upgradeDevVerRes_Any(soap, "ns1:upgradeDevVerRes-Any", id, (const struct _ns1__upgradeDevVerRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__upgradeDevVerRes:
		return soap_out__ns1__upgradeDevVerRes(soap, "ns1:upgradeDevVerRes", id, (const struct _ns1__upgradeDevVerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__upgradeDevVerReq_Any:
		return soap_out__ns1__upgradeDevVerReq_Any(soap, "ns1:upgradeDevVerReq-Any", id, (const struct _ns1__upgradeDevVerReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__upgradeDevVerReq:
		return soap_out__ns1__upgradeDevVerReq(soap, "ns1:upgradeDevVerReq", id, (const struct _ns1__upgradeDevVerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getDevVerRes_Any:
		return soap_out__ns1__getDevVerRes_Any(soap, "ns1:getDevVerRes-Any", id, (const struct _ns1__getDevVerRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getDevVerRes:
		return soap_out__ns1__getDevVerRes(soap, "ns1:getDevVerRes", id, (const struct _ns1__getDevVerRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getDevVerReq_Any:
		return soap_out__ns1__getDevVerReq_Any(soap, "ns1:getDevVerReq-Any", id, (const struct _ns1__getDevVerReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getDevVerReq:
		return soap_out__ns1__getDevVerReq(soap, "ns1:getDevVerReq", id, (const struct _ns1__getDevVerReq *)ptr, NULL);
	case SOAP_TYPE__ns1__rebootRes_Any:
		return soap_out__ns1__rebootRes_Any(soap, "ns1:rebootRes-Any", id, (const struct _ns1__rebootRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__rebootRes:
		return soap_out__ns1__rebootRes(soap, "ns1:rebootRes", id, (const struct _ns1__rebootRes *)ptr, NULL);
	case SOAP_TYPE__ns1__rebootReq_Any:
		return soap_out__ns1__rebootReq_Any(soap, "ns1:rebootReq-Any", id, (const struct _ns1__rebootReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__rebootReq:
		return soap_out__ns1__rebootReq(soap, "ns1:rebootReq", id, (const struct _ns1__rebootReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setCodingParamRes_Any:
		return soap_out__ns1__setCodingParamRes_Any(soap, "ns1:setCodingParamRes-Any", id, (const struct _ns1__setCodingParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setCodingParamRes:
		return soap_out__ns1__setCodingParamRes(soap, "ns1:setCodingParamRes", id, (const struct _ns1__setCodingParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setCodingParamReq_Any:
		return soap_out__ns1__setCodingParamReq_Any(soap, "ns1:setCodingParamReq-Any", id, (const struct _ns1__setCodingParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setCodingParamReq:
		return soap_out__ns1__setCodingParamReq(soap, "ns1:setCodingParamReq", id, (const struct _ns1__setCodingParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getCodingParamRes_Any:
		return soap_out__ns1__getCodingParamRes_Any(soap, "ns1:getCodingParamRes-Any", id, (const struct _ns1__getCodingParamRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getCodingParamRes:
		return soap_out__ns1__getCodingParamRes(soap, "ns1:getCodingParamRes", id, (const struct _ns1__getCodingParamRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getCodingParamReq_Any:
		return soap_out__ns1__getCodingParamReq_Any(soap, "ns1:getCodingParamReq-Any", id, (const struct _ns1__getCodingParamReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getCodingParamReq:
		return soap_out__ns1__getCodingParamReq(soap, "ns1:getCodingParamReq", id, (const struct _ns1__getCodingParamReq *)ptr, NULL);
	case SOAP_TYPE__ns1__presetControlRes_Any:
		return soap_out__ns1__presetControlRes_Any(soap, "ns1:presetControlRes-Any", id, (const struct _ns1__presetControlRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__presetControlRes:
		return soap_out__ns1__presetControlRes(soap, "ns1:presetControlRes", id, (const struct _ns1__presetControlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__presetControlReq_Any:
		return soap_out__ns1__presetControlReq_Any(soap, "ns1:presetControlReq-Any", id, (const struct _ns1__presetControlReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__presetControlReq:
		return soap_out__ns1__presetControlReq(soap, "ns1:presetControlReq", id, (const struct _ns1__presetControlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__lensControlRes_Any:
		return soap_out__ns1__lensControlRes_Any(soap, "ns1:lensControlRes-Any", id, (const struct _ns1__lensControlRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__lensControlRes:
		return soap_out__ns1__lensControlRes(soap, "ns1:lensControlRes", id, (const struct _ns1__lensControlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__lensControlReq_Any:
		return soap_out__ns1__lensControlReq_Any(soap, "ns1:lensControlReq-Any", id, (const struct _ns1__lensControlReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__lensControlReq:
		return soap_out__ns1__lensControlReq(soap, "ns1:lensControlReq", id, (const struct _ns1__lensControlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__ptzControlRes_Any:
		return soap_out__ns1__ptzControlRes_Any(soap, "ns1:ptzControlRes-Any", id, (const struct _ns1__ptzControlRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__ptzControlRes:
		return soap_out__ns1__ptzControlRes(soap, "ns1:ptzControlRes", id, (const struct _ns1__ptzControlRes *)ptr, NULL);
	case SOAP_TYPE__ns1__ptzControlReq_Any:
		return soap_out__ns1__ptzControlReq_Any(soap, "ns1:ptzControlReq-Any", id, (const struct _ns1__ptzControlReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__ptzControlReq:
		return soap_out__ns1__ptzControlReq(soap, "ns1:ptzControlReq", id, (const struct _ns1__ptzControlReq *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceRes_Any:
		return soap_out__ns1__nullifyDeviceRes_Any(soap, "ns1:nullifyDeviceRes-Any", id, (const struct _ns1__nullifyDeviceRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceRes:
		return soap_out__ns1__nullifyDeviceRes(soap, "ns1:nullifyDeviceRes", id, (const struct _ns1__nullifyDeviceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceReq_Any:
		return soap_out__ns1__nullifyDeviceReq_Any(soap, "ns1:nullifyDeviceReq-Any", id, (const struct _ns1__nullifyDeviceReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__nullifyDeviceReq:
		return soap_out__ns1__nullifyDeviceReq(soap, "ns1:nullifyDeviceReq", id, (const struct _ns1__nullifyDeviceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceRes_Any:
		return soap_out__ns1__addDeviceRes_Any(soap, "ns1:addDeviceRes-Any", id, (const struct _ns1__addDeviceRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceRes:
		return soap_out__ns1__addDeviceRes(soap, "ns1:addDeviceRes", id, (const struct _ns1__addDeviceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceReq_Any:
		return soap_out__ns1__addDeviceReq_Any(soap, "ns1:addDeviceReq-Any", id, (const struct _ns1__addDeviceReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__addDeviceReq:
		return soap_out__ns1__addDeviceReq(soap, "ns1:addDeviceReq", id, (const struct _ns1__addDeviceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateChannelNameRes_Any:
		return soap_out__ns1__updateChannelNameRes_Any(soap, "ns1:updateChannelNameRes-Any", id, (const struct _ns1__updateChannelNameRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updateChannelNameRes:
		return soap_out__ns1__updateChannelNameRes(soap, "ns1:updateChannelNameRes", id, (const struct _ns1__updateChannelNameRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateChannelNameReq_Any:
		return soap_out__ns1__updateChannelNameReq_Any(soap, "ns1:updateChannelNameReq-Any", id, (const struct _ns1__updateChannelNameReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updateChannelNameReq:
		return soap_out__ns1__updateChannelNameReq(soap, "ns1:updateChannelNameReq", id, (const struct _ns1__updateChannelNameReq *)ptr, NULL);
	case SOAP_TYPE__ns1__userLogoutRes_Any:
		return soap_out__ns1__userLogoutRes_Any(soap, "ns1:userLogoutRes-Any", id, (const struct _ns1__userLogoutRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__userLogoutRes:
		return soap_out__ns1__userLogoutRes(soap, "ns1:userLogoutRes", id, (const struct _ns1__userLogoutRes *)ptr, NULL);
	case SOAP_TYPE__ns1__userLogoutReq_Any:
		return soap_out__ns1__userLogoutReq_Any(soap, "ns1:userLogoutReq-Any", id, (const struct _ns1__userLogoutReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__userLogoutReq:
		return soap_out__ns1__userLogoutReq(soap, "ns1:userLogoutReq", id, (const struct _ns1__userLogoutReq *)ptr, NULL);
	case SOAP_TYPE__ns1__userLoginRes_Any:
		return soap_out__ns1__userLoginRes_Any(soap, "ns1:userLoginRes-Any", id, (const struct _ns1__userLoginRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__userLoginRes:
		return soap_out__ns1__userLoginRes(soap, "ns1:userLoginRes", id, (const struct _ns1__userLoginRes *)ptr, NULL);
	case SOAP_TYPE__ns1__userLoginReq_Any:
		return soap_out__ns1__userLoginReq_Any(soap, "ns1:userLoginReq-Any", id, (const struct _ns1__userLoginReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__userLoginReq:
		return soap_out__ns1__userLoginReq(soap, "ns1:userLoginReq", id, (const struct _ns1__userLoginReq *)ptr, NULL);
	case SOAP_TYPE__ns1__byeRes_Any:
		return soap_out__ns1__byeRes_Any(soap, "ns1:byeRes-Any", id, (const struct _ns1__byeRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__byeRes:
		return soap_out__ns1__byeRes(soap, "ns1:byeRes", id, (const struct _ns1__byeRes *)ptr, NULL);
	case SOAP_TYPE__ns1__byeReq_Any:
		return soap_out__ns1__byeReq_Any(soap, "ns1:byeReq-Any", id, (const struct _ns1__byeReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__byeReq:
		return soap_out__ns1__byeReq(soap, "ns1:byeReq", id, (const struct _ns1__byeReq *)ptr, NULL);
	case SOAP_TYPE__ns1__inviteRes_Any:
		return soap_out__ns1__inviteRes_Any(soap, "ns1:inviteRes-Any", id, (const struct _ns1__inviteRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__inviteRes:
		return soap_out__ns1__inviteRes(soap, "ns1:inviteRes", id, (const struct _ns1__inviteRes *)ptr, NULL);
	case SOAP_TYPE__ns1__inviteReq_Any:
		return soap_out__ns1__inviteReq_Any(soap, "ns1:inviteReq-Any", id, (const struct _ns1__inviteReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__inviteReq:
		return soap_out__ns1__inviteReq(soap, "ns1:inviteReq", id, (const struct _ns1__inviteReq *)ptr, NULL);
	case SOAP_TYPE__ns1__setAuxiliaryRes_Any:
		return soap_out__ns1__setAuxiliaryRes_Any(soap, "ns1:setAuxiliaryRes-Any", id, (const struct _ns1__setAuxiliaryRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setAuxiliaryRes:
		return soap_out__ns1__setAuxiliaryRes(soap, "ns1:setAuxiliaryRes", id, (const struct _ns1__setAuxiliaryRes *)ptr, NULL);
	case SOAP_TYPE__ns1__setAuxiliaryReq_Any:
		return soap_out__ns1__setAuxiliaryReq_Any(soap, "ns1:setAuxiliaryReq-Any", id, (const struct _ns1__setAuxiliaryReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__setAuxiliaryReq:
		return soap_out__ns1__setAuxiliaryReq(soap, "ns1:setAuxiliaryReq", id, (const struct _ns1__setAuxiliaryReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getAuxiliaryRes_Any:
		return soap_out__ns1__getAuxiliaryRes_Any(soap, "ns1:getAuxiliaryRes-Any", id, (const struct _ns1__getAuxiliaryRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getAuxiliaryRes:
		return soap_out__ns1__getAuxiliaryRes(soap, "ns1:getAuxiliaryRes", id, (const struct _ns1__getAuxiliaryRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getAuxiliaryReq_Any:
		return soap_out__ns1__getAuxiliaryReq_Any(soap, "ns1:getAuxiliaryReq-Any", id, (const struct _ns1__getAuxiliaryReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getAuxiliaryReq:
		return soap_out__ns1__getAuxiliaryReq(soap, "ns1:getAuxiliaryReq", id, (const struct _ns1__getAuxiliaryReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getBackPasswordRes_Any:
		return soap_out__ns1__getBackPasswordRes_Any(soap, "ns1:getBackPasswordRes-Any", id, (const struct _ns1__getBackPasswordRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getBackPasswordRes:
		return soap_out__ns1__getBackPasswordRes(soap, "ns1:getBackPasswordRes", id, (const struct _ns1__getBackPasswordRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getBackPasswordReq_Any:
		return soap_out__ns1__getBackPasswordReq_Any(soap, "ns1:getBackPasswordReq-Any", id, (const struct _ns1__getBackPasswordReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getBackPasswordReq:
		return soap_out__ns1__getBackPasswordReq(soap, "ns1:getBackPasswordReq", id, (const struct _ns1__getBackPasswordReq *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountRes_Any:
		return soap_out__ns1__getAccountRes_Any(soap, "ns1:getAccountRes-Any", id, (const struct _ns1__getAccountRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountRes:
		return soap_out__ns1__getAccountRes(soap, "ns1:getAccountRes", id, (const struct _ns1__getAccountRes *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountReq_Any:
		return soap_out__ns1__getAccountReq_Any(soap, "ns1:getAccountReq-Any", id, (const struct _ns1__getAccountReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__getAccountReq:
		return soap_out__ns1__getAccountReq(soap, "ns1:getAccountReq", id, (const struct _ns1__getAccountReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAppleTokenRes_Any:
		return soap_out__ns1__updateAppleTokenRes_Any(soap, "ns1:updateAppleTokenRes-Any", id, (const struct _ns1__updateAppleTokenRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAppleTokenRes:
		return soap_out__ns1__updateAppleTokenRes(soap, "ns1:updateAppleTokenRes", id, (const struct _ns1__updateAppleTokenRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAppleTokenReq_Any:
		return soap_out__ns1__updateAppleTokenReq_Any(soap, "ns1:updateAppleTokenReq-Any", id, (const struct _ns1__updateAppleTokenReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAppleTokenReq:
		return soap_out__ns1__updateAppleTokenReq(soap, "ns1:updateAppleTokenReq", id, (const struct _ns1__updateAppleTokenReq *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceRes_Any:
		return soap_out__ns1__queryDeviceRes_Any(soap, "ns1:queryDeviceRes-Any", id, (const struct _ns1__queryDeviceRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceRes:
		return soap_out__ns1__queryDeviceRes(soap, "ns1:queryDeviceRes", id, (const struct _ns1__queryDeviceRes *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceReq_Any:
		return soap_out__ns1__queryDeviceReq_Any(soap, "ns1:queryDeviceReq-Any", id, (const struct _ns1__queryDeviceReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__queryDeviceReq:
		return soap_out__ns1__queryDeviceReq(soap, "ns1:queryDeviceReq", id, (const struct _ns1__queryDeviceReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updatePasswordRes_Any:
		return soap_out__ns1__updatePasswordRes_Any(soap, "ns1:updatePasswordRes-Any", id, (const struct _ns1__updatePasswordRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updatePasswordRes:
		return soap_out__ns1__updatePasswordRes(soap, "ns1:updatePasswordRes", id, (const struct _ns1__updatePasswordRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updatePasswordReq_Any:
		return soap_out__ns1__updatePasswordReq_Any(soap, "ns1:updatePasswordReq-Any", id, (const struct _ns1__updatePasswordReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updatePasswordReq:
		return soap_out__ns1__updatePasswordReq(soap, "ns1:updatePasswordReq", id, (const struct _ns1__updatePasswordReq *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountRes_Any:
		return soap_out__ns1__updateAccountRes_Any(soap, "ns1:updateAccountRes-Any", id, (const struct _ns1__updateAccountRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountRes:
		return soap_out__ns1__updateAccountRes(soap, "ns1:updateAccountRes", id, (const struct _ns1__updateAccountRes *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountReq_Any:
		return soap_out__ns1__updateAccountReq_Any(soap, "ns1:updateAccountReq-Any", id, (const struct _ns1__updateAccountReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__updateAccountReq:
		return soap_out__ns1__updateAccountReq(soap, "ns1:updateAccountReq", id, (const struct _ns1__updateAccountReq *)ptr, NULL);
	case SOAP_TYPE__ns1__createAccountRes_Any:
		return soap_out__ns1__createAccountRes_Any(soap, "ns1:createAccountRes-Any", id, (const struct _ns1__createAccountRes_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__createAccountRes:
		return soap_out__ns1__createAccountRes(soap, "ns1:createAccountRes", id, (const struct _ns1__createAccountRes *)ptr, NULL);
	case SOAP_TYPE__ns1__createAccountReq_Any:
		return soap_out__ns1__createAccountReq_Any(soap, "ns1:createAccountReq-Any", id, (const struct _ns1__createAccountReq_Any *)ptr, NULL);
	case SOAP_TYPE__ns1__createAccountReq:
		return soap_out__ns1__createAccountReq(soap, "ns1:createAccountReq", id, (const struct _ns1__createAccountReq *)ptr, NULL);
	case SOAP_TYPE__ns1__VODRecord_Any:
		return soap_out__ns1__VODRecord_Any(soap, "ns1:VODRecord-Any", id, (const struct _ns1__VODRecord_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__VODRecord:
		return soap_out_ns1__VODRecord(soap, tag, id, (const struct ns1__VODRecord *)ptr, "ns1:VODRecord");
	case SOAP_TYPE__ns1__PrivacyMaskRegion_Any:
		return soap_out__ns1__PrivacyMaskRegion_Any(soap, "ns1:PrivacyMaskRegion-Any", id, (const struct _ns1__PrivacyMaskRegion_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__PrivacyMaskRegion:
		return soap_out_ns1__PrivacyMaskRegion(soap, tag, id, (const struct ns1__PrivacyMaskRegion *)ptr, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE__ns1__VMDGrid_Any:
		return soap_out__ns1__VMDGrid_Any(soap, "ns1:VMDGrid-Any", id, (const struct _ns1__VMDGrid_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__VMDGrid:
		return soap_out_ns1__VMDGrid(soap, tag, id, (const struct ns1__VMDGrid *)ptr, "ns1:VMDGrid");
	case SOAP_TYPE__ns1__DevLog_Any:
		return soap_out__ns1__DevLog_Any(soap, "ns1:DevLog-Any", id, (const struct _ns1__DevLog_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__DevLog:
		return soap_out_ns1__DevLog(soap, tag, id, (const struct ns1__DevLog *)ptr, "ns1:DevLog");
	case SOAP_TYPE_ns1__ArrayOfDevLog:
		return soap_out_ns1__ArrayOfDevLog(soap, tag, id, (const struct ns1__ArrayOfDevLog *)ptr, "ns1:ArrayOfDevLog");
	case SOAP_TYPE__ns1__PuLog_Any:
		return soap_out__ns1__PuLog_Any(soap, "ns1:PuLog-Any", id, (const struct _ns1__PuLog_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__PuLog:
		return soap_out_ns1__PuLog(soap, tag, id, (const struct ns1__PuLog *)ptr, "ns1:PuLog");
	case SOAP_TYPE_ns1__ArrayOfPuLog:
		return soap_out_ns1__ArrayOfPuLog(soap, tag, id, (const struct ns1__ArrayOfPuLog *)ptr, "ns1:ArrayOfPuLog");
	case SOAP_TYPE__ns1__Device_Any:
		return soap_out__ns1__Device_Any(soap, "ns1:Device-Any", id, (const struct _ns1__Device_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__Device:
		return soap_out_ns1__Device(soap, tag, id, (const struct ns1__Device *)ptr, "ns1:Device");
	case SOAP_TYPE_ns1__ArrayOfDevice:
		return soap_out_ns1__ArrayOfDevice(soap, tag, id, (const struct ns1__ArrayOfDevice *)ptr, "ns1:ArrayOfDevice");
	case SOAP_TYPE__ns1__Dev_Any:
		return soap_out__ns1__Dev_Any(soap, "ns1:Dev-Any", id, (const struct _ns1__Dev_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__Dev:
		return soap_out_ns1__Dev(soap, tag, id, (const struct ns1__Dev *)ptr, "ns1:Dev");
	case SOAP_TYPE_ns1__ArrayOfDev:
		return soap_out_ns1__ArrayOfDev(soap, tag, id, (const struct ns1__ArrayOfDev *)ptr, "ns1:ArrayOfDev");
	case SOAP_TYPE__ns1__NodeDetails_Any:
		return soap_out__ns1__NodeDetails_Any(soap, "ns1:NodeDetails-Any", id, (const struct _ns1__NodeDetails_Any *)ptr, NULL);
	case SOAP_TYPE_ns1__NodeDetails:
		return soap_out_ns1__NodeDetails(soap, tag, id, (const struct ns1__NodeDetails *)ptr, "ns1:NodeDetails");
	case SOAP_TYPE_ns1__ArrayOfNodeDetails:
		return soap_out_ns1__ArrayOfNodeDetails(soap, tag, id, (const struct ns1__ArrayOfNodeDetails *)ptr, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes:
		return soap_out_PointerTo_ns1__vodSearchRes(soap, tag, id, (struct _ns1__vodSearchRes *const*)ptr, "ns1:vodSearchRes");
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq:
		return soap_out_PointerTo_ns1__vodSearchReq(soap, tag, id, (struct _ns1__vodSearchReq *const*)ptr, "ns1:vodSearchReq");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes:
		return soap_out_PointerTo_ns1__getVODUrlRes(soap, tag, id, (struct _ns1__getVODUrlRes *const*)ptr, "ns1:getVODUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq:
		return soap_out_PointerTo_ns1__getVODUrlReq(soap, tag, id, (struct _ns1__getVODUrlReq *const*)ptr, "ns1:getVODUrlReq");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes:
		return soap_out_PointerTo_ns1__getPlayUrlRes(soap, tag, id, (struct _ns1__getPlayUrlRes *const*)ptr, "ns1:getPlayUrlRes");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq:
		return soap_out_PointerTo_ns1__getPlayUrlReq(soap, tag, id, (struct _ns1__getPlayUrlReq *const*)ptr, "ns1:getPlayUrlReq");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes:
		return soap_out_PointerTo_ns1__setPrivacyMaskParamRes(soap, tag, id, (struct _ns1__setPrivacyMaskParamRes *const*)ptr, "ns1:setPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq:
		return soap_out_PointerTo_ns1__setPrivacyMaskParamReq(soap, tag, id, (struct _ns1__setPrivacyMaskParamReq *const*)ptr, "ns1:setPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes:
		return soap_out_PointerTo_ns1__getPrivacyMaskParamRes(soap, tag, id, (struct _ns1__getPrivacyMaskParamRes *const*)ptr, "ns1:getPrivacyMaskParamRes");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq:
		return soap_out_PointerTo_ns1__getPrivacyMaskParamReq(soap, tag, id, (struct _ns1__getPrivacyMaskParamReq *const*)ptr, "ns1:getPrivacyMaskParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes:
		return soap_out_PointerTo_ns1__setVMDParamRes(soap, tag, id, (struct _ns1__setVMDParamRes *const*)ptr, "ns1:setVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq:
		return soap_out_PointerTo_ns1__setVMDParamReq(soap, tag, id, (struct _ns1__setVMDParamReq *const*)ptr, "ns1:setVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes:
		return soap_out_PointerTo_ns1__getVMDParamRes(soap, tag, id, (struct _ns1__getVMDParamRes *const*)ptr, "ns1:getVMDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq:
		return soap_out_PointerTo_ns1__getVMDParamReq(soap, tag, id, (struct _ns1__getVMDParamReq *const*)ptr, "ns1:getVMDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setTimeRes:
		return soap_out_PointerTo_ns1__setTimeRes(soap, tag, id, (struct _ns1__setTimeRes *const*)ptr, "ns1:setTimeRes");
	case SOAP_TYPE_PointerTo_ns1__setTimeReq:
		return soap_out_PointerTo_ns1__setTimeReq(soap, tag, id, (struct _ns1__setTimeReq *const*)ptr, "ns1:setTimeReq");
	case SOAP_TYPE_PointerTo_ns1__getTimeRes:
		return soap_out_PointerTo_ns1__getTimeRes(soap, tag, id, (struct _ns1__getTimeRes *const*)ptr, "ns1:getTimeRes");
	case SOAP_TYPE_PointerTo_ns1__getTimeReq:
		return soap_out_PointerTo_ns1__getTimeReq(soap, tag, id, (struct _ns1__getTimeReq *const*)ptr, "ns1:getTimeReq");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes:
		return soap_out_PointerTo_ns1__setOSDParamRes(soap, tag, id, (struct _ns1__setOSDParamRes *const*)ptr, "ns1:setOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq:
		return soap_out_PointerTo_ns1__setOSDParamReq(soap, tag, id, (struct _ns1__setOSDParamReq *const*)ptr, "ns1:setOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes:
		return soap_out_PointerTo_ns1__getOSDParamRes(soap, tag, id, (struct _ns1__getOSDParamRes *const*)ptr, "ns1:getOSDParamRes");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq:
		return soap_out_PointerTo_ns1__getOSDParamReq(soap, tag, id, (struct _ns1__getOSDParamReq *const*)ptr, "ns1:getOSDParamReq");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes:
		return soap_out_PointerTo_ns1__setVideoParamRes(soap, tag, id, (struct _ns1__setVideoParamRes *const*)ptr, "ns1:setVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq:
		return soap_out_PointerTo_ns1__setVideoParamReq(soap, tag, id, (struct _ns1__setVideoParamReq *const*)ptr, "ns1:setVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes:
		return soap_out_PointerTo_ns1__getVideoParamRes(soap, tag, id, (struct _ns1__getVideoParamRes *const*)ptr, "ns1:getVideoParamRes");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq:
		return soap_out_PointerTo_ns1__getVideoParamReq(soap, tag, id, (struct _ns1__getVideoParamReq *const*)ptr, "ns1:getVideoParamReq");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes:
		return soap_out_PointerTo_ns1__queryDevLogRes(soap, tag, id, (struct _ns1__queryDevLogRes *const*)ptr, "ns1:queryDevLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq:
		return soap_out_PointerTo_ns1__queryDevLogReq(soap, tag, id, (struct _ns1__queryDevLogReq *const*)ptr, "ns1:queryDevLogReq");
	case SOAP_TYPE_PointerTo_ns1__queryLogRes:
		return soap_out_PointerTo_ns1__queryLogRes(soap, tag, id, (struct _ns1__queryLogRes *const*)ptr, "ns1:queryLogRes");
	case SOAP_TYPE_PointerTo_ns1__queryLogReq:
		return soap_out_PointerTo_ns1__queryLogReq(soap, tag, id, (struct _ns1__queryLogReq *const*)ptr, "ns1:queryLogReq");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes:
		return soap_out_PointerTo_ns1__upgradeDevVerRes(soap, tag, id, (struct _ns1__upgradeDevVerRes *const*)ptr, "ns1:upgradeDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq:
		return soap_out_PointerTo_ns1__upgradeDevVerReq(soap, tag, id, (struct _ns1__upgradeDevVerReq *const*)ptr, "ns1:upgradeDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes:
		return soap_out_PointerTo_ns1__getDevVerRes(soap, tag, id, (struct _ns1__getDevVerRes *const*)ptr, "ns1:getDevVerRes");
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq:
		return soap_out_PointerTo_ns1__getDevVerReq(soap, tag, id, (struct _ns1__getDevVerReq *const*)ptr, "ns1:getDevVerReq");
	case SOAP_TYPE_PointerTo_ns1__rebootRes:
		return soap_out_PointerTo_ns1__rebootRes(soap, tag, id, (struct _ns1__rebootRes *const*)ptr, "ns1:rebootRes");
	case SOAP_TYPE_PointerTo_ns1__rebootReq:
		return soap_out_PointerTo_ns1__rebootReq(soap, tag, id, (struct _ns1__rebootReq *const*)ptr, "ns1:rebootReq");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes:
		return soap_out_PointerTo_ns1__setCodingParamRes(soap, tag, id, (struct _ns1__setCodingParamRes *const*)ptr, "ns1:setCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq:
		return soap_out_PointerTo_ns1__setCodingParamReq(soap, tag, id, (struct _ns1__setCodingParamReq *const*)ptr, "ns1:setCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes:
		return soap_out_PointerTo_ns1__getCodingParamRes(soap, tag, id, (struct _ns1__getCodingParamRes *const*)ptr, "ns1:getCodingParamRes");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq:
		return soap_out_PointerTo_ns1__getCodingParamReq(soap, tag, id, (struct _ns1__getCodingParamReq *const*)ptr, "ns1:getCodingParamReq");
	case SOAP_TYPE_PointerTo_ns1__presetControlRes:
		return soap_out_PointerTo_ns1__presetControlRes(soap, tag, id, (struct _ns1__presetControlRes *const*)ptr, "ns1:presetControlRes");
	case SOAP_TYPE_PointerTo_ns1__presetControlReq:
		return soap_out_PointerTo_ns1__presetControlReq(soap, tag, id, (struct _ns1__presetControlReq *const*)ptr, "ns1:presetControlReq");
	case SOAP_TYPE_PointerTo_ns1__lensControlRes:
		return soap_out_PointerTo_ns1__lensControlRes(soap, tag, id, (struct _ns1__lensControlRes *const*)ptr, "ns1:lensControlRes");
	case SOAP_TYPE_PointerTo_ns1__lensControlReq:
		return soap_out_PointerTo_ns1__lensControlReq(soap, tag, id, (struct _ns1__lensControlReq *const*)ptr, "ns1:lensControlReq");
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes:
		return soap_out_PointerTo_ns1__ptzControlRes(soap, tag, id, (struct _ns1__ptzControlRes *const*)ptr, "ns1:ptzControlRes");
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq:
		return soap_out_PointerTo_ns1__ptzControlReq(soap, tag, id, (struct _ns1__ptzControlReq *const*)ptr, "ns1:ptzControlReq");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes:
		return soap_out_PointerTo_ns1__nullifyDeviceRes(soap, tag, id, (struct _ns1__nullifyDeviceRes *const*)ptr, "ns1:nullifyDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq:
		return soap_out_PointerTo_ns1__nullifyDeviceReq(soap, tag, id, (struct _ns1__nullifyDeviceReq *const*)ptr, "ns1:nullifyDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes:
		return soap_out_PointerTo_ns1__addDeviceRes(soap, tag, id, (struct _ns1__addDeviceRes *const*)ptr, "ns1:addDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq:
		return soap_out_PointerTo_ns1__addDeviceReq(soap, tag, id, (struct _ns1__addDeviceReq *const*)ptr, "ns1:addDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes:
		return soap_out_PointerTo_ns1__updateChannelNameRes(soap, tag, id, (struct _ns1__updateChannelNameRes *const*)ptr, "ns1:updateChannelNameRes");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq:
		return soap_out_PointerTo_ns1__updateChannelNameReq(soap, tag, id, (struct _ns1__updateChannelNameReq *const*)ptr, "ns1:updateChannelNameReq");
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes:
		return soap_out_PointerTo_ns1__userLogoutRes(soap, tag, id, (struct _ns1__userLogoutRes *const*)ptr, "ns1:userLogoutRes");
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq:
		return soap_out_PointerTo_ns1__userLogoutReq(soap, tag, id, (struct _ns1__userLogoutReq *const*)ptr, "ns1:userLogoutReq");
	case SOAP_TYPE_PointerTo_ns1__userLoginRes:
		return soap_out_PointerTo_ns1__userLoginRes(soap, tag, id, (struct _ns1__userLoginRes *const*)ptr, "ns1:userLoginRes");
	case SOAP_TYPE_PointerTo_ns1__userLoginReq:
		return soap_out_PointerTo_ns1__userLoginReq(soap, tag, id, (struct _ns1__userLoginReq *const*)ptr, "ns1:userLoginReq");
	case SOAP_TYPE_PointerTo_ns1__byeRes:
		return soap_out_PointerTo_ns1__byeRes(soap, tag, id, (struct _ns1__byeRes *const*)ptr, "ns1:byeRes");
	case SOAP_TYPE_PointerTo_ns1__byeReq:
		return soap_out_PointerTo_ns1__byeReq(soap, tag, id, (struct _ns1__byeReq *const*)ptr, "ns1:byeReq");
	case SOAP_TYPE_PointerTo_ns1__inviteRes:
		return soap_out_PointerTo_ns1__inviteRes(soap, tag, id, (struct _ns1__inviteRes *const*)ptr, "ns1:inviteRes");
	case SOAP_TYPE_PointerTo_ns1__inviteReq:
		return soap_out_PointerTo_ns1__inviteReq(soap, tag, id, (struct _ns1__inviteReq *const*)ptr, "ns1:inviteReq");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes:
		return soap_out_PointerTo_ns1__setAuxiliaryRes(soap, tag, id, (struct _ns1__setAuxiliaryRes *const*)ptr, "ns1:setAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq:
		return soap_out_PointerTo_ns1__setAuxiliaryReq(soap, tag, id, (struct _ns1__setAuxiliaryReq *const*)ptr, "ns1:setAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes:
		return soap_out_PointerTo_ns1__getAuxiliaryRes(soap, tag, id, (struct _ns1__getAuxiliaryRes *const*)ptr, "ns1:getAuxiliaryRes");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq:
		return soap_out_PointerTo_ns1__getAuxiliaryReq(soap, tag, id, (struct _ns1__getAuxiliaryReq *const*)ptr, "ns1:getAuxiliaryReq");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes:
		return soap_out_PointerTo_ns1__getBackPasswordRes(soap, tag, id, (struct _ns1__getBackPasswordRes *const*)ptr, "ns1:getBackPasswordRes");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq:
		return soap_out_PointerTo_ns1__getBackPasswordReq(soap, tag, id, (struct _ns1__getBackPasswordReq *const*)ptr, "ns1:getBackPasswordReq");
	case SOAP_TYPE_PointerTo_ns1__getAccountRes:
		return soap_out_PointerTo_ns1__getAccountRes(soap, tag, id, (struct _ns1__getAccountRes *const*)ptr, "ns1:getAccountRes");
	case SOAP_TYPE_PointerTo_ns1__getAccountReq:
		return soap_out_PointerTo_ns1__getAccountReq(soap, tag, id, (struct _ns1__getAccountReq *const*)ptr, "ns1:getAccountReq");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes:
		return soap_out_PointerTo_ns1__updateAppleTokenRes(soap, tag, id, (struct _ns1__updateAppleTokenRes *const*)ptr, "ns1:updateAppleTokenRes");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq:
		return soap_out_PointerTo_ns1__updateAppleTokenReq(soap, tag, id, (struct _ns1__updateAppleTokenReq *const*)ptr, "ns1:updateAppleTokenReq");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes:
		return soap_out_PointerTo_ns1__queryDeviceRes(soap, tag, id, (struct _ns1__queryDeviceRes *const*)ptr, "ns1:queryDeviceRes");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq:
		return soap_out_PointerTo_ns1__queryDeviceReq(soap, tag, id, (struct _ns1__queryDeviceReq *const*)ptr, "ns1:queryDeviceReq");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes:
		return soap_out_PointerTo_ns1__updatePasswordRes(soap, tag, id, (struct _ns1__updatePasswordRes *const*)ptr, "ns1:updatePasswordRes");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq:
		return soap_out_PointerTo_ns1__updatePasswordReq(soap, tag, id, (struct _ns1__updatePasswordReq *const*)ptr, "ns1:updatePasswordReq");
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes:
		return soap_out_PointerTo_ns1__updateAccountRes(soap, tag, id, (struct _ns1__updateAccountRes *const*)ptr, "ns1:updateAccountRes");
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq:
		return soap_out_PointerTo_ns1__updateAccountReq(soap, tag, id, (struct _ns1__updateAccountReq *const*)ptr, "ns1:updateAccountReq");
	case SOAP_TYPE_PointerTo_ns1__createAccountRes:
		return soap_out_PointerTo_ns1__createAccountRes(soap, tag, id, (struct _ns1__createAccountRes *const*)ptr, "ns1:createAccountRes");
	case SOAP_TYPE_PointerTo_ns1__createAccountReq:
		return soap_out_PointerTo_ns1__createAccountReq(soap, tag, id, (struct _ns1__createAccountReq *const*)ptr, "ns1:createAccountReq");
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes_Any:
		return soap_out_PointerTo_ns1__vodSearchRes_Any(soap, tag, id, (struct _ns1__vodSearchRes_Any *const*)ptr, "ns1:vodSearchRes-Any");
	case SOAP_TYPE_PointerTons1__VODRecord:
		return soap_out_PointerTons1__VODRecord(soap, tag, id, (struct ns1__VODRecord *const*)ptr, "ns1:VODRecord");
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq_Any:
		return soap_out_PointerTo_ns1__vodSearchReq_Any(soap, tag, id, (struct _ns1__vodSearchReq_Any *const*)ptr, "ns1:vodSearchReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes_Any:
		return soap_out_PointerTo_ns1__getVODUrlRes_Any(soap, tag, id, (struct _ns1__getVODUrlRes_Any *const*)ptr, "ns1:getVODUrlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq_Any:
		return soap_out_PointerTo_ns1__getVODUrlReq_Any(soap, tag, id, (struct _ns1__getVODUrlReq_Any *const*)ptr, "ns1:getVODUrlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes_Any:
		return soap_out_PointerTo_ns1__getPlayUrlRes_Any(soap, tag, id, (struct _ns1__getPlayUrlRes_Any *const*)ptr, "ns1:getPlayUrlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq_Any:
		return soap_out_PointerTo_ns1__getPlayUrlReq_Any(soap, tag, id, (struct _ns1__getPlayUrlReq_Any *const*)ptr, "ns1:getPlayUrlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes_Any:
		return soap_out_PointerTo_ns1__setPrivacyMaskParamRes_Any(soap, tag, id, (struct _ns1__setPrivacyMaskParamRes_Any *const*)ptr, "ns1:setPrivacyMaskParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq_Any:
		return soap_out_PointerTo_ns1__setPrivacyMaskParamReq_Any(soap, tag, id, (struct _ns1__setPrivacyMaskParamReq_Any *const*)ptr, "ns1:setPrivacyMaskParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes_Any:
		return soap_out_PointerTo_ns1__getPrivacyMaskParamRes_Any(soap, tag, id, (struct _ns1__getPrivacyMaskParamRes_Any *const*)ptr, "ns1:getPrivacyMaskParamRes-Any");
	case SOAP_TYPE_PointerTons1__PrivacyMaskRegion:
		return soap_out_PointerTons1__PrivacyMaskRegion(soap, tag, id, (struct ns1__PrivacyMaskRegion *const*)ptr, "ns1:PrivacyMaskRegion");
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq_Any:
		return soap_out_PointerTo_ns1__getPrivacyMaskParamReq_Any(soap, tag, id, (struct _ns1__getPrivacyMaskParamReq_Any *const*)ptr, "ns1:getPrivacyMaskParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes_Any:
		return soap_out_PointerTo_ns1__setVMDParamRes_Any(soap, tag, id, (struct _ns1__setVMDParamRes_Any *const*)ptr, "ns1:setVMDParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq_Any:
		return soap_out_PointerTo_ns1__setVMDParamReq_Any(soap, tag, id, (struct _ns1__setVMDParamReq_Any *const*)ptr, "ns1:setVMDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes_Any:
		return soap_out_PointerTo_ns1__getVMDParamRes_Any(soap, tag, id, (struct _ns1__getVMDParamRes_Any *const*)ptr, "ns1:getVMDParamRes-Any");
	case SOAP_TYPE_PointerTons1__VMDGrid:
		return soap_out_PointerTons1__VMDGrid(soap, tag, id, (struct ns1__VMDGrid *const*)ptr, "ns1:VMDGrid");
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq_Any:
		return soap_out_PointerTo_ns1__getVMDParamReq_Any(soap, tag, id, (struct _ns1__getVMDParamReq_Any *const*)ptr, "ns1:getVMDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setTimeRes_Any:
		return soap_out_PointerTo_ns1__setTimeRes_Any(soap, tag, id, (struct _ns1__setTimeRes_Any *const*)ptr, "ns1:setTimeRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setTimeReq_Any:
		return soap_out_PointerTo_ns1__setTimeReq_Any(soap, tag, id, (struct _ns1__setTimeReq_Any *const*)ptr, "ns1:setTimeReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getTimeRes_Any:
		return soap_out_PointerTo_ns1__getTimeRes_Any(soap, tag, id, (struct _ns1__getTimeRes_Any *const*)ptr, "ns1:getTimeRes-Any");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTo_ns1__getTimeReq_Any:
		return soap_out_PointerTo_ns1__getTimeReq_Any(soap, tag, id, (struct _ns1__getTimeReq_Any *const*)ptr, "ns1:getTimeReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes_Any:
		return soap_out_PointerTo_ns1__setOSDParamRes_Any(soap, tag, id, (struct _ns1__setOSDParamRes_Any *const*)ptr, "ns1:setOSDParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq_Any:
		return soap_out_PointerTo_ns1__setOSDParamReq_Any(soap, tag, id, (struct _ns1__setOSDParamReq_Any *const*)ptr, "ns1:setOSDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes_Any:
		return soap_out_PointerTo_ns1__getOSDParamRes_Any(soap, tag, id, (struct _ns1__getOSDParamRes_Any *const*)ptr, "ns1:getOSDParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq_Any:
		return soap_out_PointerTo_ns1__getOSDParamReq_Any(soap, tag, id, (struct _ns1__getOSDParamReq_Any *const*)ptr, "ns1:getOSDParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes_Any:
		return soap_out_PointerTo_ns1__setVideoParamRes_Any(soap, tag, id, (struct _ns1__setVideoParamRes_Any *const*)ptr, "ns1:setVideoParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq_Any:
		return soap_out_PointerTo_ns1__setVideoParamReq_Any(soap, tag, id, (struct _ns1__setVideoParamReq_Any *const*)ptr, "ns1:setVideoParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes_Any:
		return soap_out_PointerTo_ns1__getVideoParamRes_Any(soap, tag, id, (struct _ns1__getVideoParamRes_Any *const*)ptr, "ns1:getVideoParamRes-Any");
	case SOAP_TYPE_PointerTons1__VideoStandard:
		return soap_out_PointerTons1__VideoStandard(soap, tag, id, (enum ns1__VideoStandard *const*)ptr, "ns1:VideoStandard");
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq_Any:
		return soap_out_PointerTo_ns1__getVideoParamReq_Any(soap, tag, id, (struct _ns1__getVideoParamReq_Any *const*)ptr, "ns1:getVideoParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes_Any:
		return soap_out_PointerTo_ns1__queryDevLogRes_Any(soap, tag, id, (struct _ns1__queryDevLogRes_Any *const*)ptr, "ns1:queryDevLogRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfDevLog:
		return soap_out_PointerTons1__ArrayOfDevLog(soap, tag, id, (struct ns1__ArrayOfDevLog *const*)ptr, "ns1:ArrayOfDevLog");
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq_Any:
		return soap_out_PointerTo_ns1__queryDevLogReq_Any(soap, tag, id, (struct _ns1__queryDevLogReq_Any *const*)ptr, "ns1:queryDevLogReq-Any");
	case SOAP_TYPE_PointerTo_ns1__queryLogRes_Any:
		return soap_out_PointerTo_ns1__queryLogRes_Any(soap, tag, id, (struct _ns1__queryLogRes_Any *const*)ptr, "ns1:queryLogRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfPuLog:
		return soap_out_PointerTons1__ArrayOfPuLog(soap, tag, id, (struct ns1__ArrayOfPuLog *const*)ptr, "ns1:ArrayOfPuLog");
	case SOAP_TYPE_PointerTo_ns1__queryLogReq_Any:
		return soap_out_PointerTo_ns1__queryLogReq_Any(soap, tag, id, (struct _ns1__queryLogReq_Any *const*)ptr, "ns1:queryLogReq-Any");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes_Any:
		return soap_out_PointerTo_ns1__upgradeDevVerRes_Any(soap, tag, id, (struct _ns1__upgradeDevVerRes_Any *const*)ptr, "ns1:upgradeDevVerRes-Any");
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq_Any:
		return soap_out_PointerTo_ns1__upgradeDevVerReq_Any(soap, tag, id, (struct _ns1__upgradeDevVerReq_Any *const*)ptr, "ns1:upgradeDevVerReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes_Any:
		return soap_out_PointerTo_ns1__getDevVerRes_Any(soap, tag, id, (struct _ns1__getDevVerRes_Any *const*)ptr, "ns1:getDevVerRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq_Any:
		return soap_out_PointerTo_ns1__getDevVerReq_Any(soap, tag, id, (struct _ns1__getDevVerReq_Any *const*)ptr, "ns1:getDevVerReq-Any");
	case SOAP_TYPE_PointerTo_ns1__rebootRes_Any:
		return soap_out_PointerTo_ns1__rebootRes_Any(soap, tag, id, (struct _ns1__rebootRes_Any *const*)ptr, "ns1:rebootRes-Any");
	case SOAP_TYPE_PointerTo_ns1__rebootReq_Any:
		return soap_out_PointerTo_ns1__rebootReq_Any(soap, tag, id, (struct _ns1__rebootReq_Any *const*)ptr, "ns1:rebootReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes_Any:
		return soap_out_PointerTo_ns1__setCodingParamRes_Any(soap, tag, id, (struct _ns1__setCodingParamRes_Any *const*)ptr, "ns1:setCodingParamRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq_Any:
		return soap_out_PointerTo_ns1__setCodingParamReq_Any(soap, tag, id, (struct _ns1__setCodingParamReq_Any *const*)ptr, "ns1:setCodingParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes_Any:
		return soap_out_PointerTo_ns1__getCodingParamRes_Any(soap, tag, id, (struct _ns1__getCodingParamRes_Any *const*)ptr, "ns1:getCodingParamRes-Any");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons1__RateType:
		return soap_out_PointerTons1__RateType(soap, tag, id, (enum ns1__RateType *const*)ptr, "ns1:RateType");
	case SOAP_TYPE_PointerTons1__FrameSize:
		return soap_out_PointerTons1__FrameSize(soap, tag, id, (enum ns1__FrameSize *const*)ptr, "ns1:FrameSize");
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq_Any:
		return soap_out_PointerTo_ns1__getCodingParamReq_Any(soap, tag, id, (struct _ns1__getCodingParamReq_Any *const*)ptr, "ns1:getCodingParamReq-Any");
	case SOAP_TYPE_PointerTo_ns1__presetControlRes_Any:
		return soap_out_PointerTo_ns1__presetControlRes_Any(soap, tag, id, (struct _ns1__presetControlRes_Any *const*)ptr, "ns1:presetControlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__presetControlReq_Any:
		return soap_out_PointerTo_ns1__presetControlReq_Any(soap, tag, id, (struct _ns1__presetControlReq_Any *const*)ptr, "ns1:presetControlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__lensControlRes_Any:
		return soap_out_PointerTo_ns1__lensControlRes_Any(soap, tag, id, (struct _ns1__lensControlRes_Any *const*)ptr, "ns1:lensControlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__lensControlReq_Any:
		return soap_out_PointerTo_ns1__lensControlReq_Any(soap, tag, id, (struct _ns1__lensControlReq_Any *const*)ptr, "ns1:lensControlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes_Any:
		return soap_out_PointerTo_ns1__ptzControlRes_Any(soap, tag, id, (struct _ns1__ptzControlRes_Any *const*)ptr, "ns1:ptzControlRes-Any");
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq_Any:
		return soap_out_PointerTo_ns1__ptzControlReq_Any(soap, tag, id, (struct _ns1__ptzControlReq_Any *const*)ptr, "ns1:ptzControlReq-Any");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes_Any:
		return soap_out_PointerTo_ns1__nullifyDeviceRes_Any(soap, tag, id, (struct _ns1__nullifyDeviceRes_Any *const*)ptr, "ns1:nullifyDeviceRes-Any");
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq_Any:
		return soap_out_PointerTo_ns1__nullifyDeviceReq_Any(soap, tag, id, (struct _ns1__nullifyDeviceReq_Any *const*)ptr, "ns1:nullifyDeviceReq-Any");
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes_Any:
		return soap_out_PointerTo_ns1__addDeviceRes_Any(soap, tag, id, (struct _ns1__addDeviceRes_Any *const*)ptr, "ns1:addDeviceRes-Any");
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq_Any:
		return soap_out_PointerTo_ns1__addDeviceReq_Any(soap, tag, id, (struct _ns1__addDeviceReq_Any *const*)ptr, "ns1:addDeviceReq-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfDevice:
		return soap_out_PointerTons1__ArrayOfDevice(soap, tag, id, (struct ns1__ArrayOfDevice *const*)ptr, "ns1:ArrayOfDevice");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes_Any:
		return soap_out_PointerTo_ns1__updateChannelNameRes_Any(soap, tag, id, (struct _ns1__updateChannelNameRes_Any *const*)ptr, "ns1:updateChannelNameRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq_Any:
		return soap_out_PointerTo_ns1__updateChannelNameReq_Any(soap, tag, id, (struct _ns1__updateChannelNameReq_Any *const*)ptr, "ns1:updateChannelNameReq-Any");
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes_Any:
		return soap_out_PointerTo_ns1__userLogoutRes_Any(soap, tag, id, (struct _ns1__userLogoutRes_Any *const*)ptr, "ns1:userLogoutRes-Any");
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq_Any:
		return soap_out_PointerTo_ns1__userLogoutReq_Any(soap, tag, id, (struct _ns1__userLogoutReq_Any *const*)ptr, "ns1:userLogoutReq-Any");
	case SOAP_TYPE_PointerTo_ns1__userLoginRes_Any:
		return soap_out_PointerTo_ns1__userLoginRes_Any(soap, tag, id, (struct _ns1__userLoginRes_Any *const*)ptr, "ns1:userLoginRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfDev:
		return soap_out_PointerTons1__ArrayOfDev(soap, tag, id, (struct ns1__ArrayOfDev *const*)ptr, "ns1:ArrayOfDev");
	case SOAP_TYPE_PointerTo_ns1__userLoginReq_Any:
		return soap_out_PointerTo_ns1__userLoginReq_Any(soap, tag, id, (struct _ns1__userLoginReq_Any *const*)ptr, "ns1:userLoginReq-Any");
	case SOAP_TYPE_PointerTo_ns1__byeRes_Any:
		return soap_out_PointerTo_ns1__byeRes_Any(soap, tag, id, (struct _ns1__byeRes_Any *const*)ptr, "ns1:byeRes-Any");
	case SOAP_TYPE_PointerTo_ns1__byeReq_Any:
		return soap_out_PointerTo_ns1__byeReq_Any(soap, tag, id, (struct _ns1__byeReq_Any *const*)ptr, "ns1:byeReq-Any");
	case SOAP_TYPE_PointerTo_ns1__inviteRes_Any:
		return soap_out_PointerTo_ns1__inviteRes_Any(soap, tag, id, (struct _ns1__inviteRes_Any *const*)ptr, "ns1:inviteRes-Any");
	case SOAP_TYPE_PointerTo_ns1__inviteReq_Any:
		return soap_out_PointerTo_ns1__inviteReq_Any(soap, tag, id, (struct _ns1__inviteReq_Any *const*)ptr, "ns1:inviteReq-Any");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes_Any:
		return soap_out_PointerTo_ns1__setAuxiliaryRes_Any(soap, tag, id, (struct _ns1__setAuxiliaryRes_Any *const*)ptr, "ns1:setAuxiliaryRes-Any");
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq_Any:
		return soap_out_PointerTo_ns1__setAuxiliaryReq_Any(soap, tag, id, (struct _ns1__setAuxiliaryReq_Any *const*)ptr, "ns1:setAuxiliaryReq-Any");
	case SOAP_TYPE_PointerTons1__AuxiliaryType:
		return soap_out_PointerTons1__AuxiliaryType(soap, tag, id, (enum ns1__AuxiliaryType *const*)ptr, "ns1:AuxiliaryType");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes_Any:
		return soap_out_PointerTo_ns1__getAuxiliaryRes_Any(soap, tag, id, (struct _ns1__getAuxiliaryRes_Any *const*)ptr, "ns1:getAuxiliaryRes-Any");
	case SOAP_TYPE_PointerTons1__AuxiliaryState:
		return soap_out_PointerTons1__AuxiliaryState(soap, tag, id, (enum ns1__AuxiliaryState *const*)ptr, "ns1:AuxiliaryState");
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq_Any:
		return soap_out_PointerTo_ns1__getAuxiliaryReq_Any(soap, tag, id, (struct _ns1__getAuxiliaryReq_Any *const*)ptr, "ns1:getAuxiliaryReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes_Any:
		return soap_out_PointerTo_ns1__getBackPasswordRes_Any(soap, tag, id, (struct _ns1__getBackPasswordRes_Any *const*)ptr, "ns1:getBackPasswordRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq_Any:
		return soap_out_PointerTo_ns1__getBackPasswordReq_Any(soap, tag, id, (struct _ns1__getBackPasswordReq_Any *const*)ptr, "ns1:getBackPasswordReq-Any");
	case SOAP_TYPE_PointerTo_ns1__getAccountRes_Any:
		return soap_out_PointerTo_ns1__getAccountRes_Any(soap, tag, id, (struct _ns1__getAccountRes_Any *const*)ptr, "ns1:getAccountRes-Any");
	case SOAP_TYPE_PointerTo_ns1__getAccountReq_Any:
		return soap_out_PointerTo_ns1__getAccountReq_Any(soap, tag, id, (struct _ns1__getAccountReq_Any *const*)ptr, "ns1:getAccountReq-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes_Any:
		return soap_out_PointerTo_ns1__updateAppleTokenRes_Any(soap, tag, id, (struct _ns1__updateAppleTokenRes_Any *const*)ptr, "ns1:updateAppleTokenRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq_Any:
		return soap_out_PointerTo_ns1__updateAppleTokenReq_Any(soap, tag, id, (struct _ns1__updateAppleTokenReq_Any *const*)ptr, "ns1:updateAppleTokenReq-Any");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes_Any:
		return soap_out_PointerTo_ns1__queryDeviceRes_Any(soap, tag, id, (struct _ns1__queryDeviceRes_Any *const*)ptr, "ns1:queryDeviceRes-Any");
	case SOAP_TYPE_PointerTons1__ArrayOfNodeDetails:
		return soap_out_PointerTons1__ArrayOfNodeDetails(soap, tag, id, (struct ns1__ArrayOfNodeDetails *const*)ptr, "ns1:ArrayOfNodeDetails");
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq_Any:
		return soap_out_PointerTo_ns1__queryDeviceReq_Any(soap, tag, id, (struct _ns1__queryDeviceReq_Any *const*)ptr, "ns1:queryDeviceReq-Any");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes_Any:
		return soap_out_PointerTo_ns1__updatePasswordRes_Any(soap, tag, id, (struct _ns1__updatePasswordRes_Any *const*)ptr, "ns1:updatePasswordRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq_Any:
		return soap_out_PointerTo_ns1__updatePasswordReq_Any(soap, tag, id, (struct _ns1__updatePasswordReq_Any *const*)ptr, "ns1:updatePasswordReq-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes_Any:
		return soap_out_PointerTo_ns1__updateAccountRes_Any(soap, tag, id, (struct _ns1__updateAccountRes_Any *const*)ptr, "ns1:updateAccountRes-Any");
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq_Any:
		return soap_out_PointerTo_ns1__updateAccountReq_Any(soap, tag, id, (struct _ns1__updateAccountReq_Any *const*)ptr, "ns1:updateAccountReq-Any");
	case SOAP_TYPE_PointerTo_ns1__createAccountRes_Any:
		return soap_out_PointerTo_ns1__createAccountRes_Any(soap, tag, id, (struct _ns1__createAccountRes_Any *const*)ptr, "ns1:createAccountRes-Any");
	case SOAP_TYPE_PointerTo_ns1__createAccountReq_Any:
		return soap_out_PointerTo_ns1__createAccountReq_Any(soap, tag, id, (struct _ns1__createAccountReq_Any *const*)ptr, "ns1:createAccountReq-Any");
	case SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166:
		return soap_out_PointerTons1__CountryAbbr2ISO3166(soap, tag, id, (enum ns1__CountryAbbr2ISO3166 *const*)ptr, "ns1:CountryAbbr2ISO3166");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTo_ns1__VODRecord_Any:
		return soap_out_PointerTo_ns1__VODRecord_Any(soap, tag, id, (struct _ns1__VODRecord_Any *const*)ptr, "ns1:VODRecord-Any");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTo_ns1__PrivacyMaskRegion_Any:
		return soap_out_PointerTo_ns1__PrivacyMaskRegion_Any(soap, tag, id, (struct _ns1__PrivacyMaskRegion_Any *const*)ptr, "ns1:PrivacyMaskRegion-Any");
	case SOAP_TYPE_PointerTo_ns1__VMDGrid_Any:
		return soap_out_PointerTo_ns1__VMDGrid_Any(soap, tag, id, (struct _ns1__VMDGrid_Any *const*)ptr, "ns1:VMDGrid-Any");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__DevLog_Any:
		return soap_out_PointerTo_ns1__DevLog_Any(soap, tag, id, (struct _ns1__DevLog_Any *const*)ptr, "ns1:DevLog-Any");
	case SOAP_TYPE_PointerTons1__DevLog:
		return soap_out_PointerTons1__DevLog(soap, tag, id, (struct ns1__DevLog *const*)ptr, "ns1:DevLog");
	case SOAP_TYPE_PointerTo_ns1__PuLog_Any:
		return soap_out_PointerTo_ns1__PuLog_Any(soap, tag, id, (struct _ns1__PuLog_Any *const*)ptr, "ns1:PuLog-Any");
	case SOAP_TYPE_PointerTons1__PuLog:
		return soap_out_PointerTons1__PuLog(soap, tag, id, (struct ns1__PuLog *const*)ptr, "ns1:PuLog");
	case SOAP_TYPE_PointerTo_ns1__Device_Any:
		return soap_out_PointerTo_ns1__Device_Any(soap, tag, id, (struct _ns1__Device_Any *const*)ptr, "ns1:Device-Any");
	case SOAP_TYPE_PointerTons1__Device:
		return soap_out_PointerTons1__Device(soap, tag, id, (struct ns1__Device *const*)ptr, "ns1:Device");
	case SOAP_TYPE_PointerTo_ns1__Dev_Any:
		return soap_out_PointerTo_ns1__Dev_Any(soap, tag, id, (struct _ns1__Dev_Any *const*)ptr, "ns1:Dev-Any");
	case SOAP_TYPE_PointerTons1__Dev:
		return soap_out_PointerTons1__Dev(soap, tag, id, (struct ns1__Dev *const*)ptr, "ns1:Dev");
	case SOAP_TYPE_PointerTo_ns1__NodeDetails_Any:
		return soap_out_PointerTo_ns1__NodeDetails_Any(soap, tag, id, (struct _ns1__NodeDetails_Any *const*)ptr, "ns1:NodeDetails-Any");
	case SOAP_TYPE_PointerTons1__NodeDetails:
		return soap_out_PointerTons1__NodeDetails(soap, tag, id, (struct ns1__NodeDetails *const*)ptr, "ns1:NodeDetails");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns1__vodSearch:
		soap_serialize___ns1__vodSearch(soap, (const struct __ns1__vodSearch *)ptr);
		break;
	case SOAP_TYPE___ns1__getVODUrl:
		soap_serialize___ns1__getVODUrl(soap, (const struct __ns1__getVODUrl *)ptr);
		break;
	case SOAP_TYPE___ns1__getPlayUrl:
		soap_serialize___ns1__getPlayUrl(soap, (const struct __ns1__getPlayUrl *)ptr);
		break;
	case SOAP_TYPE___ns1__setPrivacyMaskParam:
		soap_serialize___ns1__setPrivacyMaskParam(soap, (const struct __ns1__setPrivacyMaskParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getPrivacyMaskParam:
		soap_serialize___ns1__getPrivacyMaskParam(soap, (const struct __ns1__getPrivacyMaskParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setVMDParam:
		soap_serialize___ns1__setVMDParam(soap, (const struct __ns1__setVMDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getVMDParam:
		soap_serialize___ns1__getVMDParam(soap, (const struct __ns1__getVMDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setTime:
		soap_serialize___ns1__setTime(soap, (const struct __ns1__setTime *)ptr);
		break;
	case SOAP_TYPE___ns1__getTime:
		soap_serialize___ns1__getTime(soap, (const struct __ns1__getTime *)ptr);
		break;
	case SOAP_TYPE___ns1__setOSDParam:
		soap_serialize___ns1__setOSDParam(soap, (const struct __ns1__setOSDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getOSDParam:
		soap_serialize___ns1__getOSDParam(soap, (const struct __ns1__getOSDParam *)ptr);
		break;
	case SOAP_TYPE___ns1__setVideoParam:
		soap_serialize___ns1__setVideoParam(soap, (const struct __ns1__setVideoParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getVideoParam:
		soap_serialize___ns1__getVideoParam(soap, (const struct __ns1__getVideoParam *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDevLog:
		soap_serialize___ns1__queryDevLog(soap, (const struct __ns1__queryDevLog *)ptr);
		break;
	case SOAP_TYPE___ns1__queryLog:
		soap_serialize___ns1__queryLog(soap, (const struct __ns1__queryLog *)ptr);
		break;
	case SOAP_TYPE___ns1__upgradeDevVer:
		soap_serialize___ns1__upgradeDevVer(soap, (const struct __ns1__upgradeDevVer *)ptr);
		break;
	case SOAP_TYPE___ns1__getDevVer:
		soap_serialize___ns1__getDevVer(soap, (const struct __ns1__getDevVer *)ptr);
		break;
	case SOAP_TYPE___ns1__reboot:
		soap_serialize___ns1__reboot(soap, (const struct __ns1__reboot *)ptr);
		break;
	case SOAP_TYPE___ns1__setCodingParam:
		soap_serialize___ns1__setCodingParam(soap, (const struct __ns1__setCodingParam *)ptr);
		break;
	case SOAP_TYPE___ns1__getCodingParam:
		soap_serialize___ns1__getCodingParam(soap, (const struct __ns1__getCodingParam *)ptr);
		break;
	case SOAP_TYPE___ns1__presetControl:
		soap_serialize___ns1__presetControl(soap, (const struct __ns1__presetControl *)ptr);
		break;
	case SOAP_TYPE___ns1__lensControl:
		soap_serialize___ns1__lensControl(soap, (const struct __ns1__lensControl *)ptr);
		break;
	case SOAP_TYPE___ns1__ptzControl:
		soap_serialize___ns1__ptzControl(soap, (const struct __ns1__ptzControl *)ptr);
		break;
	case SOAP_TYPE___ns1__nullifyDevice:
		soap_serialize___ns1__nullifyDevice(soap, (const struct __ns1__nullifyDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__addDevice:
		soap_serialize___ns1__addDevice(soap, (const struct __ns1__addDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__updateChannelName:
		soap_serialize___ns1__updateChannelName(soap, (const struct __ns1__updateChannelName *)ptr);
		break;
	case SOAP_TYPE___ns1__userLogout:
		soap_serialize___ns1__userLogout(soap, (const struct __ns1__userLogout *)ptr);
		break;
	case SOAP_TYPE___ns1__userLogin:
		soap_serialize___ns1__userLogin(soap, (const struct __ns1__userLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__bye:
		soap_serialize___ns1__bye(soap, (const struct __ns1__bye *)ptr);
		break;
	case SOAP_TYPE___ns1__invite:
		soap_serialize___ns1__invite(soap, (const struct __ns1__invite *)ptr);
		break;
	case SOAP_TYPE___ns1__setAuxiliary:
		soap_serialize___ns1__setAuxiliary(soap, (const struct __ns1__setAuxiliary *)ptr);
		break;
	case SOAP_TYPE___ns1__getAuxiliary:
		soap_serialize___ns1__getAuxiliary(soap, (const struct __ns1__getAuxiliary *)ptr);
		break;
	case SOAP_TYPE___ns1__getBackPassword:
		soap_serialize___ns1__getBackPassword(soap, (const struct __ns1__getBackPassword *)ptr);
		break;
	case SOAP_TYPE___ns1__getAccount:
		soap_serialize___ns1__getAccount(soap, (const struct __ns1__getAccount *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAppleToken:
		soap_serialize___ns1__updateAppleToken(soap, (const struct __ns1__updateAppleToken *)ptr);
		break;
	case SOAP_TYPE___ns1__queryDevice:
		soap_serialize___ns1__queryDevice(soap, (const struct __ns1__queryDevice *)ptr);
		break;
	case SOAP_TYPE___ns1__updatePassword:
		soap_serialize___ns1__updatePassword(soap, (const struct __ns1__updatePassword *)ptr);
		break;
	case SOAP_TYPE___ns1__updateAccount:
		soap_serialize___ns1__updateAccount(soap, (const struct __ns1__updateAccount *)ptr);
		break;
	case SOAP_TYPE___ns1__createAccount:
		soap_serialize___ns1__createAccount(soap, (const struct __ns1__createAccount *)ptr);
		break;
	case SOAP_TYPE__ns1__vodSearchRes_Any:
		soap_serialize__ns1__vodSearchRes_Any(soap, (const struct _ns1__vodSearchRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__vodSearchRes:
		soap_serialize__ns1__vodSearchRes(soap, (const struct _ns1__vodSearchRes *)ptr);
		break;
	case SOAP_TYPE__ns1__vodSearchReq_Any:
		soap_serialize__ns1__vodSearchReq_Any(soap, (const struct _ns1__vodSearchReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__vodSearchReq:
		soap_serialize__ns1__vodSearchReq(soap, (const struct _ns1__vodSearchReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getVODUrlRes_Any:
		soap_serialize__ns1__getVODUrlRes_Any(soap, (const struct _ns1__getVODUrlRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getVODUrlRes:
		soap_serialize__ns1__getVODUrlRes(soap, (const struct _ns1__getVODUrlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getVODUrlReq_Any:
		soap_serialize__ns1__getVODUrlReq_Any(soap, (const struct _ns1__getVODUrlReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getVODUrlReq:
		soap_serialize__ns1__getVODUrlReq(soap, (const struct _ns1__getVODUrlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getPlayUrlRes_Any:
		soap_serialize__ns1__getPlayUrlRes_Any(soap, (const struct _ns1__getPlayUrlRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getPlayUrlRes:
		soap_serialize__ns1__getPlayUrlRes(soap, (const struct _ns1__getPlayUrlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getPlayUrlReq_Any:
		soap_serialize__ns1__getPlayUrlReq_Any(soap, (const struct _ns1__getPlayUrlReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getPlayUrlReq:
		soap_serialize__ns1__getPlayUrlReq(soap, (const struct _ns1__getPlayUrlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any:
		soap_serialize__ns1__setPrivacyMaskParamRes_Any(soap, (const struct _ns1__setPrivacyMaskParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setPrivacyMaskParamRes:
		soap_serialize__ns1__setPrivacyMaskParamRes(soap, (const struct _ns1__setPrivacyMaskParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any:
		soap_serialize__ns1__setPrivacyMaskParamReq_Any(soap, (const struct _ns1__setPrivacyMaskParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setPrivacyMaskParamReq:
		soap_serialize__ns1__setPrivacyMaskParamReq(soap, (const struct _ns1__setPrivacyMaskParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any:
		soap_serialize__ns1__getPrivacyMaskParamRes_Any(soap, (const struct _ns1__getPrivacyMaskParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getPrivacyMaskParamRes:
		soap_serialize__ns1__getPrivacyMaskParamRes(soap, (const struct _ns1__getPrivacyMaskParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any:
		soap_serialize__ns1__getPrivacyMaskParamReq_Any(soap, (const struct _ns1__getPrivacyMaskParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getPrivacyMaskParamReq:
		soap_serialize__ns1__getPrivacyMaskParamReq(soap, (const struct _ns1__getPrivacyMaskParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setVMDParamRes_Any:
		soap_serialize__ns1__setVMDParamRes_Any(soap, (const struct _ns1__setVMDParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setVMDParamRes:
		soap_serialize__ns1__setVMDParamRes(soap, (const struct _ns1__setVMDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setVMDParamReq_Any:
		soap_serialize__ns1__setVMDParamReq_Any(soap, (const struct _ns1__setVMDParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setVMDParamReq:
		soap_serialize__ns1__setVMDParamReq(soap, (const struct _ns1__setVMDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getVMDParamRes_Any:
		soap_serialize__ns1__getVMDParamRes_Any(soap, (const struct _ns1__getVMDParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getVMDParamRes:
		soap_serialize__ns1__getVMDParamRes(soap, (const struct _ns1__getVMDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getVMDParamReq_Any:
		soap_serialize__ns1__getVMDParamReq_Any(soap, (const struct _ns1__getVMDParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getVMDParamReq:
		soap_serialize__ns1__getVMDParamReq(soap, (const struct _ns1__getVMDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setTimeRes_Any:
		soap_serialize__ns1__setTimeRes_Any(soap, (const struct _ns1__setTimeRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setTimeRes:
		soap_serialize__ns1__setTimeRes(soap, (const struct _ns1__setTimeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setTimeReq_Any:
		soap_serialize__ns1__setTimeReq_Any(soap, (const struct _ns1__setTimeReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setTimeReq:
		soap_serialize__ns1__setTimeReq(soap, (const struct _ns1__setTimeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getTimeRes_Any:
		soap_serialize__ns1__getTimeRes_Any(soap, (const struct _ns1__getTimeRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getTimeRes:
		soap_serialize__ns1__getTimeRes(soap, (const struct _ns1__getTimeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getTimeReq_Any:
		soap_serialize__ns1__getTimeReq_Any(soap, (const struct _ns1__getTimeReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getTimeReq:
		soap_serialize__ns1__getTimeReq(soap, (const struct _ns1__getTimeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setOSDParamRes_Any:
		soap_serialize__ns1__setOSDParamRes_Any(soap, (const struct _ns1__setOSDParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setOSDParamRes:
		soap_serialize__ns1__setOSDParamRes(soap, (const struct _ns1__setOSDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setOSDParamReq_Any:
		soap_serialize__ns1__setOSDParamReq_Any(soap, (const struct _ns1__setOSDParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setOSDParamReq:
		soap_serialize__ns1__setOSDParamReq(soap, (const struct _ns1__setOSDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getOSDParamRes_Any:
		soap_serialize__ns1__getOSDParamRes_Any(soap, (const struct _ns1__getOSDParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getOSDParamRes:
		soap_serialize__ns1__getOSDParamRes(soap, (const struct _ns1__getOSDParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getOSDParamReq_Any:
		soap_serialize__ns1__getOSDParamReq_Any(soap, (const struct _ns1__getOSDParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getOSDParamReq:
		soap_serialize__ns1__getOSDParamReq(soap, (const struct _ns1__getOSDParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setVideoParamRes_Any:
		soap_serialize__ns1__setVideoParamRes_Any(soap, (const struct _ns1__setVideoParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setVideoParamRes:
		soap_serialize__ns1__setVideoParamRes(soap, (const struct _ns1__setVideoParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setVideoParamReq_Any:
		soap_serialize__ns1__setVideoParamReq_Any(soap, (const struct _ns1__setVideoParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setVideoParamReq:
		soap_serialize__ns1__setVideoParamReq(soap, (const struct _ns1__setVideoParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getVideoParamRes_Any:
		soap_serialize__ns1__getVideoParamRes_Any(soap, (const struct _ns1__getVideoParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getVideoParamRes:
		soap_serialize__ns1__getVideoParamRes(soap, (const struct _ns1__getVideoParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getVideoParamReq_Any:
		soap_serialize__ns1__getVideoParamReq_Any(soap, (const struct _ns1__getVideoParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getVideoParamReq:
		soap_serialize__ns1__getVideoParamReq(soap, (const struct _ns1__getVideoParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDevLogRes_Any:
		soap_serialize__ns1__queryDevLogRes_Any(soap, (const struct _ns1__queryDevLogRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDevLogRes:
		soap_serialize__ns1__queryDevLogRes(soap, (const struct _ns1__queryDevLogRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDevLogReq_Any:
		soap_serialize__ns1__queryDevLogReq_Any(soap, (const struct _ns1__queryDevLogReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDevLogReq:
		soap_serialize__ns1__queryDevLogReq(soap, (const struct _ns1__queryDevLogReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryLogRes_Any:
		soap_serialize__ns1__queryLogRes_Any(soap, (const struct _ns1__queryLogRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__queryLogRes:
		soap_serialize__ns1__queryLogRes(soap, (const struct _ns1__queryLogRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryLogReq_Any:
		soap_serialize__ns1__queryLogReq_Any(soap, (const struct _ns1__queryLogReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__queryLogReq:
		soap_serialize__ns1__queryLogReq(soap, (const struct _ns1__queryLogReq *)ptr);
		break;
	case SOAP_TYPE__ns1__upgradeDevVerRes_Any:
		soap_serialize__ns1__upgradeDevVerRes_Any(soap, (const struct _ns1__upgradeDevVerRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__upgradeDevVerRes:
		soap_serialize__ns1__upgradeDevVerRes(soap, (const struct _ns1__upgradeDevVerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__upgradeDevVerReq_Any:
		soap_serialize__ns1__upgradeDevVerReq_Any(soap, (const struct _ns1__upgradeDevVerReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__upgradeDevVerReq:
		soap_serialize__ns1__upgradeDevVerReq(soap, (const struct _ns1__upgradeDevVerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getDevVerRes_Any:
		soap_serialize__ns1__getDevVerRes_Any(soap, (const struct _ns1__getDevVerRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getDevVerRes:
		soap_serialize__ns1__getDevVerRes(soap, (const struct _ns1__getDevVerRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getDevVerReq_Any:
		soap_serialize__ns1__getDevVerReq_Any(soap, (const struct _ns1__getDevVerReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getDevVerReq:
		soap_serialize__ns1__getDevVerReq(soap, (const struct _ns1__getDevVerReq *)ptr);
		break;
	case SOAP_TYPE__ns1__rebootRes_Any:
		soap_serialize__ns1__rebootRes_Any(soap, (const struct _ns1__rebootRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__rebootRes:
		soap_serialize__ns1__rebootRes(soap, (const struct _ns1__rebootRes *)ptr);
		break;
	case SOAP_TYPE__ns1__rebootReq_Any:
		soap_serialize__ns1__rebootReq_Any(soap, (const struct _ns1__rebootReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__rebootReq:
		soap_serialize__ns1__rebootReq(soap, (const struct _ns1__rebootReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setCodingParamRes_Any:
		soap_serialize__ns1__setCodingParamRes_Any(soap, (const struct _ns1__setCodingParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setCodingParamRes:
		soap_serialize__ns1__setCodingParamRes(soap, (const struct _ns1__setCodingParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setCodingParamReq_Any:
		soap_serialize__ns1__setCodingParamReq_Any(soap, (const struct _ns1__setCodingParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setCodingParamReq:
		soap_serialize__ns1__setCodingParamReq(soap, (const struct _ns1__setCodingParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getCodingParamRes_Any:
		soap_serialize__ns1__getCodingParamRes_Any(soap, (const struct _ns1__getCodingParamRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getCodingParamRes:
		soap_serialize__ns1__getCodingParamRes(soap, (const struct _ns1__getCodingParamRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getCodingParamReq_Any:
		soap_serialize__ns1__getCodingParamReq_Any(soap, (const struct _ns1__getCodingParamReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getCodingParamReq:
		soap_serialize__ns1__getCodingParamReq(soap, (const struct _ns1__getCodingParamReq *)ptr);
		break;
	case SOAP_TYPE__ns1__presetControlRes_Any:
		soap_serialize__ns1__presetControlRes_Any(soap, (const struct _ns1__presetControlRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__presetControlRes:
		soap_serialize__ns1__presetControlRes(soap, (const struct _ns1__presetControlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__presetControlReq_Any:
		soap_serialize__ns1__presetControlReq_Any(soap, (const struct _ns1__presetControlReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__presetControlReq:
		soap_serialize__ns1__presetControlReq(soap, (const struct _ns1__presetControlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__lensControlRes_Any:
		soap_serialize__ns1__lensControlRes_Any(soap, (const struct _ns1__lensControlRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__lensControlRes:
		soap_serialize__ns1__lensControlRes(soap, (const struct _ns1__lensControlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__lensControlReq_Any:
		soap_serialize__ns1__lensControlReq_Any(soap, (const struct _ns1__lensControlReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__lensControlReq:
		soap_serialize__ns1__lensControlReq(soap, (const struct _ns1__lensControlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__ptzControlRes_Any:
		soap_serialize__ns1__ptzControlRes_Any(soap, (const struct _ns1__ptzControlRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__ptzControlRes:
		soap_serialize__ns1__ptzControlRes(soap, (const struct _ns1__ptzControlRes *)ptr);
		break;
	case SOAP_TYPE__ns1__ptzControlReq_Any:
		soap_serialize__ns1__ptzControlReq_Any(soap, (const struct _ns1__ptzControlReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__ptzControlReq:
		soap_serialize__ns1__ptzControlReq(soap, (const struct _ns1__ptzControlReq *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceRes_Any:
		soap_serialize__ns1__nullifyDeviceRes_Any(soap, (const struct _ns1__nullifyDeviceRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceRes:
		soap_serialize__ns1__nullifyDeviceRes(soap, (const struct _ns1__nullifyDeviceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceReq_Any:
		soap_serialize__ns1__nullifyDeviceReq_Any(soap, (const struct _ns1__nullifyDeviceReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__nullifyDeviceReq:
		soap_serialize__ns1__nullifyDeviceReq(soap, (const struct _ns1__nullifyDeviceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceRes_Any:
		soap_serialize__ns1__addDeviceRes_Any(soap, (const struct _ns1__addDeviceRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceRes:
		soap_serialize__ns1__addDeviceRes(soap, (const struct _ns1__addDeviceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceReq_Any:
		soap_serialize__ns1__addDeviceReq_Any(soap, (const struct _ns1__addDeviceReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__addDeviceReq:
		soap_serialize__ns1__addDeviceReq(soap, (const struct _ns1__addDeviceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateChannelNameRes_Any:
		soap_serialize__ns1__updateChannelNameRes_Any(soap, (const struct _ns1__updateChannelNameRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updateChannelNameRes:
		soap_serialize__ns1__updateChannelNameRes(soap, (const struct _ns1__updateChannelNameRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateChannelNameReq_Any:
		soap_serialize__ns1__updateChannelNameReq_Any(soap, (const struct _ns1__updateChannelNameReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updateChannelNameReq:
		soap_serialize__ns1__updateChannelNameReq(soap, (const struct _ns1__updateChannelNameReq *)ptr);
		break;
	case SOAP_TYPE__ns1__userLogoutRes_Any:
		soap_serialize__ns1__userLogoutRes_Any(soap, (const struct _ns1__userLogoutRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__userLogoutRes:
		soap_serialize__ns1__userLogoutRes(soap, (const struct _ns1__userLogoutRes *)ptr);
		break;
	case SOAP_TYPE__ns1__userLogoutReq_Any:
		soap_serialize__ns1__userLogoutReq_Any(soap, (const struct _ns1__userLogoutReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__userLogoutReq:
		soap_serialize__ns1__userLogoutReq(soap, (const struct _ns1__userLogoutReq *)ptr);
		break;
	case SOAP_TYPE__ns1__userLoginRes_Any:
		soap_serialize__ns1__userLoginRes_Any(soap, (const struct _ns1__userLoginRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__userLoginRes:
		soap_serialize__ns1__userLoginRes(soap, (const struct _ns1__userLoginRes *)ptr);
		break;
	case SOAP_TYPE__ns1__userLoginReq_Any:
		soap_serialize__ns1__userLoginReq_Any(soap, (const struct _ns1__userLoginReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__userLoginReq:
		soap_serialize__ns1__userLoginReq(soap, (const struct _ns1__userLoginReq *)ptr);
		break;
	case SOAP_TYPE__ns1__byeRes_Any:
		soap_serialize__ns1__byeRes_Any(soap, (const struct _ns1__byeRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__byeRes:
		soap_serialize__ns1__byeRes(soap, (const struct _ns1__byeRes *)ptr);
		break;
	case SOAP_TYPE__ns1__byeReq_Any:
		soap_serialize__ns1__byeReq_Any(soap, (const struct _ns1__byeReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__byeReq:
		soap_serialize__ns1__byeReq(soap, (const struct _ns1__byeReq *)ptr);
		break;
	case SOAP_TYPE__ns1__inviteRes_Any:
		soap_serialize__ns1__inviteRes_Any(soap, (const struct _ns1__inviteRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__inviteRes:
		soap_serialize__ns1__inviteRes(soap, (const struct _ns1__inviteRes *)ptr);
		break;
	case SOAP_TYPE__ns1__inviteReq_Any:
		soap_serialize__ns1__inviteReq_Any(soap, (const struct _ns1__inviteReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__inviteReq:
		soap_serialize__ns1__inviteReq(soap, (const struct _ns1__inviteReq *)ptr);
		break;
	case SOAP_TYPE__ns1__setAuxiliaryRes_Any:
		soap_serialize__ns1__setAuxiliaryRes_Any(soap, (const struct _ns1__setAuxiliaryRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setAuxiliaryRes:
		soap_serialize__ns1__setAuxiliaryRes(soap, (const struct _ns1__setAuxiliaryRes *)ptr);
		break;
	case SOAP_TYPE__ns1__setAuxiliaryReq_Any:
		soap_serialize__ns1__setAuxiliaryReq_Any(soap, (const struct _ns1__setAuxiliaryReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__setAuxiliaryReq:
		soap_serialize__ns1__setAuxiliaryReq(soap, (const struct _ns1__setAuxiliaryReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getAuxiliaryRes_Any:
		soap_serialize__ns1__getAuxiliaryRes_Any(soap, (const struct _ns1__getAuxiliaryRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getAuxiliaryRes:
		soap_serialize__ns1__getAuxiliaryRes(soap, (const struct _ns1__getAuxiliaryRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getAuxiliaryReq_Any:
		soap_serialize__ns1__getAuxiliaryReq_Any(soap, (const struct _ns1__getAuxiliaryReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getAuxiliaryReq:
		soap_serialize__ns1__getAuxiliaryReq(soap, (const struct _ns1__getAuxiliaryReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getBackPasswordRes_Any:
		soap_serialize__ns1__getBackPasswordRes_Any(soap, (const struct _ns1__getBackPasswordRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getBackPasswordRes:
		soap_serialize__ns1__getBackPasswordRes(soap, (const struct _ns1__getBackPasswordRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getBackPasswordReq_Any:
		soap_serialize__ns1__getBackPasswordReq_Any(soap, (const struct _ns1__getBackPasswordReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getBackPasswordReq:
		soap_serialize__ns1__getBackPasswordReq(soap, (const struct _ns1__getBackPasswordReq *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountRes_Any:
		soap_serialize__ns1__getAccountRes_Any(soap, (const struct _ns1__getAccountRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountRes:
		soap_serialize__ns1__getAccountRes(soap, (const struct _ns1__getAccountRes *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountReq_Any:
		soap_serialize__ns1__getAccountReq_Any(soap, (const struct _ns1__getAccountReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__getAccountReq:
		soap_serialize__ns1__getAccountReq(soap, (const struct _ns1__getAccountReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAppleTokenRes_Any:
		soap_serialize__ns1__updateAppleTokenRes_Any(soap, (const struct _ns1__updateAppleTokenRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAppleTokenRes:
		soap_serialize__ns1__updateAppleTokenRes(soap, (const struct _ns1__updateAppleTokenRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAppleTokenReq_Any:
		soap_serialize__ns1__updateAppleTokenReq_Any(soap, (const struct _ns1__updateAppleTokenReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAppleTokenReq:
		soap_serialize__ns1__updateAppleTokenReq(soap, (const struct _ns1__updateAppleTokenReq *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceRes_Any:
		soap_serialize__ns1__queryDeviceRes_Any(soap, (const struct _ns1__queryDeviceRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceRes:
		soap_serialize__ns1__queryDeviceRes(soap, (const struct _ns1__queryDeviceRes *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceReq_Any:
		soap_serialize__ns1__queryDeviceReq_Any(soap, (const struct _ns1__queryDeviceReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__queryDeviceReq:
		soap_serialize__ns1__queryDeviceReq(soap, (const struct _ns1__queryDeviceReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updatePasswordRes_Any:
		soap_serialize__ns1__updatePasswordRes_Any(soap, (const struct _ns1__updatePasswordRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updatePasswordRes:
		soap_serialize__ns1__updatePasswordRes(soap, (const struct _ns1__updatePasswordRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updatePasswordReq_Any:
		soap_serialize__ns1__updatePasswordReq_Any(soap, (const struct _ns1__updatePasswordReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updatePasswordReq:
		soap_serialize__ns1__updatePasswordReq(soap, (const struct _ns1__updatePasswordReq *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountRes_Any:
		soap_serialize__ns1__updateAccountRes_Any(soap, (const struct _ns1__updateAccountRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountRes:
		soap_serialize__ns1__updateAccountRes(soap, (const struct _ns1__updateAccountRes *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountReq_Any:
		soap_serialize__ns1__updateAccountReq_Any(soap, (const struct _ns1__updateAccountReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__updateAccountReq:
		soap_serialize__ns1__updateAccountReq(soap, (const struct _ns1__updateAccountReq *)ptr);
		break;
	case SOAP_TYPE__ns1__createAccountRes_Any:
		soap_serialize__ns1__createAccountRes_Any(soap, (const struct _ns1__createAccountRes_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__createAccountRes:
		soap_serialize__ns1__createAccountRes(soap, (const struct _ns1__createAccountRes *)ptr);
		break;
	case SOAP_TYPE__ns1__createAccountReq_Any:
		soap_serialize__ns1__createAccountReq_Any(soap, (const struct _ns1__createAccountReq_Any *)ptr);
		break;
	case SOAP_TYPE__ns1__createAccountReq:
		soap_serialize__ns1__createAccountReq(soap, (const struct _ns1__createAccountReq *)ptr);
		break;
	case SOAP_TYPE__ns1__VODRecord_Any:
		soap_serialize__ns1__VODRecord_Any(soap, (const struct _ns1__VODRecord_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__VODRecord:
		soap_serialize_ns1__VODRecord(soap, (const struct ns1__VODRecord *)ptr);
		break;
	case SOAP_TYPE__ns1__PrivacyMaskRegion_Any:
		soap_serialize__ns1__PrivacyMaskRegion_Any(soap, (const struct _ns1__PrivacyMaskRegion_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__PrivacyMaskRegion:
		soap_serialize_ns1__PrivacyMaskRegion(soap, (const struct ns1__PrivacyMaskRegion *)ptr);
		break;
	case SOAP_TYPE__ns1__VMDGrid_Any:
		soap_serialize__ns1__VMDGrid_Any(soap, (const struct _ns1__VMDGrid_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__VMDGrid:
		soap_serialize_ns1__VMDGrid(soap, (const struct ns1__VMDGrid *)ptr);
		break;
	case SOAP_TYPE__ns1__DevLog_Any:
		soap_serialize__ns1__DevLog_Any(soap, (const struct _ns1__DevLog_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__DevLog:
		soap_serialize_ns1__DevLog(soap, (const struct ns1__DevLog *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDevLog:
		soap_serialize_ns1__ArrayOfDevLog(soap, (const struct ns1__ArrayOfDevLog *)ptr);
		break;
	case SOAP_TYPE__ns1__PuLog_Any:
		soap_serialize__ns1__PuLog_Any(soap, (const struct _ns1__PuLog_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__PuLog:
		soap_serialize_ns1__PuLog(soap, (const struct ns1__PuLog *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfPuLog:
		soap_serialize_ns1__ArrayOfPuLog(soap, (const struct ns1__ArrayOfPuLog *)ptr);
		break;
	case SOAP_TYPE__ns1__Device_Any:
		soap_serialize__ns1__Device_Any(soap, (const struct _ns1__Device_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__Device:
		soap_serialize_ns1__Device(soap, (const struct ns1__Device *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDevice:
		soap_serialize_ns1__ArrayOfDevice(soap, (const struct ns1__ArrayOfDevice *)ptr);
		break;
	case SOAP_TYPE__ns1__Dev_Any:
		soap_serialize__ns1__Dev_Any(soap, (const struct _ns1__Dev_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__Dev:
		soap_serialize_ns1__Dev(soap, (const struct ns1__Dev *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfDev:
		soap_serialize_ns1__ArrayOfDev(soap, (const struct ns1__ArrayOfDev *)ptr);
		break;
	case SOAP_TYPE__ns1__NodeDetails_Any:
		soap_serialize__ns1__NodeDetails_Any(soap, (const struct _ns1__NodeDetails_Any *)ptr);
		break;
	case SOAP_TYPE_ns1__NodeDetails:
		soap_serialize_ns1__NodeDetails(soap, (const struct ns1__NodeDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__ArrayOfNodeDetails:
		soap_serialize_ns1__ArrayOfNodeDetails(soap, (const struct ns1__ArrayOfNodeDetails *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes:
		soap_serialize_PointerTo_ns1__vodSearchRes(soap, (struct _ns1__vodSearchRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq:
		soap_serialize_PointerTo_ns1__vodSearchReq(soap, (struct _ns1__vodSearchReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes:
		soap_serialize_PointerTo_ns1__getVODUrlRes(soap, (struct _ns1__getVODUrlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq:
		soap_serialize_PointerTo_ns1__getVODUrlReq(soap, (struct _ns1__getVODUrlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes:
		soap_serialize_PointerTo_ns1__getPlayUrlRes(soap, (struct _ns1__getPlayUrlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq:
		soap_serialize_PointerTo_ns1__getPlayUrlReq(soap, (struct _ns1__getPlayUrlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes:
		soap_serialize_PointerTo_ns1__setPrivacyMaskParamRes(soap, (struct _ns1__setPrivacyMaskParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq:
		soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq(soap, (struct _ns1__setPrivacyMaskParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes:
		soap_serialize_PointerTo_ns1__getPrivacyMaskParamRes(soap, (struct _ns1__getPrivacyMaskParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq:
		soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq(soap, (struct _ns1__getPrivacyMaskParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes:
		soap_serialize_PointerTo_ns1__setVMDParamRes(soap, (struct _ns1__setVMDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq:
		soap_serialize_PointerTo_ns1__setVMDParamReq(soap, (struct _ns1__setVMDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes:
		soap_serialize_PointerTo_ns1__getVMDParamRes(soap, (struct _ns1__getVMDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq:
		soap_serialize_PointerTo_ns1__getVMDParamReq(soap, (struct _ns1__getVMDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setTimeRes:
		soap_serialize_PointerTo_ns1__setTimeRes(soap, (struct _ns1__setTimeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setTimeReq:
		soap_serialize_PointerTo_ns1__setTimeReq(soap, (struct _ns1__setTimeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTimeRes:
		soap_serialize_PointerTo_ns1__getTimeRes(soap, (struct _ns1__getTimeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTimeReq:
		soap_serialize_PointerTo_ns1__getTimeReq(soap, (struct _ns1__getTimeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes:
		soap_serialize_PointerTo_ns1__setOSDParamRes(soap, (struct _ns1__setOSDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq:
		soap_serialize_PointerTo_ns1__setOSDParamReq(soap, (struct _ns1__setOSDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes:
		soap_serialize_PointerTo_ns1__getOSDParamRes(soap, (struct _ns1__getOSDParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq:
		soap_serialize_PointerTo_ns1__getOSDParamReq(soap, (struct _ns1__getOSDParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes:
		soap_serialize_PointerTo_ns1__setVideoParamRes(soap, (struct _ns1__setVideoParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq:
		soap_serialize_PointerTo_ns1__setVideoParamReq(soap, (struct _ns1__setVideoParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes:
		soap_serialize_PointerTo_ns1__getVideoParamRes(soap, (struct _ns1__getVideoParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq:
		soap_serialize_PointerTo_ns1__getVideoParamReq(soap, (struct _ns1__getVideoParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes:
		soap_serialize_PointerTo_ns1__queryDevLogRes(soap, (struct _ns1__queryDevLogRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq:
		soap_serialize_PointerTo_ns1__queryDevLogReq(soap, (struct _ns1__queryDevLogReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryLogRes:
		soap_serialize_PointerTo_ns1__queryLogRes(soap, (struct _ns1__queryLogRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryLogReq:
		soap_serialize_PointerTo_ns1__queryLogReq(soap, (struct _ns1__queryLogReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes:
		soap_serialize_PointerTo_ns1__upgradeDevVerRes(soap, (struct _ns1__upgradeDevVerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq:
		soap_serialize_PointerTo_ns1__upgradeDevVerReq(soap, (struct _ns1__upgradeDevVerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes:
		soap_serialize_PointerTo_ns1__getDevVerRes(soap, (struct _ns1__getDevVerRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq:
		soap_serialize_PointerTo_ns1__getDevVerReq(soap, (struct _ns1__getDevVerReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__rebootRes:
		soap_serialize_PointerTo_ns1__rebootRes(soap, (struct _ns1__rebootRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__rebootReq:
		soap_serialize_PointerTo_ns1__rebootReq(soap, (struct _ns1__rebootReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes:
		soap_serialize_PointerTo_ns1__setCodingParamRes(soap, (struct _ns1__setCodingParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq:
		soap_serialize_PointerTo_ns1__setCodingParamReq(soap, (struct _ns1__setCodingParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes:
		soap_serialize_PointerTo_ns1__getCodingParamRes(soap, (struct _ns1__getCodingParamRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq:
		soap_serialize_PointerTo_ns1__getCodingParamReq(soap, (struct _ns1__getCodingParamReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__presetControlRes:
		soap_serialize_PointerTo_ns1__presetControlRes(soap, (struct _ns1__presetControlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__presetControlReq:
		soap_serialize_PointerTo_ns1__presetControlReq(soap, (struct _ns1__presetControlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__lensControlRes:
		soap_serialize_PointerTo_ns1__lensControlRes(soap, (struct _ns1__lensControlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__lensControlReq:
		soap_serialize_PointerTo_ns1__lensControlReq(soap, (struct _ns1__lensControlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes:
		soap_serialize_PointerTo_ns1__ptzControlRes(soap, (struct _ns1__ptzControlRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq:
		soap_serialize_PointerTo_ns1__ptzControlReq(soap, (struct _ns1__ptzControlReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes:
		soap_serialize_PointerTo_ns1__nullifyDeviceRes(soap, (struct _ns1__nullifyDeviceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq:
		soap_serialize_PointerTo_ns1__nullifyDeviceReq(soap, (struct _ns1__nullifyDeviceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes:
		soap_serialize_PointerTo_ns1__addDeviceRes(soap, (struct _ns1__addDeviceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq:
		soap_serialize_PointerTo_ns1__addDeviceReq(soap, (struct _ns1__addDeviceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes:
		soap_serialize_PointerTo_ns1__updateChannelNameRes(soap, (struct _ns1__updateChannelNameRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq:
		soap_serialize_PointerTo_ns1__updateChannelNameReq(soap, (struct _ns1__updateChannelNameReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes:
		soap_serialize_PointerTo_ns1__userLogoutRes(soap, (struct _ns1__userLogoutRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq:
		soap_serialize_PointerTo_ns1__userLogoutReq(soap, (struct _ns1__userLogoutReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLoginRes:
		soap_serialize_PointerTo_ns1__userLoginRes(soap, (struct _ns1__userLoginRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLoginReq:
		soap_serialize_PointerTo_ns1__userLoginReq(soap, (struct _ns1__userLoginReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__byeRes:
		soap_serialize_PointerTo_ns1__byeRes(soap, (struct _ns1__byeRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__byeReq:
		soap_serialize_PointerTo_ns1__byeReq(soap, (struct _ns1__byeReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__inviteRes:
		soap_serialize_PointerTo_ns1__inviteRes(soap, (struct _ns1__inviteRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__inviteReq:
		soap_serialize_PointerTo_ns1__inviteReq(soap, (struct _ns1__inviteReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes:
		soap_serialize_PointerTo_ns1__setAuxiliaryRes(soap, (struct _ns1__setAuxiliaryRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq:
		soap_serialize_PointerTo_ns1__setAuxiliaryReq(soap, (struct _ns1__setAuxiliaryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes:
		soap_serialize_PointerTo_ns1__getAuxiliaryRes(soap, (struct _ns1__getAuxiliaryRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq:
		soap_serialize_PointerTo_ns1__getAuxiliaryReq(soap, (struct _ns1__getAuxiliaryReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes:
		soap_serialize_PointerTo_ns1__getBackPasswordRes(soap, (struct _ns1__getBackPasswordRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq:
		soap_serialize_PointerTo_ns1__getBackPasswordReq(soap, (struct _ns1__getBackPasswordReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountRes:
		soap_serialize_PointerTo_ns1__getAccountRes(soap, (struct _ns1__getAccountRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountReq:
		soap_serialize_PointerTo_ns1__getAccountReq(soap, (struct _ns1__getAccountReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes:
		soap_serialize_PointerTo_ns1__updateAppleTokenRes(soap, (struct _ns1__updateAppleTokenRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq:
		soap_serialize_PointerTo_ns1__updateAppleTokenReq(soap, (struct _ns1__updateAppleTokenReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes:
		soap_serialize_PointerTo_ns1__queryDeviceRes(soap, (struct _ns1__queryDeviceRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq:
		soap_serialize_PointerTo_ns1__queryDeviceReq(soap, (struct _ns1__queryDeviceReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes:
		soap_serialize_PointerTo_ns1__updatePasswordRes(soap, (struct _ns1__updatePasswordRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq:
		soap_serialize_PointerTo_ns1__updatePasswordReq(soap, (struct _ns1__updatePasswordReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes:
		soap_serialize_PointerTo_ns1__updateAccountRes(soap, (struct _ns1__updateAccountRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq:
		soap_serialize_PointerTo_ns1__updateAccountReq(soap, (struct _ns1__updateAccountReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createAccountRes:
		soap_serialize_PointerTo_ns1__createAccountRes(soap, (struct _ns1__createAccountRes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createAccountReq:
		soap_serialize_PointerTo_ns1__createAccountReq(soap, (struct _ns1__createAccountReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__vodSearchRes_Any:
		soap_serialize_PointerTo_ns1__vodSearchRes_Any(soap, (struct _ns1__vodSearchRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VODRecord:
		soap_serialize_PointerTons1__VODRecord(soap, (struct ns1__VODRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__vodSearchReq_Any:
		soap_serialize_PointerTo_ns1__vodSearchReq_Any(soap, (struct _ns1__vodSearchReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVODUrlRes_Any:
		soap_serialize_PointerTo_ns1__getVODUrlRes_Any(soap, (struct _ns1__getVODUrlRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVODUrlReq_Any:
		soap_serialize_PointerTo_ns1__getVODUrlReq_Any(soap, (struct _ns1__getVODUrlReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlRes_Any:
		soap_serialize_PointerTo_ns1__getPlayUrlRes_Any(soap, (struct _ns1__getPlayUrlRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPlayUrlReq_Any:
		soap_serialize_PointerTo_ns1__getPlayUrlReq_Any(soap, (struct _ns1__getPlayUrlReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes_Any:
		soap_serialize_PointerTo_ns1__setPrivacyMaskParamRes_Any(soap, (struct _ns1__setPrivacyMaskParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq_Any:
		soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq_Any(soap, (struct _ns1__setPrivacyMaskParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes_Any:
		soap_serialize_PointerTo_ns1__getPrivacyMaskParamRes_Any(soap, (struct _ns1__getPrivacyMaskParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PrivacyMaskRegion:
		soap_serialize_PointerTons1__PrivacyMaskRegion(soap, (struct ns1__PrivacyMaskRegion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq_Any:
		soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq_Any(soap, (struct _ns1__getPrivacyMaskParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVMDParamRes_Any:
		soap_serialize_PointerTo_ns1__setVMDParamRes_Any(soap, (struct _ns1__setVMDParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVMDParamReq_Any:
		soap_serialize_PointerTo_ns1__setVMDParamReq_Any(soap, (struct _ns1__setVMDParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVMDParamRes_Any:
		soap_serialize_PointerTo_ns1__getVMDParamRes_Any(soap, (struct _ns1__getVMDParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VMDGrid:
		soap_serialize_PointerTons1__VMDGrid(soap, (struct ns1__VMDGrid *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVMDParamReq_Any:
		soap_serialize_PointerTo_ns1__getVMDParamReq_Any(soap, (struct _ns1__getVMDParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setTimeRes_Any:
		soap_serialize_PointerTo_ns1__setTimeRes_Any(soap, (struct _ns1__setTimeRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setTimeReq_Any:
		soap_serialize_PointerTo_ns1__setTimeReq_Any(soap, (struct _ns1__setTimeReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTimeRes_Any:
		soap_serialize_PointerTo_ns1__getTimeRes_Any(soap, (struct _ns1__getTimeRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getTimeReq_Any:
		soap_serialize_PointerTo_ns1__getTimeReq_Any(soap, (struct _ns1__getTimeReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setOSDParamRes_Any:
		soap_serialize_PointerTo_ns1__setOSDParamRes_Any(soap, (struct _ns1__setOSDParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setOSDParamReq_Any:
		soap_serialize_PointerTo_ns1__setOSDParamReq_Any(soap, (struct _ns1__setOSDParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOSDParamRes_Any:
		soap_serialize_PointerTo_ns1__getOSDParamRes_Any(soap, (struct _ns1__getOSDParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getOSDParamReq_Any:
		soap_serialize_PointerTo_ns1__getOSDParamReq_Any(soap, (struct _ns1__getOSDParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVideoParamRes_Any:
		soap_serialize_PointerTo_ns1__setVideoParamRes_Any(soap, (struct _ns1__setVideoParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setVideoParamReq_Any:
		soap_serialize_PointerTo_ns1__setVideoParamReq_Any(soap, (struct _ns1__setVideoParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVideoParamRes_Any:
		soap_serialize_PointerTo_ns1__getVideoParamRes_Any(soap, (struct _ns1__getVideoParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VideoStandard:
		soap_serialize_PointerTons1__VideoStandard(soap, (enum ns1__VideoStandard *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getVideoParamReq_Any:
		soap_serialize_PointerTo_ns1__getVideoParamReq_Any(soap, (struct _ns1__getVideoParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDevLogRes_Any:
		soap_serialize_PointerTo_ns1__queryDevLogRes_Any(soap, (struct _ns1__queryDevLogRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDevLog:
		soap_serialize_PointerTons1__ArrayOfDevLog(soap, (struct ns1__ArrayOfDevLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDevLogReq_Any:
		soap_serialize_PointerTo_ns1__queryDevLogReq_Any(soap, (struct _ns1__queryDevLogReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryLogRes_Any:
		soap_serialize_PointerTo_ns1__queryLogRes_Any(soap, (struct _ns1__queryLogRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfPuLog:
		soap_serialize_PointerTons1__ArrayOfPuLog(soap, (struct ns1__ArrayOfPuLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryLogReq_Any:
		soap_serialize_PointerTo_ns1__queryLogReq_Any(soap, (struct _ns1__queryLogReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes_Any:
		soap_serialize_PointerTo_ns1__upgradeDevVerRes_Any(soap, (struct _ns1__upgradeDevVerRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq_Any:
		soap_serialize_PointerTo_ns1__upgradeDevVerReq_Any(soap, (struct _ns1__upgradeDevVerReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDevVerRes_Any:
		soap_serialize_PointerTo_ns1__getDevVerRes_Any(soap, (struct _ns1__getDevVerRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getDevVerReq_Any:
		soap_serialize_PointerTo_ns1__getDevVerReq_Any(soap, (struct _ns1__getDevVerReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__rebootRes_Any:
		soap_serialize_PointerTo_ns1__rebootRes_Any(soap, (struct _ns1__rebootRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__rebootReq_Any:
		soap_serialize_PointerTo_ns1__rebootReq_Any(soap, (struct _ns1__rebootReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setCodingParamRes_Any:
		soap_serialize_PointerTo_ns1__setCodingParamRes_Any(soap, (struct _ns1__setCodingParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setCodingParamReq_Any:
		soap_serialize_PointerTo_ns1__setCodingParamReq_Any(soap, (struct _ns1__setCodingParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCodingParamRes_Any:
		soap_serialize_PointerTo_ns1__getCodingParamRes_Any(soap, (struct _ns1__getCodingParamRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RateType:
		soap_serialize_PointerTons1__RateType(soap, (enum ns1__RateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FrameSize:
		soap_serialize_PointerTons1__FrameSize(soap, (enum ns1__FrameSize *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCodingParamReq_Any:
		soap_serialize_PointerTo_ns1__getCodingParamReq_Any(soap, (struct _ns1__getCodingParamReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__presetControlRes_Any:
		soap_serialize_PointerTo_ns1__presetControlRes_Any(soap, (struct _ns1__presetControlRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__presetControlReq_Any:
		soap_serialize_PointerTo_ns1__presetControlReq_Any(soap, (struct _ns1__presetControlReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__lensControlRes_Any:
		soap_serialize_PointerTo_ns1__lensControlRes_Any(soap, (struct _ns1__lensControlRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__lensControlReq_Any:
		soap_serialize_PointerTo_ns1__lensControlReq_Any(soap, (struct _ns1__lensControlReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ptzControlRes_Any:
		soap_serialize_PointerTo_ns1__ptzControlRes_Any(soap, (struct _ns1__ptzControlRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ptzControlReq_Any:
		soap_serialize_PointerTo_ns1__ptzControlReq_Any(soap, (struct _ns1__ptzControlReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes_Any:
		soap_serialize_PointerTo_ns1__nullifyDeviceRes_Any(soap, (struct _ns1__nullifyDeviceRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq_Any:
		soap_serialize_PointerTo_ns1__nullifyDeviceReq_Any(soap, (struct _ns1__nullifyDeviceReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceRes_Any:
		soap_serialize_PointerTo_ns1__addDeviceRes_Any(soap, (struct _ns1__addDeviceRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addDeviceReq_Any:
		soap_serialize_PointerTo_ns1__addDeviceReq_Any(soap, (struct _ns1__addDeviceReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDevice:
		soap_serialize_PointerTons1__ArrayOfDevice(soap, (struct ns1__ArrayOfDevice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameRes_Any:
		soap_serialize_PointerTo_ns1__updateChannelNameRes_Any(soap, (struct _ns1__updateChannelNameRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateChannelNameReq_Any:
		soap_serialize_PointerTo_ns1__updateChannelNameReq_Any(soap, (struct _ns1__updateChannelNameReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLogoutRes_Any:
		soap_serialize_PointerTo_ns1__userLogoutRes_Any(soap, (struct _ns1__userLogoutRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLogoutReq_Any:
		soap_serialize_PointerTo_ns1__userLogoutReq_Any(soap, (struct _ns1__userLogoutReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLoginRes_Any:
		soap_serialize_PointerTo_ns1__userLoginRes_Any(soap, (struct _ns1__userLoginRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDev:
		soap_serialize_PointerTons1__ArrayOfDev(soap, (struct ns1__ArrayOfDev *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userLoginReq_Any:
		soap_serialize_PointerTo_ns1__userLoginReq_Any(soap, (struct _ns1__userLoginReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__byeRes_Any:
		soap_serialize_PointerTo_ns1__byeRes_Any(soap, (struct _ns1__byeRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__byeReq_Any:
		soap_serialize_PointerTo_ns1__byeReq_Any(soap, (struct _ns1__byeReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__inviteRes_Any:
		soap_serialize_PointerTo_ns1__inviteRes_Any(soap, (struct _ns1__inviteRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__inviteReq_Any:
		soap_serialize_PointerTo_ns1__inviteReq_Any(soap, (struct _ns1__inviteReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes_Any:
		soap_serialize_PointerTo_ns1__setAuxiliaryRes_Any(soap, (struct _ns1__setAuxiliaryRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq_Any:
		soap_serialize_PointerTo_ns1__setAuxiliaryReq_Any(soap, (struct _ns1__setAuxiliaryReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuxiliaryType:
		soap_serialize_PointerTons1__AuxiliaryType(soap, (enum ns1__AuxiliaryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes_Any:
		soap_serialize_PointerTo_ns1__getAuxiliaryRes_Any(soap, (struct _ns1__getAuxiliaryRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuxiliaryState:
		soap_serialize_PointerTons1__AuxiliaryState(soap, (enum ns1__AuxiliaryState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq_Any:
		soap_serialize_PointerTo_ns1__getAuxiliaryReq_Any(soap, (struct _ns1__getAuxiliaryReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordRes_Any:
		soap_serialize_PointerTo_ns1__getBackPasswordRes_Any(soap, (struct _ns1__getBackPasswordRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getBackPasswordReq_Any:
		soap_serialize_PointerTo_ns1__getBackPasswordReq_Any(soap, (struct _ns1__getBackPasswordReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountRes_Any:
		soap_serialize_PointerTo_ns1__getAccountRes_Any(soap, (struct _ns1__getAccountRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getAccountReq_Any:
		soap_serialize_PointerTo_ns1__getAccountReq_Any(soap, (struct _ns1__getAccountReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes_Any:
		soap_serialize_PointerTo_ns1__updateAppleTokenRes_Any(soap, (struct _ns1__updateAppleTokenRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq_Any:
		soap_serialize_PointerTo_ns1__updateAppleTokenReq_Any(soap, (struct _ns1__updateAppleTokenReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceRes_Any:
		soap_serialize_PointerTo_ns1__queryDeviceRes_Any(soap, (struct _ns1__queryDeviceRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfNodeDetails:
		soap_serialize_PointerTons1__ArrayOfNodeDetails(soap, (struct ns1__ArrayOfNodeDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__queryDeviceReq_Any:
		soap_serialize_PointerTo_ns1__queryDeviceReq_Any(soap, (struct _ns1__queryDeviceReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updatePasswordRes_Any:
		soap_serialize_PointerTo_ns1__updatePasswordRes_Any(soap, (struct _ns1__updatePasswordRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updatePasswordReq_Any:
		soap_serialize_PointerTo_ns1__updatePasswordReq_Any(soap, (struct _ns1__updatePasswordReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountRes_Any:
		soap_serialize_PointerTo_ns1__updateAccountRes_Any(soap, (struct _ns1__updateAccountRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__updateAccountReq_Any:
		soap_serialize_PointerTo_ns1__updateAccountReq_Any(soap, (struct _ns1__updateAccountReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createAccountRes_Any:
		soap_serialize_PointerTo_ns1__createAccountRes_Any(soap, (struct _ns1__createAccountRes_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__createAccountReq_Any:
		soap_serialize_PointerTo_ns1__createAccountReq_Any(soap, (struct _ns1__createAccountReq_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166:
		soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, (enum ns1__CountryAbbr2ISO3166 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__VODRecord_Any:
		soap_serialize_PointerTo_ns1__VODRecord_Any(soap, (struct _ns1__VODRecord_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PrivacyMaskRegion_Any:
		soap_serialize_PointerTo_ns1__PrivacyMaskRegion_Any(soap, (struct _ns1__PrivacyMaskRegion_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__VMDGrid_Any:
		soap_serialize_PointerTo_ns1__VMDGrid_Any(soap, (struct _ns1__VMDGrid_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DevLog_Any:
		soap_serialize_PointerTo_ns1__DevLog_Any(soap, (struct _ns1__DevLog_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DevLog:
		soap_serialize_PointerTons1__DevLog(soap, (struct ns1__DevLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PuLog_Any:
		soap_serialize_PointerTo_ns1__PuLog_Any(soap, (struct _ns1__PuLog_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PuLog:
		soap_serialize_PointerTons1__PuLog(soap, (struct ns1__PuLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Device_Any:
		soap_serialize_PointerTo_ns1__Device_Any(soap, (struct _ns1__Device_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Device:
		soap_serialize_PointerTons1__Device(soap, (struct ns1__Device *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Dev_Any:
		soap_serialize_PointerTo_ns1__Dev_Any(soap, (struct _ns1__Dev_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Dev:
		soap_serialize_PointerTons1__Dev(soap, (struct ns1__Dev *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__NodeDetails_Any:
		soap_serialize_PointerTo_ns1__NodeDetails_Any(soap, (struct _ns1__NodeDetails_Any *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NodeDetails:
		soap_serialize_PointerTons1__NodeDetails(soap, (struct ns1__NodeDetails *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__VideoStandard
	*a = SOAP_DEFAULT_ns1__VideoStandard;
#else
	*a = (enum ns1__VideoStandard)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__VideoStandard[] =
{	{ (long)ns1__VideoStandard__PAL, "PAL" },
	{ (long)ns1__VideoStandard__NTSC, "NTSC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__VideoStandard2s(struct soap *soap, enum ns1__VideoStandard n)
{	const char *s = soap_code_str(soap_codes_ns1__VideoStandard, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VideoStandard(struct soap *soap, const char *tag, int id, const enum ns1__VideoStandard *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VideoStandard), type) || soap_send(soap, soap_ns1__VideoStandard2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__VideoStandard(struct soap *soap, const char *s, enum ns1__VideoStandard *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__VideoStandard, s);
	if (map)
		*a = (enum ns1__VideoStandard)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__VideoStandard)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__VideoStandard * SOAP_FMAC4 soap_in_ns1__VideoStandard(struct soap *soap, const char *tag, enum ns1__VideoStandard *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__VideoStandard *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VideoStandard, sizeof(enum ns1__VideoStandard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__VideoStandard(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__VideoStandard *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VideoStandard, 0, sizeof(enum ns1__VideoStandard), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VideoStandard(struct soap *soap, const enum ns1__VideoStandard *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VideoStandard);
	if (soap_out_ns1__VideoStandard(soap, tag?tag:"ns1:VideoStandard", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__VideoStandard * SOAP_FMAC4 soap_get_ns1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VideoStandard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RateType(struct soap *soap, enum ns1__RateType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__RateType
	*a = SOAP_DEFAULT_ns1__RateType;
#else
	*a = (enum ns1__RateType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__RateType[] =
{	{ (long)ns1__RateType__CBR, "CBR" },
	{ (long)ns1__RateType__VBR, "VBR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RateType2s(struct soap *soap, enum ns1__RateType n)
{	const char *s = soap_code_str(soap_codes_ns1__RateType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RateType(struct soap *soap, const char *tag, int id, const enum ns1__RateType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RateType), type) || soap_send(soap, soap_ns1__RateType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RateType(struct soap *soap, const char *s, enum ns1__RateType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RateType, s);
	if (map)
		*a = (enum ns1__RateType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RateType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RateType * SOAP_FMAC4 soap_in_ns1__RateType(struct soap *soap, const char *tag, enum ns1__RateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RateType, sizeof(enum ns1__RateType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__RateType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__RateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RateType, 0, sizeof(enum ns1__RateType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RateType(struct soap *soap, const enum ns1__RateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RateType);
	if (soap_out_ns1__RateType(soap, tag?tag:"ns1:RateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RateType * SOAP_FMAC4 soap_get_ns1__RateType(struct soap *soap, enum ns1__RateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FrameSize(struct soap *soap, enum ns1__FrameSize *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__FrameSize
	*a = SOAP_DEFAULT_ns1__FrameSize;
#else
	*a = (enum ns1__FrameSize)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__FrameSize[] =
{	{ (long)ns1__FrameSize__HD720P, "HD720P" },
	{ (long)ns1__FrameSize__VGA, "VGA" },
	{ (long)ns1__FrameSize__D1, "D1" },
	{ (long)ns1__FrameSize__CIF, "CIF" },
	{ (long)ns1__FrameSize__QVGA, "QVGA" },
	{ (long)ns1__FrameSize__HD1080P, "HD1080P" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__FrameSize2s(struct soap *soap, enum ns1__FrameSize n)
{	const char *s = soap_code_str(soap_codes_ns1__FrameSize, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FrameSize(struct soap *soap, const char *tag, int id, const enum ns1__FrameSize *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FrameSize), type) || soap_send(soap, soap_ns1__FrameSize2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__FrameSize(struct soap *soap, const char *s, enum ns1__FrameSize *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__FrameSize, s);
	if (map)
		*a = (enum ns1__FrameSize)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__FrameSize)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__FrameSize * SOAP_FMAC4 soap_in_ns1__FrameSize(struct soap *soap, const char *tag, enum ns1__FrameSize *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__FrameSize *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FrameSize, sizeof(enum ns1__FrameSize), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__FrameSize(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__FrameSize *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FrameSize, 0, sizeof(enum ns1__FrameSize), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FrameSize(struct soap *soap, const enum ns1__FrameSize *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__FrameSize);
	if (soap_out_ns1__FrameSize(soap, tag?tag:"ns1:FrameSize", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FrameSize * SOAP_FMAC4 soap_get_ns1__FrameSize(struct soap *soap, enum ns1__FrameSize *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FrameSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PTZPreset(struct soap *soap, enum ns1__PTZPreset *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PTZPreset
	*a = SOAP_DEFAULT_ns1__PTZPreset;
#else
	*a = (enum ns1__PTZPreset)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PTZPreset[] =
{	{ (long)ns1__PTZPreset__Clear, "Clear" },
	{ (long)ns1__PTZPreset__Set, "Set" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PTZPreset2s(struct soap *soap, enum ns1__PTZPreset n)
{	const char *s = soap_code_str(soap_codes_ns1__PTZPreset, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZPreset(struct soap *soap, const char *tag, int id, const enum ns1__PTZPreset *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZPreset), type) || soap_send(soap, soap_ns1__PTZPreset2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PTZPreset(struct soap *soap, const char *s, enum ns1__PTZPreset *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PTZPreset, s);
	if (map)
		*a = (enum ns1__PTZPreset)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PTZPreset)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PTZPreset * SOAP_FMAC4 soap_in_ns1__PTZPreset(struct soap *soap, const char *tag, enum ns1__PTZPreset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PTZPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZPreset, sizeof(enum ns1__PTZPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PTZPreset(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZPreset, 0, sizeof(enum ns1__PTZPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PTZPreset(struct soap *soap, const enum ns1__PTZPreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PTZPreset);
	if (soap_out_ns1__PTZPreset(soap, tag?tag:"ns1:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PTZPreset * SOAP_FMAC4 soap_get_ns1__PTZPreset(struct soap *soap, enum ns1__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PTZLens(struct soap *soap, enum ns1__PTZLens *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PTZLens
	*a = SOAP_DEFAULT_ns1__PTZLens;
#else
	*a = (enum ns1__PTZLens)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PTZLens[] =
{	{ (long)ns1__PTZLens__Stop, "Stop" },
	{ (long)ns1__PTZLens__IrisOpen, "IrisOpen" },
	{ (long)ns1__PTZLens__IrisClose, "IrisClose" },
	{ (long)ns1__PTZLens__ZoomTele, "ZoomTele" },
	{ (long)ns1__PTZLens__ZoomWide, "ZoomWide" },
	{ (long)ns1__PTZLens__FocusFar, "FocusFar" },
	{ (long)ns1__PTZLens__FocusNear, "FocusNear" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PTZLens2s(struct soap *soap, enum ns1__PTZLens n)
{	const char *s = soap_code_str(soap_codes_ns1__PTZLens, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZLens(struct soap *soap, const char *tag, int id, const enum ns1__PTZLens *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZLens), type) || soap_send(soap, soap_ns1__PTZLens2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PTZLens(struct soap *soap, const char *s, enum ns1__PTZLens *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PTZLens, s);
	if (map)
		*a = (enum ns1__PTZLens)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PTZLens)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PTZLens * SOAP_FMAC4 soap_in_ns1__PTZLens(struct soap *soap, const char *tag, enum ns1__PTZLens *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PTZLens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZLens, sizeof(enum ns1__PTZLens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PTZLens(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PTZLens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZLens, 0, sizeof(enum ns1__PTZLens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PTZLens(struct soap *soap, const enum ns1__PTZLens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PTZLens);
	if (soap_out_ns1__PTZLens(soap, tag?tag:"ns1:PTZLens", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PTZLens * SOAP_FMAC4 soap_get_ns1__PTZLens(struct soap *soap, enum ns1__PTZLens *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZLens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PTZDirection(struct soap *soap, enum ns1__PTZDirection *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PTZDirection
	*a = SOAP_DEFAULT_ns1__PTZDirection;
#else
	*a = (enum ns1__PTZDirection)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PTZDirection[] =
{	{ (long)ns1__PTZDirection__Stop, "Stop" },
	{ (long)ns1__PTZDirection__Up, "Up" },
	{ (long)ns1__PTZDirection__Down, "Down" },
	{ (long)ns1__PTZDirection__Left, "Left" },
	{ (long)ns1__PTZDirection__Right, "Right" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PTZDirection2s(struct soap *soap, enum ns1__PTZDirection n)
{	const char *s = soap_code_str(soap_codes_ns1__PTZDirection, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PTZDirection(struct soap *soap, const char *tag, int id, const enum ns1__PTZDirection *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PTZDirection), type) || soap_send(soap, soap_ns1__PTZDirection2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PTZDirection(struct soap *soap, const char *s, enum ns1__PTZDirection *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PTZDirection, s);
	if (map)
		*a = (enum ns1__PTZDirection)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PTZDirection)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PTZDirection * SOAP_FMAC4 soap_in_ns1__PTZDirection(struct soap *soap, const char *tag, enum ns1__PTZDirection *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PTZDirection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PTZDirection, sizeof(enum ns1__PTZDirection), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PTZDirection(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PTZDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PTZDirection, 0, sizeof(enum ns1__PTZDirection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PTZDirection(struct soap *soap, const enum ns1__PTZDirection *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PTZDirection);
	if (soap_out_ns1__PTZDirection(soap, tag?tag:"ns1:PTZDirection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PTZDirection * SOAP_FMAC4 soap_get_ns1__PTZDirection(struct soap *soap, enum ns1__PTZDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PTZDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PwdType(struct soap *soap, enum ns1__PwdType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PwdType
	*a = SOAP_DEFAULT_ns1__PwdType;
#else
	*a = (enum ns1__PwdType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__PwdType[] =
{	{ (long)ns1__PwdType__Common, "Common" },
	{ (long)ns1__PwdType__Dynamic, "Dynamic" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__PwdType2s(struct soap *soap, enum ns1__PwdType n)
{	const char *s = soap_code_str(soap_codes_ns1__PwdType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PwdType(struct soap *soap, const char *tag, int id, const enum ns1__PwdType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PwdType), type) || soap_send(soap, soap_ns1__PwdType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__PwdType(struct soap *soap, const char *s, enum ns1__PwdType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__PwdType, s);
	if (map)
		*a = (enum ns1__PwdType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__PwdType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__PwdType * SOAP_FMAC4 soap_in_ns1__PwdType(struct soap *soap, const char *tag, enum ns1__PwdType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__PwdType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PwdType, sizeof(enum ns1__PwdType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__PwdType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__PwdType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PwdType, 0, sizeof(enum ns1__PwdType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PwdType(struct soap *soap, const enum ns1__PwdType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PwdType);
	if (soap_out_ns1__PwdType(soap, tag?tag:"ns1:PwdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__PwdType * SOAP_FMAC4 soap_get_ns1__PwdType(struct soap *soap, enum ns1__PwdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PwdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StreamType(struct soap *soap, enum ns1__StreamType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__StreamType
	*a = SOAP_DEFAULT_ns1__StreamType;
#else
	*a = (enum ns1__StreamType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__StreamType[] =
{	{ (long)ns1__StreamType__Main, "Main" },
	{ (long)ns1__StreamType__Sub, "Sub" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StreamType2s(struct soap *soap, enum ns1__StreamType n)
{	const char *s = soap_code_str(soap_codes_ns1__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StreamType(struct soap *soap, const char *tag, int id, const enum ns1__StreamType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StreamType), type) || soap_send(soap, soap_ns1__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StreamType(struct soap *soap, const char *s, enum ns1__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__StreamType, s);
	if (map)
		*a = (enum ns1__StreamType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StreamType * SOAP_FMAC4 soap_in_ns1__StreamType(struct soap *soap, const char *tag, enum ns1__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StreamType, sizeof(enum ns1__StreamType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__StreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StreamType, 0, sizeof(enum ns1__StreamType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StreamType(struct soap *soap, const enum ns1__StreamType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StreamType);
	if (soap_out_ns1__StreamType(soap, tag?tag:"ns1:StreamType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__StreamType * SOAP_FMAC4 soap_get_ns1__StreamType(struct soap *soap, enum ns1__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__AuxiliaryState
	*a = SOAP_DEFAULT_ns1__AuxiliaryState;
#else
	*a = (enum ns1__AuxiliaryState)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__AuxiliaryState[] =
{	{ (long)ns1__AuxiliaryState__Inactive, "Inactive" },
	{ (long)ns1__AuxiliaryState__Active, "Active" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AuxiliaryState2s(struct soap *soap, enum ns1__AuxiliaryState n)
{	const char *s = soap_code_str(soap_codes_ns1__AuxiliaryState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuxiliaryState(struct soap *soap, const char *tag, int id, const enum ns1__AuxiliaryState *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuxiliaryState), type) || soap_send(soap, soap_ns1__AuxiliaryState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AuxiliaryState(struct soap *soap, const char *s, enum ns1__AuxiliaryState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AuxiliaryState, s);
	if (map)
		*a = (enum ns1__AuxiliaryState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AuxiliaryState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AuxiliaryState * SOAP_FMAC4 soap_in_ns1__AuxiliaryState(struct soap *soap, const char *tag, enum ns1__AuxiliaryState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AuxiliaryState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuxiliaryState, sizeof(enum ns1__AuxiliaryState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__AuxiliaryState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuxiliaryState, 0, sizeof(enum ns1__AuxiliaryState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AuxiliaryState(struct soap *soap, const enum ns1__AuxiliaryState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AuxiliaryState);
	if (soap_out_ns1__AuxiliaryState(soap, tag?tag:"ns1:AuxiliaryState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryState * SOAP_FMAC4 soap_get_ns1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuxiliaryState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__AuxiliaryType
	*a = SOAP_DEFAULT_ns1__AuxiliaryType;
#else
	*a = (enum ns1__AuxiliaryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__AuxiliaryType[] =
{	{ (long)ns1__AuxiliaryType__Lighting, "Lighting" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AuxiliaryType2s(struct soap *soap, enum ns1__AuxiliaryType n)
{	const char *s = soap_code_str(soap_codes_ns1__AuxiliaryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuxiliaryType(struct soap *soap, const char *tag, int id, const enum ns1__AuxiliaryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuxiliaryType), type) || soap_send(soap, soap_ns1__AuxiliaryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AuxiliaryType(struct soap *soap, const char *s, enum ns1__AuxiliaryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AuxiliaryType, s);
	if (map)
		*a = (enum ns1__AuxiliaryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AuxiliaryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AuxiliaryType * SOAP_FMAC4 soap_in_ns1__AuxiliaryType(struct soap *soap, const char *tag, enum ns1__AuxiliaryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AuxiliaryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuxiliaryType, sizeof(enum ns1__AuxiliaryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__AuxiliaryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuxiliaryType, 0, sizeof(enum ns1__AuxiliaryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AuxiliaryType(struct soap *soap, const enum ns1__AuxiliaryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AuxiliaryType);
	if (soap_out_ns1__AuxiliaryType(soap, tag?tag:"ns1:AuxiliaryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryType * SOAP_FMAC4 soap_get_ns1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuxiliaryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeliveryType(struct soap *soap, enum ns1__DeliveryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__DeliveryType
	*a = SOAP_DEFAULT_ns1__DeliveryType;
#else
	*a = (enum ns1__DeliveryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__DeliveryType[] =
{	{ (long)ns1__DeliveryType__Email, "Email" },
	{ (long)ns1__DeliveryType__Mobile, "Mobile" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DeliveryType2s(struct soap *soap, enum ns1__DeliveryType n)
{	const char *s = soap_code_str(soap_codes_ns1__DeliveryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeliveryType(struct soap *soap, const char *tag, int id, const enum ns1__DeliveryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeliveryType), type) || soap_send(soap, soap_ns1__DeliveryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DeliveryType(struct soap *soap, const char *s, enum ns1__DeliveryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DeliveryType, s);
	if (map)
		*a = (enum ns1__DeliveryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DeliveryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DeliveryType * SOAP_FMAC4 soap_in_ns1__DeliveryType(struct soap *soap, const char *tag, enum ns1__DeliveryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DeliveryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeliveryType, sizeof(enum ns1__DeliveryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__DeliveryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DeliveryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeliveryType, 0, sizeof(enum ns1__DeliveryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeliveryType(struct soap *soap, const enum ns1__DeliveryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DeliveryType);
	if (soap_out_ns1__DeliveryType(soap, tag?tag:"ns1:DeliveryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DeliveryType * SOAP_FMAC4 soap_get_ns1__DeliveryType(struct soap *soap, enum ns1__DeliveryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeliveryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MCUResult(struct soap *soap, enum ns1__MCUResult *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MCUResult
	*a = SOAP_DEFAULT_ns1__MCUResult;
#else
	*a = (enum ns1__MCUResult)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MCUResult[] =
{	{ (long)ns1__MCUResult__OK, "OK" },
	{ (long)ns1__MCUResult__AccountNotExist, "AccountNotExist" },
	{ (long)ns1__MCUResult__SessionExpired, "SessionExpired" },
	{ (long)ns1__MCUResult__DeviceNotExist, "DeviceNotExist" },
	{ (long)ns1__MCUResult__AccountExist, "AccountExist" },
	{ (long)ns1__MCUResult__EmailExist, "EmailExist" },
	{ (long)ns1__MCUResult__AccountFormat, "AccountFormat" },
	{ (long)ns1__MCUResult__EmailFormat, "EmailFormat" },
	{ (long)ns1__MCUResult__PasswordFormat, "PasswordFormat" },
	{ (long)ns1__MCUResult__NicknameFormat, "NicknameFormat" },
	{ (long)ns1__MCUResult__MobileTelFormat, "MobileTelFormat" },
	{ (long)ns1__MCUResult__Authencation, "Authencation" },
	{ (long)ns1__MCUResult__MobileTelExist, "MobileTelExist" },
	{ (long)ns1__MCUResult__MCUVersion, "MCUVersion" },
	{ (long)ns1__MCUResult__DeviceAuthencation, "DeviceAuthencation" },
	{ (long)ns1__MCUResult__DeviceOffline, "DeviceOffline" },
	{ (long)ns1__MCUResult__ParamIllegal, "ParamIllegal" },
	{ (long)ns1__MCUResult__HashTokenIllegal, "HashTokenIllegal" },
	{ (long)ns1__MCUResult__ServiceBusy, "ServiceBusy" },
	{ (long)ns1__MCUResult__NotSupport, "NotSupport" },
	{ (long)ns1__MCUResult__DeviceBusy, "DeviceBusy" },
	{ (long)ns1__MCUResult__EmailSend, "EmailSend" },
	{ (long)ns1__MCUResult__SMSSend, "SMSSend" },
	{ (long)ns1__MCUResult__AccessDenied, "AccessDenied" },
	{ (long)ns1__MCUResult__DeviceSessionExpired, "DeviceSessionExpired" },
	{ (long)ns1__MCUResult__NotAllowSession, "NotAllowSession" },
	{ (long)ns1__MCUResult__DeviceError, "DeviceError" },
	{ (long)ns1__MCUResult__UnKnow, "UnKnow" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MCUResult2s(struct soap *soap, enum ns1__MCUResult n)
{	const char *s = soap_code_str(soap_codes_ns1__MCUResult, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MCUResult(struct soap *soap, const char *tag, int id, const enum ns1__MCUResult *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MCUResult), type) || soap_send(soap, soap_ns1__MCUResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MCUResult(struct soap *soap, const char *s, enum ns1__MCUResult *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MCUResult, s);
	if (map)
		*a = (enum ns1__MCUResult)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 27)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MCUResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MCUResult * SOAP_FMAC4 soap_in_ns1__MCUResult(struct soap *soap, const char *tag, enum ns1__MCUResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MCUResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MCUResult, sizeof(enum ns1__MCUResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MCUResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MCUResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MCUResult, 0, sizeof(enum ns1__MCUResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MCUResult(struct soap *soap, const enum ns1__MCUResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MCUResult);
	if (soap_out_ns1__MCUResult(soap, tag?tag:"ns1:MCUResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MCUResult * SOAP_FMAC4 soap_get_ns1__MCUResult(struct soap *soap, enum ns1__MCUResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MCUResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__CountryAbbr2ISO3166
	*a = SOAP_DEFAULT_ns1__CountryAbbr2ISO3166;
#else
	*a = (enum ns1__CountryAbbr2ISO3166)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__CountryAbbr2ISO3166[] =
{	{ (long)ns1__CountryAbbr2ISO3166__AF, "AF" },
	{ (long)ns1__CountryAbbr2ISO3166__AL, "AL" },
	{ (long)ns1__CountryAbbr2ISO3166__DZ, "DZ" },
	{ (long)ns1__CountryAbbr2ISO3166__AS, "AS" },
	{ (long)ns1__CountryAbbr2ISO3166__AD, "AD" },
	{ (long)ns1__CountryAbbr2ISO3166__AO, "AO" },
	{ (long)ns1__CountryAbbr2ISO3166__AI, "AI" },
	{ (long)ns1__CountryAbbr2ISO3166__AG, "AG" },
	{ (long)ns1__CountryAbbr2ISO3166__AR, "AR" },
	{ (long)ns1__CountryAbbr2ISO3166__AM, "AM" },
	{ (long)ns1__CountryAbbr2ISO3166__AW, "AW" },
	{ (long)ns1__CountryAbbr2ISO3166__AU, "AU" },
	{ (long)ns1__CountryAbbr2ISO3166__AT, "AT" },
	{ (long)ns1__CountryAbbr2ISO3166__AZ, "AZ" },
	{ (long)ns1__CountryAbbr2ISO3166__BH, "BH" },
	{ (long)ns1__CountryAbbr2ISO3166__BD, "BD" },
	{ (long)ns1__CountryAbbr2ISO3166__BB, "BB" },
	{ (long)ns1__CountryAbbr2ISO3166__BY, "BY" },
	{ (long)ns1__CountryAbbr2ISO3166__BE, "BE" },
	{ (long)ns1__CountryAbbr2ISO3166__BZ, "BZ" },
	{ (long)ns1__CountryAbbr2ISO3166__BJ, "BJ" },
	{ (long)ns1__CountryAbbr2ISO3166__BM, "BM" },
	{ (long)ns1__CountryAbbr2ISO3166__BT, "BT" },
	{ (long)ns1__CountryAbbr2ISO3166__BO, "BO" },
	{ (long)ns1__CountryAbbr2ISO3166__BA, "BA" },
	{ (long)ns1__CountryAbbr2ISO3166__BW, "BW" },
	{ (long)ns1__CountryAbbr2ISO3166__BR, "BR" },
	{ (long)ns1__CountryAbbr2ISO3166__BN, "BN" },
	{ (long)ns1__CountryAbbr2ISO3166__BG, "BG" },
	{ (long)ns1__CountryAbbr2ISO3166__BF, "BF" },
	{ (long)ns1__CountryAbbr2ISO3166__BI, "BI" },
	{ (long)ns1__CountryAbbr2ISO3166__KH, "KH" },
	{ (long)ns1__CountryAbbr2ISO3166__CM, "CM" },
	{ (long)ns1__CountryAbbr2ISO3166__CA, "CA" },
	{ (long)ns1__CountryAbbr2ISO3166__CV, "CV" },
	{ (long)ns1__CountryAbbr2ISO3166__KY, "KY" },
	{ (long)ns1__CountryAbbr2ISO3166__CF, "CF" },
	{ (long)ns1__CountryAbbr2ISO3166__TD, "TD" },
	{ (long)ns1__CountryAbbr2ISO3166__CL, "CL" },
	{ (long)ns1__CountryAbbr2ISO3166__CN, "CN" },
	{ (long)ns1__CountryAbbr2ISO3166__CX, "CX" },
	{ (long)ns1__CountryAbbr2ISO3166__CO, "CO" },
	{ (long)ns1__CountryAbbr2ISO3166__CK, "CK" },
	{ (long)ns1__CountryAbbr2ISO3166__CR, "CR" },
	{ (long)ns1__CountryAbbr2ISO3166__HR, "HR" },
	{ (long)ns1__CountryAbbr2ISO3166__CU, "CU" },
	{ (long)ns1__CountryAbbr2ISO3166__CY, "CY" },
	{ (long)ns1__CountryAbbr2ISO3166__CZ, "CZ" },
	{ (long)ns1__CountryAbbr2ISO3166__CI, "CI" },
	{ (long)ns1__CountryAbbr2ISO3166__CD, "CD" },
	{ (long)ns1__CountryAbbr2ISO3166__DK, "DK" },
	{ (long)ns1__CountryAbbr2ISO3166__DJ, "DJ" },
	{ (long)ns1__CountryAbbr2ISO3166__DM, "DM" },
	{ (long)ns1__CountryAbbr2ISO3166__DO, "DO" },
	{ (long)ns1__CountryAbbr2ISO3166__EC, "EC" },
	{ (long)ns1__CountryAbbr2ISO3166__EG, "EG" },
	{ (long)ns1__CountryAbbr2ISO3166__SV, "SV" },
	{ (long)ns1__CountryAbbr2ISO3166__GQ, "GQ" },
	{ (long)ns1__CountryAbbr2ISO3166__ER, "ER" },
	{ (long)ns1__CountryAbbr2ISO3166__EE, "EE" },
	{ (long)ns1__CountryAbbr2ISO3166__ET, "ET" },
	{ (long)ns1__CountryAbbr2ISO3166__FK, "FK" },
	{ (long)ns1__CountryAbbr2ISO3166__FO, "FO" },
	{ (long)ns1__CountryAbbr2ISO3166__FM, "FM" },
	{ (long)ns1__CountryAbbr2ISO3166__FJ, "FJ" },
	{ (long)ns1__CountryAbbr2ISO3166__FI, "FI" },
	{ (long)ns1__CountryAbbr2ISO3166__FR, "FR" },
	{ (long)ns1__CountryAbbr2ISO3166__GF, "GF" },
	{ (long)ns1__CountryAbbr2ISO3166__PF, "PF" },
	{ (long)ns1__CountryAbbr2ISO3166__GA, "GA" },
	{ (long)ns1__CountryAbbr2ISO3166__GM, "GM" },
	{ (long)ns1__CountryAbbr2ISO3166__GE, "GE" },
	{ (long)ns1__CountryAbbr2ISO3166__DE, "DE" },
	{ (long)ns1__CountryAbbr2ISO3166__GH, "GH" },
	{ (long)ns1__CountryAbbr2ISO3166__GI, "GI" },
	{ (long)ns1__CountryAbbr2ISO3166__GB, "GB" },
	{ (long)ns1__CountryAbbr2ISO3166__GR, "GR" },
	{ (long)ns1__CountryAbbr2ISO3166__GL, "GL" },
	{ (long)ns1__CountryAbbr2ISO3166__GD, "GD" },
	{ (long)ns1__CountryAbbr2ISO3166__GP, "GP" },
	{ (long)ns1__CountryAbbr2ISO3166__GU, "GU" },
	{ (long)ns1__CountryAbbr2ISO3166__GT, "GT" },
	{ (long)ns1__CountryAbbr2ISO3166__GN, "GN" },
	{ (long)ns1__CountryAbbr2ISO3166__GW, "GW" },
	{ (long)ns1__CountryAbbr2ISO3166__GY, "GY" },
	{ (long)ns1__CountryAbbr2ISO3166__HT, "HT" },
	{ (long)ns1__CountryAbbr2ISO3166__HN, "HN" },
	{ (long)ns1__CountryAbbr2ISO3166__HK, "HK" },
	{ (long)ns1__CountryAbbr2ISO3166__HU, "HU" },
	{ (long)ns1__CountryAbbr2ISO3166__ID, "ID" },
	{ (long)ns1__CountryAbbr2ISO3166__IE, "IE" },
	{ (long)ns1__CountryAbbr2ISO3166__IL, "IL" },
	{ (long)ns1__CountryAbbr2ISO3166__IN, "IN" },
	{ (long)ns1__CountryAbbr2ISO3166__IQ, "IQ" },
	{ (long)ns1__CountryAbbr2ISO3166__IR, "IR" },
	{ (long)ns1__CountryAbbr2ISO3166__IS, "IS" },
	{ (long)ns1__CountryAbbr2ISO3166__IT, "IT" },
	{ (long)ns1__CountryAbbr2ISO3166__JM, "JM" },
	{ (long)ns1__CountryAbbr2ISO3166__JO, "JO" },
	{ (long)ns1__CountryAbbr2ISO3166__JP, "JP" },
	{ (long)ns1__CountryAbbr2ISO3166__KE, "KE" },
	{ (long)ns1__CountryAbbr2ISO3166__KG, "KG" },
	{ (long)ns1__CountryAbbr2ISO3166__KI, "KI" },
	{ (long)ns1__CountryAbbr2ISO3166__KM, "KM" },
	{ (long)ns1__CountryAbbr2ISO3166__KN, "KN" },
	{ (long)ns1__CountryAbbr2ISO3166__KP, "KP" },
	{ (long)ns1__CountryAbbr2ISO3166__KR, "KR" },
	{ (long)ns1__CountryAbbr2ISO3166__KW, "KW" },
	{ (long)ns1__CountryAbbr2ISO3166__KZ, "KZ" },
	{ (long)ns1__CountryAbbr2ISO3166__LA, "LA" },
	{ (long)ns1__CountryAbbr2ISO3166__LB, "LB" },
	{ (long)ns1__CountryAbbr2ISO3166__LC, "LC" },
	{ (long)ns1__CountryAbbr2ISO3166__LI, "LI" },
	{ (long)ns1__CountryAbbr2ISO3166__LK, "LK" },
	{ (long)ns1__CountryAbbr2ISO3166__LR, "LR" },
	{ (long)ns1__CountryAbbr2ISO3166__LS, "LS" },
	{ (long)ns1__CountryAbbr2ISO3166__LT, "LT" },
	{ (long)ns1__CountryAbbr2ISO3166__LU, "LU" },
	{ (long)ns1__CountryAbbr2ISO3166__LV, "LV" },
	{ (long)ns1__CountryAbbr2ISO3166__LY, "LY" },
	{ (long)ns1__CountryAbbr2ISO3166__MA, "MA" },
	{ (long)ns1__CountryAbbr2ISO3166__MC, "MC" },
	{ (long)ns1__CountryAbbr2ISO3166__MD, "MD" },
	{ (long)ns1__CountryAbbr2ISO3166__ME, "ME" },
	{ (long)ns1__CountryAbbr2ISO3166__MG, "MG" },
	{ (long)ns1__CountryAbbr2ISO3166__MH, "MH" },
	{ (long)ns1__CountryAbbr2ISO3166__MK, "MK" },
	{ (long)ns1__CountryAbbr2ISO3166__ML, "ML" },
	{ (long)ns1__CountryAbbr2ISO3166__MM, "MM" },
	{ (long)ns1__CountryAbbr2ISO3166__MN, "MN" },
	{ (long)ns1__CountryAbbr2ISO3166__MO, "MO" },
	{ (long)ns1__CountryAbbr2ISO3166__MP, "MP" },
	{ (long)ns1__CountryAbbr2ISO3166__MQ, "MQ" },
	{ (long)ns1__CountryAbbr2ISO3166__MR, "MR" },
	{ (long)ns1__CountryAbbr2ISO3166__MT, "MT" },
	{ (long)ns1__CountryAbbr2ISO3166__MU, "MU" },
	{ (long)ns1__CountryAbbr2ISO3166__MV, "MV" },
	{ (long)ns1__CountryAbbr2ISO3166__MW, "MW" },
	{ (long)ns1__CountryAbbr2ISO3166__MX, "MX" },
	{ (long)ns1__CountryAbbr2ISO3166__MY, "MY" },
	{ (long)ns1__CountryAbbr2ISO3166__MZ, "MZ" },
	{ (long)ns1__CountryAbbr2ISO3166__NA, "NA" },
	{ (long)ns1__CountryAbbr2ISO3166__NC, "NC" },
	{ (long)ns1__CountryAbbr2ISO3166__NE, "NE" },
	{ (long)ns1__CountryAbbr2ISO3166__NG, "NG" },
	{ (long)ns1__CountryAbbr2ISO3166__NI, "NI" },
	{ (long)ns1__CountryAbbr2ISO3166__NL, "NL" },
	{ (long)ns1__CountryAbbr2ISO3166__NO, "NO" },
	{ (long)ns1__CountryAbbr2ISO3166__NP, "NP" },
	{ (long)ns1__CountryAbbr2ISO3166__NR, "NR" },
	{ (long)ns1__CountryAbbr2ISO3166__NU, "NU" },
	{ (long)ns1__CountryAbbr2ISO3166__NZ, "NZ" },
	{ (long)ns1__CountryAbbr2ISO3166__OM, "OM" },
	{ (long)ns1__CountryAbbr2ISO3166__PA, "PA" },
	{ (long)ns1__CountryAbbr2ISO3166__PE, "PE" },
	{ (long)ns1__CountryAbbr2ISO3166__PG, "PG" },
	{ (long)ns1__CountryAbbr2ISO3166__PH, "PH" },
	{ (long)ns1__CountryAbbr2ISO3166__PK, "PK" },
	{ (long)ns1__CountryAbbr2ISO3166__PL, "PL" },
	{ (long)ns1__CountryAbbr2ISO3166__PM, "PM" },
	{ (long)ns1__CountryAbbr2ISO3166__PR, "PR" },
	{ (long)ns1__CountryAbbr2ISO3166__PS, "PS" },
	{ (long)ns1__CountryAbbr2ISO3166__PT, "PT" },
	{ (long)ns1__CountryAbbr2ISO3166__PW, "PW" },
	{ (long)ns1__CountryAbbr2ISO3166__PY, "PY" },
	{ (long)ns1__CountryAbbr2ISO3166__QA, "QA" },
	{ (long)ns1__CountryAbbr2ISO3166__RE, "RE" },
	{ (long)ns1__CountryAbbr2ISO3166__RO, "RO" },
	{ (long)ns1__CountryAbbr2ISO3166__RS, "RS" },
	{ (long)ns1__CountryAbbr2ISO3166__RU, "RU" },
	{ (long)ns1__CountryAbbr2ISO3166__RW, "RW" },
	{ (long)ns1__CountryAbbr2ISO3166__SA, "SA" },
	{ (long)ns1__CountryAbbr2ISO3166__SB, "SB" },
	{ (long)ns1__CountryAbbr2ISO3166__SC, "SC" },
	{ (long)ns1__CountryAbbr2ISO3166__SD, "SD" },
	{ (long)ns1__CountryAbbr2ISO3166__SE, "SE" },
	{ (long)ns1__CountryAbbr2ISO3166__SG, "SG" },
	{ (long)ns1__CountryAbbr2ISO3166__SH, "SH" },
	{ (long)ns1__CountryAbbr2ISO3166__SI, "SI" },
	{ (long)ns1__CountryAbbr2ISO3166__SK, "SK" },
	{ (long)ns1__CountryAbbr2ISO3166__SL, "SL" },
	{ (long)ns1__CountryAbbr2ISO3166__SM, "SM" },
	{ (long)ns1__CountryAbbr2ISO3166__SN, "SN" },
	{ (long)ns1__CountryAbbr2ISO3166__SO, "SO" },
	{ (long)ns1__CountryAbbr2ISO3166__SR, "SR" },
	{ (long)ns1__CountryAbbr2ISO3166__SS, "SS" },
	{ (long)ns1__CountryAbbr2ISO3166__ST, "ST" },
	{ (long)ns1__CountryAbbr2ISO3166__SY, "SY" },
	{ (long)ns1__CountryAbbr2ISO3166__SZ, "SZ" },
	{ (long)ns1__CountryAbbr2ISO3166__TC, "TC" },
	{ (long)ns1__CountryAbbr2ISO3166__TG, "TG" },
	{ (long)ns1__CountryAbbr2ISO3166__TH, "TH" },
	{ (long)ns1__CountryAbbr2ISO3166__TJ, "TJ" },
	{ (long)ns1__CountryAbbr2ISO3166__TK, "TK" },
	{ (long)ns1__CountryAbbr2ISO3166__TL, "TL" },
	{ (long)ns1__CountryAbbr2ISO3166__TM, "TM" },
	{ (long)ns1__CountryAbbr2ISO3166__TN, "TN" },
	{ (long)ns1__CountryAbbr2ISO3166__TO, "TO" },
	{ (long)ns1__CountryAbbr2ISO3166__TR, "TR" },
	{ (long)ns1__CountryAbbr2ISO3166__TT, "TT" },
	{ (long)ns1__CountryAbbr2ISO3166__TV, "TV" },
	{ (long)ns1__CountryAbbr2ISO3166__TW, "TW" },
	{ (long)ns1__CountryAbbr2ISO3166__TZ, "TZ" },
	{ (long)ns1__CountryAbbr2ISO3166__UA, "UA" },
	{ (long)ns1__CountryAbbr2ISO3166__UG, "UG" },
	{ (long)ns1__CountryAbbr2ISO3166__US, "US" },
	{ (long)ns1__CountryAbbr2ISO3166__UY, "UY" },
	{ (long)ns1__CountryAbbr2ISO3166__UZ, "UZ" },
	{ (long)ns1__CountryAbbr2ISO3166__VE, "VE" },
	{ (long)ns1__CountryAbbr2ISO3166__VN, "VN" },
	{ (long)ns1__CountryAbbr2ISO3166__VU, "VU" },
	{ (long)ns1__CountryAbbr2ISO3166__WF, "WF" },
	{ (long)ns1__CountryAbbr2ISO3166__WS, "WS" },
	{ (long)ns1__CountryAbbr2ISO3166__YE, "YE" },
	{ (long)ns1__CountryAbbr2ISO3166__YT, "YT" },
	{ (long)ns1__CountryAbbr2ISO3166__ZA, "ZA" },
	{ (long)ns1__CountryAbbr2ISO3166__ZM, "ZM" },
	{ (long)ns1__CountryAbbr2ISO3166__ZW, "ZW" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__CountryAbbr2ISO31662s(struct soap *soap, enum ns1__CountryAbbr2ISO3166 n)
{	const char *s = soap_code_str(soap_codes_ns1__CountryAbbr2ISO3166, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, int id, const enum ns1__CountryAbbr2ISO3166 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CountryAbbr2ISO3166), type) || soap_send(soap, soap_ns1__CountryAbbr2ISO31662s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__CountryAbbr2ISO3166(struct soap *soap, const char *s, enum ns1__CountryAbbr2ISO3166 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__CountryAbbr2ISO3166, s);
	if (map)
		*a = (enum ns1__CountryAbbr2ISO3166)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 217)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__CountryAbbr2ISO3166)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 * SOAP_FMAC4 soap_in_ns1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, enum ns1__CountryAbbr2ISO3166 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__CountryAbbr2ISO3166 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CountryAbbr2ISO3166, sizeof(enum ns1__CountryAbbr2ISO3166), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__CountryAbbr2ISO3166(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__CountryAbbr2ISO3166 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CountryAbbr2ISO3166, 0, sizeof(enum ns1__CountryAbbr2ISO3166), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CountryAbbr2ISO3166(struct soap *soap, const enum ns1__CountryAbbr2ISO3166 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CountryAbbr2ISO3166);
	if (soap_out_ns1__CountryAbbr2ISO3166(soap, tag?tag:"ns1:CountryAbbr2ISO3166", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 * SOAP_FMAC4 soap_get_ns1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryAbbr2ISO3166(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__vodSearch(struct soap *soap, struct __ns1__vodSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__vodSearchReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__vodSearch(struct soap *soap, const struct __ns1__vodSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__vodSearchReq(soap, &a->ns1__vodSearchReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__vodSearch(struct soap *soap, const char *tag, int id, const struct __ns1__vodSearch *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__vodSearchReq(soap, "ns1:vodSearchReq", -1, &a->ns1__vodSearchReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vodSearch * SOAP_FMAC4 soap_in___ns1__vodSearch(struct soap *soap, const char *tag, struct __ns1__vodSearch *a, const char *type)
{
	size_t soap_flag_ns1__vodSearchReq = 1;
	short soap_flag;
	a = (struct __ns1__vodSearch *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__vodSearch, sizeof(struct __ns1__vodSearch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__vodSearch(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__vodSearchReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__vodSearchReq(soap, "ns1:vodSearchReq", &a->ns1__vodSearchReq, ""))
				{	soap_flag_ns1__vodSearchReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__vodSearch(struct soap *soap, const struct __ns1__vodSearch *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__vodSearch(soap, tag?tag:"-ns1:vodSearch", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__vodSearch * SOAP_FMAC4 soap_get___ns1__vodSearch(struct soap *soap, struct __ns1__vodSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__vodSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVODUrl(struct soap *soap, struct __ns1__getVODUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVODUrlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVODUrl(struct soap *soap, const struct __ns1__getVODUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVODUrlReq(soap, &a->ns1__getVODUrlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVODUrl(struct soap *soap, const char *tag, int id, const struct __ns1__getVODUrl *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVODUrlReq(soap, "ns1:getVODUrlReq", -1, &a->ns1__getVODUrlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVODUrl * SOAP_FMAC4 soap_in___ns1__getVODUrl(struct soap *soap, const char *tag, struct __ns1__getVODUrl *a, const char *type)
{
	size_t soap_flag_ns1__getVODUrlReq = 1;
	short soap_flag;
	a = (struct __ns1__getVODUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVODUrl, sizeof(struct __ns1__getVODUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVODUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVODUrlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVODUrlReq(soap, "ns1:getVODUrlReq", &a->ns1__getVODUrlReq, ""))
				{	soap_flag_ns1__getVODUrlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVODUrl(struct soap *soap, const struct __ns1__getVODUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVODUrl(soap, tag?tag:"-ns1:getVODUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVODUrl * SOAP_FMAC4 soap_get___ns1__getVODUrl(struct soap *soap, struct __ns1__getVODUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVODUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPlayUrl(struct soap *soap, struct __ns1__getPlayUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPlayUrlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPlayUrl(struct soap *soap, const struct __ns1__getPlayUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPlayUrlReq(soap, &a->ns1__getPlayUrlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPlayUrl(struct soap *soap, const char *tag, int id, const struct __ns1__getPlayUrl *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPlayUrlReq(soap, "ns1:getPlayUrlReq", -1, &a->ns1__getPlayUrlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPlayUrl * SOAP_FMAC4 soap_in___ns1__getPlayUrl(struct soap *soap, const char *tag, struct __ns1__getPlayUrl *a, const char *type)
{
	size_t soap_flag_ns1__getPlayUrlReq = 1;
	short soap_flag;
	a = (struct __ns1__getPlayUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPlayUrl, sizeof(struct __ns1__getPlayUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPlayUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPlayUrlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPlayUrlReq(soap, "ns1:getPlayUrlReq", &a->ns1__getPlayUrlReq, ""))
				{	soap_flag_ns1__getPlayUrlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPlayUrl(struct soap *soap, const struct __ns1__getPlayUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPlayUrl(soap, tag?tag:"-ns1:getPlayUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPlayUrl * SOAP_FMAC4 soap_get___ns1__getPlayUrl(struct soap *soap, struct __ns1__getPlayUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPlayUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPrivacyMaskParam(struct soap *soap, struct __ns1__setPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setPrivacyMaskParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPrivacyMaskParam(struct soap *soap, const struct __ns1__setPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq(soap, &a->ns1__setPrivacyMaskParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPrivacyMaskParam(struct soap *soap, const char *tag, int id, const struct __ns1__setPrivacyMaskParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamReq(soap, "ns1:setPrivacyMaskParamReq", -1, &a->ns1__setPrivacyMaskParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPrivacyMaskParam * SOAP_FMAC4 soap_in___ns1__setPrivacyMaskParam(struct soap *soap, const char *tag, struct __ns1__setPrivacyMaskParam *a, const char *type)
{
	size_t soap_flag_ns1__setPrivacyMaskParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setPrivacyMaskParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPrivacyMaskParam, sizeof(struct __ns1__setPrivacyMaskParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPrivacyMaskParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setPrivacyMaskParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setPrivacyMaskParamReq(soap, "ns1:setPrivacyMaskParamReq", &a->ns1__setPrivacyMaskParamReq, ""))
				{	soap_flag_ns1__setPrivacyMaskParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPrivacyMaskParam(struct soap *soap, const struct __ns1__setPrivacyMaskParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPrivacyMaskParam(soap, tag?tag:"-ns1:setPrivacyMaskParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPrivacyMaskParam * SOAP_FMAC4 soap_get___ns1__setPrivacyMaskParam(struct soap *soap, struct __ns1__setPrivacyMaskParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPrivacyMaskParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPrivacyMaskParam(struct soap *soap, struct __ns1__getPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPrivacyMaskParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPrivacyMaskParam(struct soap *soap, const struct __ns1__getPrivacyMaskParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq(soap, &a->ns1__getPrivacyMaskParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPrivacyMaskParam(struct soap *soap, const char *tag, int id, const struct __ns1__getPrivacyMaskParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamReq(soap, "ns1:getPrivacyMaskParamReq", -1, &a->ns1__getPrivacyMaskParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPrivacyMaskParam * SOAP_FMAC4 soap_in___ns1__getPrivacyMaskParam(struct soap *soap, const char *tag, struct __ns1__getPrivacyMaskParam *a, const char *type)
{
	size_t soap_flag_ns1__getPrivacyMaskParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getPrivacyMaskParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPrivacyMaskParam, sizeof(struct __ns1__getPrivacyMaskParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPrivacyMaskParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPrivacyMaskParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getPrivacyMaskParamReq(soap, "ns1:getPrivacyMaskParamReq", &a->ns1__getPrivacyMaskParamReq, ""))
				{	soap_flag_ns1__getPrivacyMaskParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPrivacyMaskParam(struct soap *soap, const struct __ns1__getPrivacyMaskParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPrivacyMaskParam(soap, tag?tag:"-ns1:getPrivacyMaskParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPrivacyMaskParam * SOAP_FMAC4 soap_get___ns1__getPrivacyMaskParam(struct soap *soap, struct __ns1__getPrivacyMaskParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPrivacyMaskParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setVMDParam(struct soap *soap, struct __ns1__setVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setVMDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setVMDParam(struct soap *soap, const struct __ns1__setVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setVMDParamReq(soap, &a->ns1__setVMDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setVMDParam(struct soap *soap, const char *tag, int id, const struct __ns1__setVMDParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setVMDParamReq(soap, "ns1:setVMDParamReq", -1, &a->ns1__setVMDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVMDParam * SOAP_FMAC4 soap_in___ns1__setVMDParam(struct soap *soap, const char *tag, struct __ns1__setVMDParam *a, const char *type)
{
	size_t soap_flag_ns1__setVMDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setVMDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setVMDParam, sizeof(struct __ns1__setVMDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setVMDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setVMDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setVMDParamReq(soap, "ns1:setVMDParamReq", &a->ns1__setVMDParamReq, ""))
				{	soap_flag_ns1__setVMDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setVMDParam(struct soap *soap, const struct __ns1__setVMDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setVMDParam(soap, tag?tag:"-ns1:setVMDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVMDParam * SOAP_FMAC4 soap_get___ns1__setVMDParam(struct soap *soap, struct __ns1__setVMDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setVMDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVMDParam(struct soap *soap, struct __ns1__getVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVMDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVMDParam(struct soap *soap, const struct __ns1__getVMDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVMDParamReq(soap, &a->ns1__getVMDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVMDParam(struct soap *soap, const char *tag, int id, const struct __ns1__getVMDParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVMDParamReq(soap, "ns1:getVMDParamReq", -1, &a->ns1__getVMDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVMDParam * SOAP_FMAC4 soap_in___ns1__getVMDParam(struct soap *soap, const char *tag, struct __ns1__getVMDParam *a, const char *type)
{
	size_t soap_flag_ns1__getVMDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getVMDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVMDParam, sizeof(struct __ns1__getVMDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVMDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVMDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVMDParamReq(soap, "ns1:getVMDParamReq", &a->ns1__getVMDParamReq, ""))
				{	soap_flag_ns1__getVMDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVMDParam(struct soap *soap, const struct __ns1__getVMDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVMDParam(soap, tag?tag:"-ns1:getVMDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVMDParam * SOAP_FMAC4 soap_get___ns1__getVMDParam(struct soap *soap, struct __ns1__getVMDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVMDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setTime(struct soap *soap, struct __ns1__setTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setTimeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setTime(struct soap *soap, const struct __ns1__setTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setTimeReq(soap, &a->ns1__setTimeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setTime(struct soap *soap, const char *tag, int id, const struct __ns1__setTime *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setTimeReq(soap, "ns1:setTimeReq", -1, &a->ns1__setTimeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTime * SOAP_FMAC4 soap_in___ns1__setTime(struct soap *soap, const char *tag, struct __ns1__setTime *a, const char *type)
{
	size_t soap_flag_ns1__setTimeReq = 1;
	short soap_flag;
	a = (struct __ns1__setTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setTime, sizeof(struct __ns1__setTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setTimeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setTimeReq(soap, "ns1:setTimeReq", &a->ns1__setTimeReq, ""))
				{	soap_flag_ns1__setTimeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setTime(struct soap *soap, const struct __ns1__setTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setTime(soap, tag?tag:"-ns1:setTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setTime * SOAP_FMAC4 soap_get___ns1__setTime(struct soap *soap, struct __ns1__setTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTime(struct soap *soap, struct __ns1__getTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTimeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTime(struct soap *soap, const struct __ns1__getTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getTimeReq(soap, &a->ns1__getTimeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTime(struct soap *soap, const char *tag, int id, const struct __ns1__getTime *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getTimeReq(soap, "ns1:getTimeReq", -1, &a->ns1__getTimeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTime * SOAP_FMAC4 soap_in___ns1__getTime(struct soap *soap, const char *tag, struct __ns1__getTime *a, const char *type)
{
	size_t soap_flag_ns1__getTimeReq = 1;
	short soap_flag;
	a = (struct __ns1__getTime *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTime, sizeof(struct __ns1__getTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTimeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getTimeReq(soap, "ns1:getTimeReq", &a->ns1__getTimeReq, ""))
				{	soap_flag_ns1__getTimeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTime(struct soap *soap, const struct __ns1__getTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTime(soap, tag?tag:"-ns1:getTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTime * SOAP_FMAC4 soap_get___ns1__getTime(struct soap *soap, struct __ns1__getTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setOSDParam(struct soap *soap, struct __ns1__setOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setOSDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setOSDParam(struct soap *soap, const struct __ns1__setOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setOSDParamReq(soap, &a->ns1__setOSDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setOSDParam(struct soap *soap, const char *tag, int id, const struct __ns1__setOSDParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setOSDParamReq(soap, "ns1:setOSDParamReq", -1, &a->ns1__setOSDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setOSDParam * SOAP_FMAC4 soap_in___ns1__setOSDParam(struct soap *soap, const char *tag, struct __ns1__setOSDParam *a, const char *type)
{
	size_t soap_flag_ns1__setOSDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setOSDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setOSDParam, sizeof(struct __ns1__setOSDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setOSDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setOSDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setOSDParamReq(soap, "ns1:setOSDParamReq", &a->ns1__setOSDParamReq, ""))
				{	soap_flag_ns1__setOSDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setOSDParam(struct soap *soap, const struct __ns1__setOSDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setOSDParam(soap, tag?tag:"-ns1:setOSDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setOSDParam * SOAP_FMAC4 soap_get___ns1__setOSDParam(struct soap *soap, struct __ns1__setOSDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setOSDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOSDParam(struct soap *soap, struct __ns1__getOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getOSDParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOSDParam(struct soap *soap, const struct __ns1__getOSDParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getOSDParamReq(soap, &a->ns1__getOSDParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOSDParam(struct soap *soap, const char *tag, int id, const struct __ns1__getOSDParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getOSDParamReq(soap, "ns1:getOSDParamReq", -1, &a->ns1__getOSDParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOSDParam * SOAP_FMAC4 soap_in___ns1__getOSDParam(struct soap *soap, const char *tag, struct __ns1__getOSDParam *a, const char *type)
{
	size_t soap_flag_ns1__getOSDParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getOSDParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOSDParam, sizeof(struct __ns1__getOSDParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOSDParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getOSDParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getOSDParamReq(soap, "ns1:getOSDParamReq", &a->ns1__getOSDParamReq, ""))
				{	soap_flag_ns1__getOSDParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOSDParam(struct soap *soap, const struct __ns1__getOSDParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getOSDParam(soap, tag?tag:"-ns1:getOSDParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOSDParam * SOAP_FMAC4 soap_get___ns1__getOSDParam(struct soap *soap, struct __ns1__getOSDParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOSDParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setVideoParam(struct soap *soap, struct __ns1__setVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setVideoParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setVideoParam(struct soap *soap, const struct __ns1__setVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setVideoParamReq(soap, &a->ns1__setVideoParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setVideoParam(struct soap *soap, const char *tag, int id, const struct __ns1__setVideoParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setVideoParamReq(soap, "ns1:setVideoParamReq", -1, &a->ns1__setVideoParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVideoParam * SOAP_FMAC4 soap_in___ns1__setVideoParam(struct soap *soap, const char *tag, struct __ns1__setVideoParam *a, const char *type)
{
	size_t soap_flag_ns1__setVideoParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setVideoParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setVideoParam, sizeof(struct __ns1__setVideoParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setVideoParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setVideoParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setVideoParamReq(soap, "ns1:setVideoParamReq", &a->ns1__setVideoParamReq, ""))
				{	soap_flag_ns1__setVideoParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setVideoParam(struct soap *soap, const struct __ns1__setVideoParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setVideoParam(soap, tag?tag:"-ns1:setVideoParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setVideoParam * SOAP_FMAC4 soap_get___ns1__setVideoParam(struct soap *soap, struct __ns1__setVideoParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setVideoParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVideoParam(struct soap *soap, struct __ns1__getVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVideoParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVideoParam(struct soap *soap, const struct __ns1__getVideoParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getVideoParamReq(soap, &a->ns1__getVideoParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVideoParam(struct soap *soap, const char *tag, int id, const struct __ns1__getVideoParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getVideoParamReq(soap, "ns1:getVideoParamReq", -1, &a->ns1__getVideoParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVideoParam * SOAP_FMAC4 soap_in___ns1__getVideoParam(struct soap *soap, const char *tag, struct __ns1__getVideoParam *a, const char *type)
{
	size_t soap_flag_ns1__getVideoParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getVideoParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVideoParam, sizeof(struct __ns1__getVideoParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVideoParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVideoParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getVideoParamReq(soap, "ns1:getVideoParamReq", &a->ns1__getVideoParamReq, ""))
				{	soap_flag_ns1__getVideoParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVideoParam(struct soap *soap, const struct __ns1__getVideoParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVideoParam(soap, tag?tag:"-ns1:getVideoParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVideoParam * SOAP_FMAC4 soap_get___ns1__getVideoParam(struct soap *soap, struct __ns1__getVideoParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVideoParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDevLog(struct soap *soap, struct __ns1__queryDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDevLogReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDevLog(struct soap *soap, const struct __ns1__queryDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDevLogReq(soap, &a->ns1__queryDevLogReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDevLog(struct soap *soap, const char *tag, int id, const struct __ns1__queryDevLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDevLogReq(soap, "ns1:queryDevLogReq", -1, &a->ns1__queryDevLogReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevLog * SOAP_FMAC4 soap_in___ns1__queryDevLog(struct soap *soap, const char *tag, struct __ns1__queryDevLog *a, const char *type)
{
	size_t soap_flag_ns1__queryDevLogReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDevLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDevLog, sizeof(struct __ns1__queryDevLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDevLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDevLogReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDevLogReq(soap, "ns1:queryDevLogReq", &a->ns1__queryDevLogReq, ""))
				{	soap_flag_ns1__queryDevLogReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDevLog(struct soap *soap, const struct __ns1__queryDevLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDevLog(soap, tag?tag:"-ns1:queryDevLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevLog * SOAP_FMAC4 soap_get___ns1__queryDevLog(struct soap *soap, struct __ns1__queryDevLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryLog(struct soap *soap, struct __ns1__queryLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryLogReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryLog(struct soap *soap, const struct __ns1__queryLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryLogReq(soap, &a->ns1__queryLogReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryLog(struct soap *soap, const char *tag, int id, const struct __ns1__queryLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryLogReq(soap, "ns1:queryLogReq", -1, &a->ns1__queryLogReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryLog * SOAP_FMAC4 soap_in___ns1__queryLog(struct soap *soap, const char *tag, struct __ns1__queryLog *a, const char *type)
{
	size_t soap_flag_ns1__queryLogReq = 1;
	short soap_flag;
	a = (struct __ns1__queryLog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryLog, sizeof(struct __ns1__queryLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryLogReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryLogReq(soap, "ns1:queryLogReq", &a->ns1__queryLogReq, ""))
				{	soap_flag_ns1__queryLogReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryLog(struct soap *soap, const struct __ns1__queryLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryLog(soap, tag?tag:"-ns1:queryLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryLog * SOAP_FMAC4 soap_get___ns1__queryLog(struct soap *soap, struct __ns1__queryLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__upgradeDevVer(struct soap *soap, struct __ns1__upgradeDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__upgradeDevVerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__upgradeDevVer(struct soap *soap, const struct __ns1__upgradeDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__upgradeDevVerReq(soap, &a->ns1__upgradeDevVerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__upgradeDevVer(struct soap *soap, const char *tag, int id, const struct __ns1__upgradeDevVer *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__upgradeDevVerReq(soap, "ns1:upgradeDevVerReq", -1, &a->ns1__upgradeDevVerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upgradeDevVer * SOAP_FMAC4 soap_in___ns1__upgradeDevVer(struct soap *soap, const char *tag, struct __ns1__upgradeDevVer *a, const char *type)
{
	size_t soap_flag_ns1__upgradeDevVerReq = 1;
	short soap_flag;
	a = (struct __ns1__upgradeDevVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__upgradeDevVer, sizeof(struct __ns1__upgradeDevVer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__upgradeDevVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__upgradeDevVerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__upgradeDevVerReq(soap, "ns1:upgradeDevVerReq", &a->ns1__upgradeDevVerReq, ""))
				{	soap_flag_ns1__upgradeDevVerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__upgradeDevVer(struct soap *soap, const struct __ns1__upgradeDevVer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__upgradeDevVer(soap, tag?tag:"-ns1:upgradeDevVer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__upgradeDevVer * SOAP_FMAC4 soap_get___ns1__upgradeDevVer(struct soap *soap, struct __ns1__upgradeDevVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__upgradeDevVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDevVer(struct soap *soap, struct __ns1__getDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDevVerReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDevVer(struct soap *soap, const struct __ns1__getDevVer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getDevVerReq(soap, &a->ns1__getDevVerReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDevVer(struct soap *soap, const char *tag, int id, const struct __ns1__getDevVer *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getDevVerReq(soap, "ns1:getDevVerReq", -1, &a->ns1__getDevVerReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDevVer * SOAP_FMAC4 soap_in___ns1__getDevVer(struct soap *soap, const char *tag, struct __ns1__getDevVer *a, const char *type)
{
	size_t soap_flag_ns1__getDevVerReq = 1;
	short soap_flag;
	a = (struct __ns1__getDevVer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDevVer, sizeof(struct __ns1__getDevVer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDevVer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDevVerReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getDevVerReq(soap, "ns1:getDevVerReq", &a->ns1__getDevVerReq, ""))
				{	soap_flag_ns1__getDevVerReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDevVer(struct soap *soap, const struct __ns1__getDevVer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDevVer(soap, tag?tag:"-ns1:getDevVer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDevVer * SOAP_FMAC4 soap_get___ns1__getDevVer(struct soap *soap, struct __ns1__getDevVer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDevVer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reboot(struct soap *soap, struct __ns1__reboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__rebootReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reboot(struct soap *soap, const struct __ns1__reboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__rebootReq(soap, &a->ns1__rebootReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reboot(struct soap *soap, const char *tag, int id, const struct __ns1__reboot *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__rebootReq(soap, "ns1:rebootReq", -1, &a->ns1__rebootReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reboot * SOAP_FMAC4 soap_in___ns1__reboot(struct soap *soap, const char *tag, struct __ns1__reboot *a, const char *type)
{
	size_t soap_flag_ns1__rebootReq = 1;
	short soap_flag;
	a = (struct __ns1__reboot *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reboot, sizeof(struct __ns1__reboot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__reboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__rebootReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__rebootReq(soap, "ns1:rebootReq", &a->ns1__rebootReq, ""))
				{	soap_flag_ns1__rebootReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reboot(struct soap *soap, const struct __ns1__reboot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__reboot(soap, tag?tag:"-ns1:reboot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reboot * SOAP_FMAC4 soap_get___ns1__reboot(struct soap *soap, struct __ns1__reboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__reboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setCodingParam(struct soap *soap, struct __ns1__setCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setCodingParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setCodingParam(struct soap *soap, const struct __ns1__setCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setCodingParamReq(soap, &a->ns1__setCodingParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setCodingParam(struct soap *soap, const char *tag, int id, const struct __ns1__setCodingParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setCodingParamReq(soap, "ns1:setCodingParamReq", -1, &a->ns1__setCodingParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCodingParam * SOAP_FMAC4 soap_in___ns1__setCodingParam(struct soap *soap, const char *tag, struct __ns1__setCodingParam *a, const char *type)
{
	size_t soap_flag_ns1__setCodingParamReq = 1;
	short soap_flag;
	a = (struct __ns1__setCodingParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setCodingParam, sizeof(struct __ns1__setCodingParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setCodingParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setCodingParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setCodingParamReq(soap, "ns1:setCodingParamReq", &a->ns1__setCodingParamReq, ""))
				{	soap_flag_ns1__setCodingParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setCodingParam(struct soap *soap, const struct __ns1__setCodingParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setCodingParam(soap, tag?tag:"-ns1:setCodingParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCodingParam * SOAP_FMAC4 soap_get___ns1__setCodingParam(struct soap *soap, struct __ns1__setCodingParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setCodingParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCodingParam(struct soap *soap, struct __ns1__getCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCodingParamReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCodingParam(struct soap *soap, const struct __ns1__getCodingParam *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getCodingParamReq(soap, &a->ns1__getCodingParamReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCodingParam(struct soap *soap, const char *tag, int id, const struct __ns1__getCodingParam *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getCodingParamReq(soap, "ns1:getCodingParamReq", -1, &a->ns1__getCodingParamReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCodingParam * SOAP_FMAC4 soap_in___ns1__getCodingParam(struct soap *soap, const char *tag, struct __ns1__getCodingParam *a, const char *type)
{
	size_t soap_flag_ns1__getCodingParamReq = 1;
	short soap_flag;
	a = (struct __ns1__getCodingParam *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCodingParam, sizeof(struct __ns1__getCodingParam), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCodingParam(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCodingParamReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getCodingParamReq(soap, "ns1:getCodingParamReq", &a->ns1__getCodingParamReq, ""))
				{	soap_flag_ns1__getCodingParamReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCodingParam(struct soap *soap, const struct __ns1__getCodingParam *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCodingParam(soap, tag?tag:"-ns1:getCodingParam", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCodingParam * SOAP_FMAC4 soap_get___ns1__getCodingParam(struct soap *soap, struct __ns1__getCodingParam *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCodingParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__presetControl(struct soap *soap, struct __ns1__presetControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__presetControlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__presetControl(struct soap *soap, const struct __ns1__presetControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__presetControlReq(soap, &a->ns1__presetControlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__presetControl(struct soap *soap, const char *tag, int id, const struct __ns1__presetControl *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__presetControlReq(soap, "ns1:presetControlReq", -1, &a->ns1__presetControlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__presetControl * SOAP_FMAC4 soap_in___ns1__presetControl(struct soap *soap, const char *tag, struct __ns1__presetControl *a, const char *type)
{
	size_t soap_flag_ns1__presetControlReq = 1;
	short soap_flag;
	a = (struct __ns1__presetControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__presetControl, sizeof(struct __ns1__presetControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__presetControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__presetControlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__presetControlReq(soap, "ns1:presetControlReq", &a->ns1__presetControlReq, ""))
				{	soap_flag_ns1__presetControlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__presetControl(struct soap *soap, const struct __ns1__presetControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__presetControl(soap, tag?tag:"-ns1:presetControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__presetControl * SOAP_FMAC4 soap_get___ns1__presetControl(struct soap *soap, struct __ns1__presetControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__presetControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lensControl(struct soap *soap, struct __ns1__lensControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__lensControlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lensControl(struct soap *soap, const struct __ns1__lensControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__lensControlReq(soap, &a->ns1__lensControlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lensControl(struct soap *soap, const char *tag, int id, const struct __ns1__lensControl *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__lensControlReq(soap, "ns1:lensControlReq", -1, &a->ns1__lensControlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lensControl * SOAP_FMAC4 soap_in___ns1__lensControl(struct soap *soap, const char *tag, struct __ns1__lensControl *a, const char *type)
{
	size_t soap_flag_ns1__lensControlReq = 1;
	short soap_flag;
	a = (struct __ns1__lensControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lensControl, sizeof(struct __ns1__lensControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lensControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__lensControlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__lensControlReq(soap, "ns1:lensControlReq", &a->ns1__lensControlReq, ""))
				{	soap_flag_ns1__lensControlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lensControl(struct soap *soap, const struct __ns1__lensControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__lensControl(soap, tag?tag:"-ns1:lensControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lensControl * SOAP_FMAC4 soap_get___ns1__lensControl(struct soap *soap, struct __ns1__lensControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lensControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ptzControl(struct soap *soap, struct __ns1__ptzControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ptzControlReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ptzControl(struct soap *soap, const struct __ns1__ptzControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ptzControlReq(soap, &a->ns1__ptzControlReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ptzControl(struct soap *soap, const char *tag, int id, const struct __ns1__ptzControl *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ptzControlReq(soap, "ns1:ptzControlReq", -1, &a->ns1__ptzControlReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ptzControl * SOAP_FMAC4 soap_in___ns1__ptzControl(struct soap *soap, const char *tag, struct __ns1__ptzControl *a, const char *type)
{
	size_t soap_flag_ns1__ptzControlReq = 1;
	short soap_flag;
	a = (struct __ns1__ptzControl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ptzControl, sizeof(struct __ns1__ptzControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ptzControl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ptzControlReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ptzControlReq(soap, "ns1:ptzControlReq", &a->ns1__ptzControlReq, ""))
				{	soap_flag_ns1__ptzControlReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ptzControl(struct soap *soap, const struct __ns1__ptzControl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ptzControl(soap, tag?tag:"-ns1:ptzControl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ptzControl * SOAP_FMAC4 soap_get___ns1__ptzControl(struct soap *soap, struct __ns1__ptzControl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ptzControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__nullifyDevice(struct soap *soap, struct __ns1__nullifyDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__nullifyDeviceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__nullifyDevice(struct soap *soap, const struct __ns1__nullifyDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__nullifyDeviceReq(soap, &a->ns1__nullifyDeviceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__nullifyDevice(struct soap *soap, const char *tag, int id, const struct __ns1__nullifyDevice *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__nullifyDeviceReq(soap, "ns1:nullifyDeviceReq", -1, &a->ns1__nullifyDeviceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__nullifyDevice * SOAP_FMAC4 soap_in___ns1__nullifyDevice(struct soap *soap, const char *tag, struct __ns1__nullifyDevice *a, const char *type)
{
	size_t soap_flag_ns1__nullifyDeviceReq = 1;
	short soap_flag;
	a = (struct __ns1__nullifyDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__nullifyDevice, sizeof(struct __ns1__nullifyDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__nullifyDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__nullifyDeviceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__nullifyDeviceReq(soap, "ns1:nullifyDeviceReq", &a->ns1__nullifyDeviceReq, ""))
				{	soap_flag_ns1__nullifyDeviceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__nullifyDevice(struct soap *soap, const struct __ns1__nullifyDevice *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__nullifyDevice(soap, tag?tag:"-ns1:nullifyDevice", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__nullifyDevice * SOAP_FMAC4 soap_get___ns1__nullifyDevice(struct soap *soap, struct __ns1__nullifyDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__nullifyDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addDevice(struct soap *soap, struct __ns1__addDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addDeviceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addDevice(struct soap *soap, const struct __ns1__addDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addDeviceReq(soap, &a->ns1__addDeviceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addDevice(struct soap *soap, const char *tag, int id, const struct __ns1__addDevice *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addDeviceReq(soap, "ns1:addDeviceReq", -1, &a->ns1__addDeviceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDevice * SOAP_FMAC4 soap_in___ns1__addDevice(struct soap *soap, const char *tag, struct __ns1__addDevice *a, const char *type)
{
	size_t soap_flag_ns1__addDeviceReq = 1;
	short soap_flag;
	a = (struct __ns1__addDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addDevice, sizeof(struct __ns1__addDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addDeviceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addDeviceReq(soap, "ns1:addDeviceReq", &a->ns1__addDeviceReq, ""))
				{	soap_flag_ns1__addDeviceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addDevice(struct soap *soap, const struct __ns1__addDevice *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addDevice(soap, tag?tag:"-ns1:addDevice", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addDevice * SOAP_FMAC4 soap_get___ns1__addDevice(struct soap *soap, struct __ns1__addDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateChannelName(struct soap *soap, struct __ns1__updateChannelName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateChannelNameReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateChannelName(struct soap *soap, const struct __ns1__updateChannelName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateChannelNameReq(soap, &a->ns1__updateChannelNameReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateChannelName(struct soap *soap, const char *tag, int id, const struct __ns1__updateChannelName *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateChannelNameReq(soap, "ns1:updateChannelNameReq", -1, &a->ns1__updateChannelNameReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateChannelName * SOAP_FMAC4 soap_in___ns1__updateChannelName(struct soap *soap, const char *tag, struct __ns1__updateChannelName *a, const char *type)
{
	size_t soap_flag_ns1__updateChannelNameReq = 1;
	short soap_flag;
	a = (struct __ns1__updateChannelName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateChannelName, sizeof(struct __ns1__updateChannelName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateChannelName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateChannelNameReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateChannelNameReq(soap, "ns1:updateChannelNameReq", &a->ns1__updateChannelNameReq, ""))
				{	soap_flag_ns1__updateChannelNameReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateChannelName(struct soap *soap, const struct __ns1__updateChannelName *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateChannelName(soap, tag?tag:"-ns1:updateChannelName", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateChannelName * SOAP_FMAC4 soap_get___ns1__updateChannelName(struct soap *soap, struct __ns1__updateChannelName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateChannelName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__userLogout(struct soap *soap, struct __ns1__userLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__userLogoutReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__userLogout(struct soap *soap, const struct __ns1__userLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__userLogoutReq(soap, &a->ns1__userLogoutReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__userLogout(struct soap *soap, const char *tag, int id, const struct __ns1__userLogout *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__userLogoutReq(soap, "ns1:userLogoutReq", -1, &a->ns1__userLogoutReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogout * SOAP_FMAC4 soap_in___ns1__userLogout(struct soap *soap, const char *tag, struct __ns1__userLogout *a, const char *type)
{
	size_t soap_flag_ns1__userLogoutReq = 1;
	short soap_flag;
	a = (struct __ns1__userLogout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__userLogout, sizeof(struct __ns1__userLogout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__userLogout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__userLogoutReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__userLogoutReq(soap, "ns1:userLogoutReq", &a->ns1__userLogoutReq, ""))
				{	soap_flag_ns1__userLogoutReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__userLogout(struct soap *soap, const struct __ns1__userLogout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__userLogout(soap, tag?tag:"-ns1:userLogout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogout * SOAP_FMAC4 soap_get___ns1__userLogout(struct soap *soap, struct __ns1__userLogout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__userLogout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__userLogin(struct soap *soap, struct __ns1__userLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__userLoginReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__userLogin(struct soap *soap, const struct __ns1__userLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__userLoginReq(soap, &a->ns1__userLoginReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__userLogin(struct soap *soap, const char *tag, int id, const struct __ns1__userLogin *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__userLoginReq(soap, "ns1:userLoginReq", -1, &a->ns1__userLoginReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_in___ns1__userLogin(struct soap *soap, const char *tag, struct __ns1__userLogin *a, const char *type)
{
	size_t soap_flag_ns1__userLoginReq = 1;
	short soap_flag;
	a = (struct __ns1__userLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__userLogin, sizeof(struct __ns1__userLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__userLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__userLoginReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__userLoginReq(soap, "ns1:userLoginReq", &a->ns1__userLoginReq, ""))
				{	soap_flag_ns1__userLoginReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__userLogin(struct soap *soap, const struct __ns1__userLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__userLogin(soap, tag?tag:"-ns1:userLogin", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_get___ns1__userLogin(struct soap *soap, struct __ns1__userLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__userLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__bye(struct soap *soap, struct __ns1__bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__byeReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__bye(struct soap *soap, const struct __ns1__bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__byeReq(soap, &a->ns1__byeReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__bye(struct soap *soap, const char *tag, int id, const struct __ns1__bye *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__byeReq(soap, "ns1:byeReq", -1, &a->ns1__byeReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bye * SOAP_FMAC4 soap_in___ns1__bye(struct soap *soap, const char *tag, struct __ns1__bye *a, const char *type)
{
	size_t soap_flag_ns1__byeReq = 1;
	short soap_flag;
	a = (struct __ns1__bye *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__bye, sizeof(struct __ns1__bye), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__byeReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__byeReq(soap, "ns1:byeReq", &a->ns1__byeReq, ""))
				{	soap_flag_ns1__byeReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__bye(struct soap *soap, const struct __ns1__bye *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__bye(soap, tag?tag:"-ns1:bye", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bye * SOAP_FMAC4 soap_get___ns1__bye(struct soap *soap, struct __ns1__bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__invite(struct soap *soap, struct __ns1__invite *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__inviteReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__invite(struct soap *soap, const struct __ns1__invite *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__inviteReq(soap, &a->ns1__inviteReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__invite(struct soap *soap, const char *tag, int id, const struct __ns1__invite *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__inviteReq(soap, "ns1:inviteReq", -1, &a->ns1__inviteReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__invite * SOAP_FMAC4 soap_in___ns1__invite(struct soap *soap, const char *tag, struct __ns1__invite *a, const char *type)
{
	size_t soap_flag_ns1__inviteReq = 1;
	short soap_flag;
	a = (struct __ns1__invite *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__invite, sizeof(struct __ns1__invite), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__invite(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__inviteReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__inviteReq(soap, "ns1:inviteReq", &a->ns1__inviteReq, ""))
				{	soap_flag_ns1__inviteReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__invite(struct soap *soap, const struct __ns1__invite *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__invite(soap, tag?tag:"-ns1:invite", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__invite * SOAP_FMAC4 soap_get___ns1__invite(struct soap *soap, struct __ns1__invite *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__invite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setAuxiliary(struct soap *soap, struct __ns1__setAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setAuxiliaryReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setAuxiliary(struct soap *soap, const struct __ns1__setAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setAuxiliaryReq(soap, &a->ns1__setAuxiliaryReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setAuxiliary(struct soap *soap, const char *tag, int id, const struct __ns1__setAuxiliary *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__setAuxiliaryReq(soap, "ns1:setAuxiliaryReq", -1, &a->ns1__setAuxiliaryReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAuxiliary * SOAP_FMAC4 soap_in___ns1__setAuxiliary(struct soap *soap, const char *tag, struct __ns1__setAuxiliary *a, const char *type)
{
	size_t soap_flag_ns1__setAuxiliaryReq = 1;
	short soap_flag;
	a = (struct __ns1__setAuxiliary *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setAuxiliary, sizeof(struct __ns1__setAuxiliary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setAuxiliary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setAuxiliaryReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setAuxiliaryReq(soap, "ns1:setAuxiliaryReq", &a->ns1__setAuxiliaryReq, ""))
				{	soap_flag_ns1__setAuxiliaryReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setAuxiliary(struct soap *soap, const struct __ns1__setAuxiliary *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setAuxiliary(soap, tag?tag:"-ns1:setAuxiliary", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setAuxiliary * SOAP_FMAC4 soap_get___ns1__setAuxiliary(struct soap *soap, struct __ns1__setAuxiliary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setAuxiliary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAuxiliary(struct soap *soap, struct __ns1__getAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAuxiliaryReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAuxiliary(struct soap *soap, const struct __ns1__getAuxiliary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAuxiliaryReq(soap, &a->ns1__getAuxiliaryReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAuxiliary(struct soap *soap, const char *tag, int id, const struct __ns1__getAuxiliary *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAuxiliaryReq(soap, "ns1:getAuxiliaryReq", -1, &a->ns1__getAuxiliaryReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAuxiliary * SOAP_FMAC4 soap_in___ns1__getAuxiliary(struct soap *soap, const char *tag, struct __ns1__getAuxiliary *a, const char *type)
{
	size_t soap_flag_ns1__getAuxiliaryReq = 1;
	short soap_flag;
	a = (struct __ns1__getAuxiliary *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAuxiliary, sizeof(struct __ns1__getAuxiliary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAuxiliary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAuxiliaryReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAuxiliaryReq(soap, "ns1:getAuxiliaryReq", &a->ns1__getAuxiliaryReq, ""))
				{	soap_flag_ns1__getAuxiliaryReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAuxiliary(struct soap *soap, const struct __ns1__getAuxiliary *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAuxiliary(soap, tag?tag:"-ns1:getAuxiliary", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAuxiliary * SOAP_FMAC4 soap_get___ns1__getAuxiliary(struct soap *soap, struct __ns1__getAuxiliary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAuxiliary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getBackPassword(struct soap *soap, struct __ns1__getBackPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getBackPasswordReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getBackPassword(struct soap *soap, const struct __ns1__getBackPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getBackPasswordReq(soap, &a->ns1__getBackPasswordReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getBackPassword(struct soap *soap, const char *tag, int id, const struct __ns1__getBackPassword *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getBackPasswordReq(soap, "ns1:getBackPasswordReq", -1, &a->ns1__getBackPasswordReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBackPassword * SOAP_FMAC4 soap_in___ns1__getBackPassword(struct soap *soap, const char *tag, struct __ns1__getBackPassword *a, const char *type)
{
	size_t soap_flag_ns1__getBackPasswordReq = 1;
	short soap_flag;
	a = (struct __ns1__getBackPassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getBackPassword, sizeof(struct __ns1__getBackPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getBackPassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getBackPasswordReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getBackPasswordReq(soap, "ns1:getBackPasswordReq", &a->ns1__getBackPasswordReq, ""))
				{	soap_flag_ns1__getBackPasswordReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getBackPassword(struct soap *soap, const struct __ns1__getBackPassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getBackPassword(soap, tag?tag:"-ns1:getBackPassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBackPassword * SOAP_FMAC4 soap_get___ns1__getBackPassword(struct soap *soap, struct __ns1__getBackPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getBackPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccount(struct soap *soap, struct __ns1__getAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccountReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccount(struct soap *soap, const struct __ns1__getAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getAccountReq(soap, &a->ns1__getAccountReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccount(struct soap *soap, const char *tag, int id, const struct __ns1__getAccount *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__getAccountReq(soap, "ns1:getAccountReq", -1, &a->ns1__getAccountReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccount * SOAP_FMAC4 soap_in___ns1__getAccount(struct soap *soap, const char *tag, struct __ns1__getAccount *a, const char *type)
{
	size_t soap_flag_ns1__getAccountReq = 1;
	short soap_flag;
	a = (struct __ns1__getAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccount, sizeof(struct __ns1__getAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccountReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getAccountReq(soap, "ns1:getAccountReq", &a->ns1__getAccountReq, ""))
				{	soap_flag_ns1__getAccountReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccount(struct soap *soap, const struct __ns1__getAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccount(soap, tag?tag:"-ns1:getAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccount * SOAP_FMAC4 soap_get___ns1__getAccount(struct soap *soap, struct __ns1__getAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAppleToken(struct soap *soap, struct __ns1__updateAppleToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAppleTokenReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAppleToken(struct soap *soap, const struct __ns1__updateAppleToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAppleTokenReq(soap, &a->ns1__updateAppleTokenReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAppleToken(struct soap *soap, const char *tag, int id, const struct __ns1__updateAppleToken *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAppleTokenReq(soap, "ns1:updateAppleTokenReq", -1, &a->ns1__updateAppleTokenReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAppleToken * SOAP_FMAC4 soap_in___ns1__updateAppleToken(struct soap *soap, const char *tag, struct __ns1__updateAppleToken *a, const char *type)
{
	size_t soap_flag_ns1__updateAppleTokenReq = 1;
	short soap_flag;
	a = (struct __ns1__updateAppleToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAppleToken, sizeof(struct __ns1__updateAppleToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAppleToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAppleTokenReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAppleTokenReq(soap, "ns1:updateAppleTokenReq", &a->ns1__updateAppleTokenReq, ""))
				{	soap_flag_ns1__updateAppleTokenReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAppleToken(struct soap *soap, const struct __ns1__updateAppleToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAppleToken(soap, tag?tag:"-ns1:updateAppleToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAppleToken * SOAP_FMAC4 soap_get___ns1__updateAppleToken(struct soap *soap, struct __ns1__updateAppleToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAppleToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__queryDevice(struct soap *soap, struct __ns1__queryDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__queryDeviceReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__queryDevice(struct soap *soap, const struct __ns1__queryDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__queryDeviceReq(soap, &a->ns1__queryDeviceReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__queryDevice(struct soap *soap, const char *tag, int id, const struct __ns1__queryDevice *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__queryDeviceReq(soap, "ns1:queryDeviceReq", -1, &a->ns1__queryDeviceReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevice * SOAP_FMAC4 soap_in___ns1__queryDevice(struct soap *soap, const char *tag, struct __ns1__queryDevice *a, const char *type)
{
	size_t soap_flag_ns1__queryDeviceReq = 1;
	short soap_flag;
	a = (struct __ns1__queryDevice *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__queryDevice, sizeof(struct __ns1__queryDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__queryDevice(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__queryDeviceReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__queryDeviceReq(soap, "ns1:queryDeviceReq", &a->ns1__queryDeviceReq, ""))
				{	soap_flag_ns1__queryDeviceReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__queryDevice(struct soap *soap, const struct __ns1__queryDevice *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__queryDevice(soap, tag?tag:"-ns1:queryDevice", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__queryDevice * SOAP_FMAC4 soap_get___ns1__queryDevice(struct soap *soap, struct __ns1__queryDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__queryDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updatePassword(struct soap *soap, struct __ns1__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updatePasswordReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updatePassword(struct soap *soap, const struct __ns1__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updatePasswordReq(soap, &a->ns1__updatePasswordReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updatePassword(struct soap *soap, const char *tag, int id, const struct __ns1__updatePassword *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updatePasswordReq(soap, "ns1:updatePasswordReq", -1, &a->ns1__updatePasswordReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePassword * SOAP_FMAC4 soap_in___ns1__updatePassword(struct soap *soap, const char *tag, struct __ns1__updatePassword *a, const char *type)
{
	size_t soap_flag_ns1__updatePasswordReq = 1;
	short soap_flag;
	a = (struct __ns1__updatePassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updatePassword, sizeof(struct __ns1__updatePassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updatePassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updatePasswordReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updatePasswordReq(soap, "ns1:updatePasswordReq", &a->ns1__updatePasswordReq, ""))
				{	soap_flag_ns1__updatePasswordReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updatePassword(struct soap *soap, const struct __ns1__updatePassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updatePassword(soap, tag?tag:"-ns1:updatePassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePassword * SOAP_FMAC4 soap_get___ns1__updatePassword(struct soap *soap, struct __ns1__updatePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updatePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateAccount(struct soap *soap, struct __ns1__updateAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateAccountReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateAccount(struct soap *soap, const struct __ns1__updateAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__updateAccountReq(soap, &a->ns1__updateAccountReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateAccount(struct soap *soap, const char *tag, int id, const struct __ns1__updateAccount *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__updateAccountReq(soap, "ns1:updateAccountReq", -1, &a->ns1__updateAccountReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccount * SOAP_FMAC4 soap_in___ns1__updateAccount(struct soap *soap, const char *tag, struct __ns1__updateAccount *a, const char *type)
{
	size_t soap_flag_ns1__updateAccountReq = 1;
	short soap_flag;
	a = (struct __ns1__updateAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateAccount, sizeof(struct __ns1__updateAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateAccountReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__updateAccountReq(soap, "ns1:updateAccountReq", &a->ns1__updateAccountReq, ""))
				{	soap_flag_ns1__updateAccountReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateAccount(struct soap *soap, const struct __ns1__updateAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateAccount(soap, tag?tag:"-ns1:updateAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateAccount * SOAP_FMAC4 soap_get___ns1__updateAccount(struct soap *soap, struct __ns1__updateAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createAccount(struct soap *soap, struct __ns1__createAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createAccountReq = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createAccount(struct soap *soap, const struct __ns1__createAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__createAccountReq(soap, &a->ns1__createAccountReq);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createAccount(struct soap *soap, const char *tag, int id, const struct __ns1__createAccount *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__createAccountReq(soap, "ns1:createAccountReq", -1, &a->ns1__createAccountReq, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createAccount * SOAP_FMAC4 soap_in___ns1__createAccount(struct soap *soap, const char *tag, struct __ns1__createAccount *a, const char *type)
{
	size_t soap_flag_ns1__createAccountReq = 1;
	short soap_flag;
	a = (struct __ns1__createAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createAccount, sizeof(struct __ns1__createAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createAccountReq && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__createAccountReq(soap, "ns1:createAccountReq", &a->ns1__createAccountReq, ""))
				{	soap_flag_ns1__createAccountReq--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createAccount(struct soap *soap, const struct __ns1__createAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createAccount(soap, tag?tag:"-ns1:createAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createAccount * SOAP_FMAC4 soap_get___ns1__createAccount(struct soap *soap, struct __ns1__createAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__vodSearchRes_Any(struct soap *soap, struct _ns1__vodSearchRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__vodSearchRes_Any(struct soap *soap, const struct _ns1__vodSearchRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__vodSearchRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__vodSearchRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__vodSearchRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__vodSearchRes_Any * SOAP_FMAC4 soap_in__ns1__vodSearchRes_Any(struct soap *soap, const char *tag, struct _ns1__vodSearchRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__vodSearchRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__vodSearchRes_Any, sizeof(struct _ns1__vodSearchRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__vodSearchRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__vodSearchRes_Any, 0, sizeof(struct _ns1__vodSearchRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__vodSearchRes_Any(struct soap *soap, const struct _ns1__vodSearchRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__vodSearchRes_Any);
	if (soap_out__ns1__vodSearchRes_Any(soap, tag?tag:"ns1:vodSearchRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchRes_Any * SOAP_FMAC4 soap_get__ns1__vodSearchRes_Any(struct soap *soap, struct _ns1__vodSearchRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__vodSearchRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_int(soap, &a->PageNo);
	soap_default_int(soap, &a->PageCount);
	soap_default_int(soap, &a->RecordCount);
	a->__sizeRecord = 0;
	a->Record = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__vodSearchRes(struct soap *soap, const struct _ns1__vodSearchRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PageNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PageCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->RecordCount, SOAP_TYPE_int);
	if (a->Record)
	{	int i;
		for (i = 0; i < a->__sizeRecord; i++)
		{
			soap_embedded(soap, a->Record + i, SOAP_TYPE_ns1__VODRecord);
			soap_serialize_ns1__VODRecord(soap, a->Record + i);
		}
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__vodSearchRes_Any);
			soap_serialize__ns1__vodSearchRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__vodSearchRes(struct soap *soap, const char *tag, int id, const struct _ns1__vodSearchRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__vodSearchRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PageCount", -1, &a->PageCount, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:RecordCount", -1, &a->RecordCount, ""))
		return soap->error;
	if (a->Record)
	{	int i;
		for (i = 0; i < a->__sizeRecord; i++)
			if (soap_out_ns1__VODRecord(soap, "ns1:Record", -1, a->Record + i, ""))
				return soap->error;
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__vodSearchRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__vodSearchRes * SOAP_FMAC4 soap_in__ns1__vodSearchRes(struct soap *soap, const char *tag, struct _ns1__vodSearchRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_PageCount = 1;
	size_t soap_flag_RecordCount = 1;
	struct soap_blist *soap_blist_Record = NULL;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__vodSearchRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__vodSearchRes, sizeof(struct _ns1__vodSearchRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__vodSearchRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_PageCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PageCount", &a->PageCount, "xsd:int"))
				{	soap_flag_PageCount--;
					continue;
				}
			if (soap_flag_RecordCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:RecordCount", &a->RecordCount, "xsd:int"))
				{	soap_flag_RecordCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Record", 1, NULL))
			{	if (a->Record == NULL)
				{	if (soap_blist_Record == NULL)
						soap_blist_Record = soap_new_block(soap);
					a->Record = (struct ns1__VODRecord *)soap_push_block(soap, soap_blist_Record, sizeof(struct ns1__VODRecord));
					if (a->Record == NULL)
						return NULL;
					soap_default_ns1__VODRecord(soap, a->Record);
				}
				soap_revert(soap);
				if (soap_in_ns1__VODRecord(soap, "ns1:Record", a->Record, "ns1:VODRecord"))
				{	a->__sizeRecord++;
					a->Record = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__vodSearchRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__vodSearchRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__vodSearchRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__vodSearchRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Record)
			soap_pop_block(soap, soap_blist_Record);
		if (a->__sizeRecord)
			a->Record = (struct ns1__VODRecord *)soap_save_block(soap, soap_blist_Record, NULL, 1);
		else
		{	a->Record = NULL;
			if (soap_blist_Record)
				soap_end_block(soap, soap_blist_Record);
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__vodSearchRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__vodSearchRes, 0, sizeof(struct _ns1__vodSearchRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_PageNo > 0 || soap_flag_PageCount > 0 || soap_flag_RecordCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__vodSearchRes(struct soap *soap, const struct _ns1__vodSearchRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__vodSearchRes);
	if (soap_out__ns1__vodSearchRes(soap, tag?tag:"ns1:vodSearchRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchRes * SOAP_FMAC4 soap_get__ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__vodSearchRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__vodSearchReq_Any(struct soap *soap, struct _ns1__vodSearchReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__vodSearchReq_Any(struct soap *soap, const struct _ns1__vodSearchReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__vodSearchReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__vodSearchReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__vodSearchReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__vodSearchReq_Any * SOAP_FMAC4 soap_in__ns1__vodSearchReq_Any(struct soap *soap, const char *tag, struct _ns1__vodSearchReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__vodSearchReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__vodSearchReq_Any, sizeof(struct _ns1__vodSearchReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__vodSearchReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__vodSearchReq_Any, 0, sizeof(struct _ns1__vodSearchReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__vodSearchReq_Any(struct soap *soap, const struct _ns1__vodSearchReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__vodSearchReq_Any);
	if (soap_out__ns1__vodSearchReq_Any(soap, tag?tag:"ns1:vodSearchReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchReq_Any * SOAP_FMAC4 soap_get__ns1__vodSearchReq_Any(struct soap *soap, struct _ns1__vodSearchReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__vodSearchReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->PageNo = NULL;
	soap_default_string(soap, &a->SearchID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__vodSearchReq(struct soap *soap, const struct _ns1__vodSearchReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_serialize_PointerToint(soap, &a->PageNo);
	soap_serialize_string(soap, &a->SearchID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__vodSearchReq_Any);
			soap_serialize__ns1__vodSearchReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__vodSearchReq(struct soap *soap, const char *tag, int id, const struct _ns1__vodSearchReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__vodSearchReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:PageNo", -1, &a->PageNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SearchID", -1, &a->SearchID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__vodSearchReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__vodSearchReq * SOAP_FMAC4 soap_in__ns1__vodSearchReq(struct soap *soap, const char *tag, struct _ns1__vodSearchReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_PageNo = 1;
	size_t soap_flag_SearchID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__vodSearchReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__vodSearchReq, sizeof(struct _ns1__vodSearchReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__vodSearchReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_PageNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:PageNo", &a->PageNo, "xsd:int"))
				{	soap_flag_PageNo--;
					continue;
				}
			if (soap_flag_SearchID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SearchID", &a->SearchID, "xsd:string"))
				{	soap_flag_SearchID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__vodSearchReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__vodSearchReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__vodSearchReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__vodSearchReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__vodSearchReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__vodSearchReq, 0, sizeof(struct _ns1__vodSearchReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0 || soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__vodSearchReq(struct soap *soap, const struct _ns1__vodSearchReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__vodSearchReq);
	if (soap_out__ns1__vodSearchReq(soap, tag?tag:"ns1:vodSearchReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchReq * SOAP_FMAC4 soap_get__ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__vodSearchReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVODUrlRes_Any(struct soap *soap, struct _ns1__getVODUrlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVODUrlRes_Any(struct soap *soap, const struct _ns1__getVODUrlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVODUrlRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getVODUrlRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVODUrlRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes_Any * SOAP_FMAC4 soap_in__ns1__getVODUrlRes_Any(struct soap *soap, const char *tag, struct _ns1__getVODUrlRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVODUrlRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVODUrlRes_Any, sizeof(struct _ns1__getVODUrlRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVODUrlRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVODUrlRes_Any, 0, sizeof(struct _ns1__getVODUrlRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVODUrlRes_Any(struct soap *soap, const struct _ns1__getVODUrlRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVODUrlRes_Any);
	if (soap_out__ns1__getVODUrlRes_Any(soap, tag?tag:"ns1:getVODUrlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes_Any * SOAP_FMAC4 soap_get__ns1__getVODUrlRes_Any(struct soap *soap, struct _ns1__getVODUrlRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVODUrlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->VideoVODUrl);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVODUrlRes(struct soap *soap, const struct _ns1__getVODUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VideoVODUrl);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getVODUrlRes_Any);
			soap_serialize__ns1__getVODUrlRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVODUrlRes(struct soap *soap, const char *tag, int id, const struct _ns1__getVODUrlRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVODUrlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:VideoVODUrl", -1, &a->VideoVODUrl, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getVODUrlRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes * SOAP_FMAC4 soap_in__ns1__getVODUrlRes(struct soap *soap, const char *tag, struct _ns1__getVODUrlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_VideoVODUrl = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVODUrlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVODUrlRes, sizeof(struct _ns1__getVODUrlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVODUrlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_VideoVODUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:VideoVODUrl", &a->VideoVODUrl, "xsd:string"))
				{	soap_flag_VideoVODUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getVODUrlRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getVODUrlRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getVODUrlRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getVODUrlRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getVODUrlRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVODUrlRes, 0, sizeof(struct _ns1__getVODUrlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVODUrlRes(struct soap *soap, const struct _ns1__getVODUrlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVODUrlRes);
	if (soap_out__ns1__getVODUrlRes(soap, tag?tag:"ns1:getVODUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes * SOAP_FMAC4 soap_get__ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVODUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVODUrlReq_Any(struct soap *soap, struct _ns1__getVODUrlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVODUrlReq_Any(struct soap *soap, const struct _ns1__getVODUrlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVODUrlReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getVODUrlReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVODUrlReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq_Any * SOAP_FMAC4 soap_in__ns1__getVODUrlReq_Any(struct soap *soap, const char *tag, struct _ns1__getVODUrlReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVODUrlReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVODUrlReq_Any, sizeof(struct _ns1__getVODUrlReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVODUrlReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVODUrlReq_Any, 0, sizeof(struct _ns1__getVODUrlReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVODUrlReq_Any(struct soap *soap, const struct _ns1__getVODUrlReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVODUrlReq_Any);
	if (soap_out__ns1__getVODUrlReq_Any(soap, tag?tag:"ns1:getVODUrlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq_Any * SOAP_FMAC4 soap_get__ns1__getVODUrlReq_Any(struct soap *soap, struct _ns1__getVODUrlReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVODUrlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVODUrlReq(struct soap *soap, const struct _ns1__getVODUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getVODUrlReq_Any);
			soap_serialize__ns1__getVODUrlReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVODUrlReq(struct soap *soap, const char *tag, int id, const struct _ns1__getVODUrlReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVODUrlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getVODUrlReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq * SOAP_FMAC4 soap_in__ns1__getVODUrlReq(struct soap *soap, const char *tag, struct _ns1__getVODUrlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVODUrlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVODUrlReq, sizeof(struct _ns1__getVODUrlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVODUrlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getVODUrlReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getVODUrlReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getVODUrlReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getVODUrlReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getVODUrlReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVODUrlReq, 0, sizeof(struct _ns1__getVODUrlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0 || soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVODUrlReq(struct soap *soap, const struct _ns1__getVODUrlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVODUrlReq);
	if (soap_out__ns1__getVODUrlReq(soap, tag?tag:"ns1:getVODUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq * SOAP_FMAC4 soap_get__ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVODUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPlayUrlRes_Any(struct soap *soap, struct _ns1__getPlayUrlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPlayUrlRes_Any(struct soap *soap, const struct _ns1__getPlayUrlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPlayUrlRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getPlayUrlRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPlayUrlRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes_Any * SOAP_FMAC4 soap_in__ns1__getPlayUrlRes_Any(struct soap *soap, const char *tag, struct _ns1__getPlayUrlRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPlayUrlRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPlayUrlRes_Any, sizeof(struct _ns1__getPlayUrlRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPlayUrlRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPlayUrlRes_Any, 0, sizeof(struct _ns1__getPlayUrlRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPlayUrlRes_Any(struct soap *soap, const struct _ns1__getPlayUrlRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPlayUrlRes_Any);
	if (soap_out__ns1__getPlayUrlRes_Any(soap, tag?tag:"ns1:getPlayUrlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes_Any * SOAP_FMAC4 soap_get__ns1__getPlayUrlRes_Any(struct soap *soap, struct _ns1__getPlayUrlRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPlayUrlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->AOR);
	soap_default_string(soap, &a->ProxyUri);
	soap_default_string(soap, &a->ContactUri);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPlayUrlRes(struct soap *soap, const struct _ns1__getPlayUrlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->AOR);
	soap_serialize_string(soap, &a->ProxyUri);
	soap_serialize_string(soap, &a->ContactUri);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getPlayUrlRes_Any);
			soap_serialize__ns1__getPlayUrlRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPlayUrlRes(struct soap *soap, const char *tag, int id, const struct _ns1__getPlayUrlRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPlayUrlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AOR", -1, &a->AOR, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ProxyUri", -1, &a->ProxyUri, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ContactUri", -1, &a->ContactUri, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getPlayUrlRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes * SOAP_FMAC4 soap_in__ns1__getPlayUrlRes(struct soap *soap, const char *tag, struct _ns1__getPlayUrlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_AOR = 1;
	size_t soap_flag_ProxyUri = 1;
	size_t soap_flag_ContactUri = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPlayUrlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPlayUrlRes, sizeof(struct _ns1__getPlayUrlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPlayUrlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_AOR && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AOR", &a->AOR, "xsd:string"))
				{	soap_flag_AOR--;
					continue;
				}
			if (soap_flag_ProxyUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ProxyUri", &a->ProxyUri, "xsd:string"))
				{	soap_flag_ProxyUri--;
					continue;
				}
			if (soap_flag_ContactUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ContactUri", &a->ContactUri, "xsd:string"))
				{	soap_flag_ContactUri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getPlayUrlRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getPlayUrlRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getPlayUrlRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getPlayUrlRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getPlayUrlRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPlayUrlRes, 0, sizeof(struct _ns1__getPlayUrlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPlayUrlRes(struct soap *soap, const struct _ns1__getPlayUrlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPlayUrlRes);
	if (soap_out__ns1__getPlayUrlRes(soap, tag?tag:"ns1:getPlayUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes * SOAP_FMAC4 soap_get__ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPlayUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPlayUrlReq_Any(struct soap *soap, struct _ns1__getPlayUrlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPlayUrlReq_Any(struct soap *soap, const struct _ns1__getPlayUrlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPlayUrlReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getPlayUrlReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPlayUrlReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq_Any * SOAP_FMAC4 soap_in__ns1__getPlayUrlReq_Any(struct soap *soap, const char *tag, struct _ns1__getPlayUrlReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPlayUrlReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPlayUrlReq_Any, sizeof(struct _ns1__getPlayUrlReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPlayUrlReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPlayUrlReq_Any, 0, sizeof(struct _ns1__getPlayUrlReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPlayUrlReq_Any(struct soap *soap, const struct _ns1__getPlayUrlReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPlayUrlReq_Any);
	if (soap_out__ns1__getPlayUrlReq_Any(soap, tag?tag:"ns1:getPlayUrlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq_Any * SOAP_FMAC4 soap_get__ns1__getPlayUrlReq_Any(struct soap *soap, struct _ns1__getPlayUrlReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPlayUrlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPlayUrlReq(struct soap *soap, const struct _ns1__getPlayUrlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getPlayUrlReq_Any);
			soap_serialize__ns1__getPlayUrlReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPlayUrlReq(struct soap *soap, const char *tag, int id, const struct _ns1__getPlayUrlReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPlayUrlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getPlayUrlReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq * SOAP_FMAC4 soap_in__ns1__getPlayUrlReq(struct soap *soap, const char *tag, struct _ns1__getPlayUrlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPlayUrlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPlayUrlReq, sizeof(struct _ns1__getPlayUrlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPlayUrlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getPlayUrlReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getPlayUrlReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getPlayUrlReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getPlayUrlReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getPlayUrlReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPlayUrlReq, 0, sizeof(struct _ns1__getPlayUrlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPlayUrlReq(struct soap *soap, const struct _ns1__getPlayUrlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPlayUrlReq);
	if (soap_out__ns1__getPlayUrlReq(soap, tag?tag:"ns1:getPlayUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq * SOAP_FMAC4 soap_get__ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPlayUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPrivacyMaskParamRes_Any(struct soap *soap, const struct _ns1__setPrivacyMaskParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setPrivacyMaskParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes_Any * SOAP_FMAC4 soap_in__ns1__setPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPrivacyMaskParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any, sizeof(struct _ns1__setPrivacyMaskParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPrivacyMaskParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any, 0, sizeof(struct _ns1__setPrivacyMaskParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPrivacyMaskParamRes_Any(struct soap *soap, const struct _ns1__setPrivacyMaskParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any);
	if (soap_out__ns1__setPrivacyMaskParamRes_Any(soap, tag?tag:"ns1:setPrivacyMaskParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes_Any * SOAP_FMAC4 soap_get__ns1__setPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPrivacyMaskParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPrivacyMaskParamRes(struct soap *soap, const struct _ns1__setPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any);
			soap_serialize__ns1__setPrivacyMaskParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setPrivacyMaskParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPrivacyMaskParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setPrivacyMaskParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes * SOAP_FMAC4 soap_in__ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPrivacyMaskParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPrivacyMaskParamRes, sizeof(struct _ns1__setPrivacyMaskParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPrivacyMaskParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setPrivacyMaskParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setPrivacyMaskParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setPrivacyMaskParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setPrivacyMaskParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setPrivacyMaskParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPrivacyMaskParamRes, 0, sizeof(struct _ns1__setPrivacyMaskParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPrivacyMaskParamRes(struct soap *soap, const struct _ns1__setPrivacyMaskParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPrivacyMaskParamRes);
	if (soap_out__ns1__setPrivacyMaskParamRes(soap, tag?tag:"ns1:setPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes * SOAP_FMAC4 soap_get__ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPrivacyMaskParamReq_Any(struct soap *soap, const struct _ns1__setPrivacyMaskParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setPrivacyMaskParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq_Any * SOAP_FMAC4 soap_in__ns1__setPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPrivacyMaskParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any, sizeof(struct _ns1__setPrivacyMaskParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPrivacyMaskParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any, 0, sizeof(struct _ns1__setPrivacyMaskParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPrivacyMaskParamReq_Any(struct soap *soap, const struct _ns1__setPrivacyMaskParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any);
	if (soap_out__ns1__setPrivacyMaskParamReq_Any(soap, tag?tag:"ns1:setPrivacyMaskParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq_Any * SOAP_FMAC4 soap_get__ns1__setPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPrivacyMaskParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->Enabled = NULL;
	a->__sizeRegion = 0;
	a->Region = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setPrivacyMaskParamReq(struct soap *soap, const struct _ns1__setPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
		{
			soap_embedded(soap, a->Region + i, SOAP_TYPE_ns1__PrivacyMaskRegion);
			soap_serialize_ns1__PrivacyMaskRegion(soap, a->Region + i);
		}
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any);
			soap_serialize__ns1__setPrivacyMaskParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setPrivacyMaskParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setPrivacyMaskParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
			if (soap_out_ns1__PrivacyMaskRegion(soap, "ns1:Region", -1, a->Region + i, ""))
				return soap->error;
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setPrivacyMaskParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq * SOAP_FMAC4 soap_in__ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Region = NULL;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setPrivacyMaskParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setPrivacyMaskParamReq, sizeof(struct _ns1__setPrivacyMaskParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setPrivacyMaskParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Region", 1, NULL))
			{	if (a->Region == NULL)
				{	if (soap_blist_Region == NULL)
						soap_blist_Region = soap_new_block(soap);
					a->Region = (struct ns1__PrivacyMaskRegion *)soap_push_block(soap, soap_blist_Region, sizeof(struct ns1__PrivacyMaskRegion));
					if (a->Region == NULL)
						return NULL;
					soap_default_ns1__PrivacyMaskRegion(soap, a->Region);
				}
				soap_revert(soap);
				if (soap_in_ns1__PrivacyMaskRegion(soap, "ns1:Region", a->Region, "ns1:PrivacyMaskRegion"))
				{	a->__sizeRegion++;
					a->Region = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setPrivacyMaskParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setPrivacyMaskParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setPrivacyMaskParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setPrivacyMaskParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Region)
			soap_pop_block(soap, soap_blist_Region);
		if (a->__sizeRegion)
			a->Region = (struct ns1__PrivacyMaskRegion *)soap_save_block(soap, soap_blist_Region, NULL, 1);
		else
		{	a->Region = NULL;
			if (soap_blist_Region)
				soap_end_block(soap, soap_blist_Region);
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setPrivacyMaskParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setPrivacyMaskParamReq, 0, sizeof(struct _ns1__setPrivacyMaskParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setPrivacyMaskParamReq(struct soap *soap, const struct _ns1__setPrivacyMaskParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setPrivacyMaskParamReq);
	if (soap_out__ns1__setPrivacyMaskParamReq(soap, tag?tag:"ns1:setPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq * SOAP_FMAC4 soap_get__ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPrivacyMaskParamRes_Any(struct soap *soap, const struct _ns1__getPrivacyMaskParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getPrivacyMaskParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes_Any * SOAP_FMAC4 soap_in__ns1__getPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPrivacyMaskParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any, sizeof(struct _ns1__getPrivacyMaskParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPrivacyMaskParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any, 0, sizeof(struct _ns1__getPrivacyMaskParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPrivacyMaskParamRes_Any(struct soap *soap, const struct _ns1__getPrivacyMaskParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any);
	if (soap_out__ns1__getPrivacyMaskParamRes_Any(soap, tag?tag:"ns1:getPrivacyMaskParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes_Any * SOAP_FMAC4 soap_get__ns1__getPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrivacyMaskParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Enabled = NULL;
	a->HorizontalResolution = NULL;
	a->VerticalResolution = NULL;
	a->__sizeRegion = 0;
	a->Region = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPrivacyMaskParamRes(struct soap *soap, const struct _ns1__getPrivacyMaskParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToint(soap, &a->HorizontalResolution);
	soap_serialize_PointerToint(soap, &a->VerticalResolution);
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
		{
			soap_embedded(soap, a->Region + i, SOAP_TYPE_ns1__PrivacyMaskRegion);
			soap_serialize_ns1__PrivacyMaskRegion(soap, a->Region + i);
		}
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any);
			soap_serialize__ns1__getPrivacyMaskParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getPrivacyMaskParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrivacyMaskParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:HorizontalResolution", -1, &a->HorizontalResolution, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:VerticalResolution", -1, &a->VerticalResolution, ""))
		return soap->error;
	if (a->Region)
	{	int i;
		for (i = 0; i < a->__sizeRegion; i++)
			if (soap_out_ns1__PrivacyMaskRegion(soap, "ns1:Region", -1, a->Region + i, ""))
				return soap->error;
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getPrivacyMaskParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes * SOAP_FMAC4 soap_in__ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_HorizontalResolution = 1;
	size_t soap_flag_VerticalResolution = 1;
	struct soap_blist *soap_blist_Region = NULL;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPrivacyMaskParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrivacyMaskParamRes, sizeof(struct _ns1__getPrivacyMaskParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPrivacyMaskParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_HorizontalResolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:HorizontalResolution", &a->HorizontalResolution, "xsd:int"))
				{	soap_flag_HorizontalResolution--;
					continue;
				}
			if (soap_flag_VerticalResolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:VerticalResolution", &a->VerticalResolution, "xsd:int"))
				{	soap_flag_VerticalResolution--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Region", 1, NULL))
			{	if (a->Region == NULL)
				{	if (soap_blist_Region == NULL)
						soap_blist_Region = soap_new_block(soap);
					a->Region = (struct ns1__PrivacyMaskRegion *)soap_push_block(soap, soap_blist_Region, sizeof(struct ns1__PrivacyMaskRegion));
					if (a->Region == NULL)
						return NULL;
					soap_default_ns1__PrivacyMaskRegion(soap, a->Region);
				}
				soap_revert(soap);
				if (soap_in_ns1__PrivacyMaskRegion(soap, "ns1:Region", a->Region, "ns1:PrivacyMaskRegion"))
				{	a->__sizeRegion++;
					a->Region = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getPrivacyMaskParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getPrivacyMaskParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getPrivacyMaskParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getPrivacyMaskParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Region)
			soap_pop_block(soap, soap_blist_Region);
		if (a->__sizeRegion)
			a->Region = (struct ns1__PrivacyMaskRegion *)soap_save_block(soap, soap_blist_Region, NULL, 1);
		else
		{	a->Region = NULL;
			if (soap_blist_Region)
				soap_end_block(soap, soap_blist_Region);
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getPrivacyMaskParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrivacyMaskParamRes, 0, sizeof(struct _ns1__getPrivacyMaskParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPrivacyMaskParamRes(struct soap *soap, const struct _ns1__getPrivacyMaskParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPrivacyMaskParamRes);
	if (soap_out__ns1__getPrivacyMaskParamRes(soap, tag?tag:"ns1:getPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes * SOAP_FMAC4 soap_get__ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPrivacyMaskParamReq_Any(struct soap *soap, const struct _ns1__getPrivacyMaskParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getPrivacyMaskParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq_Any * SOAP_FMAC4 soap_in__ns1__getPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPrivacyMaskParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any, sizeof(struct _ns1__getPrivacyMaskParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPrivacyMaskParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any, 0, sizeof(struct _ns1__getPrivacyMaskParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPrivacyMaskParamReq_Any(struct soap *soap, const struct _ns1__getPrivacyMaskParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any);
	if (soap_out__ns1__getPrivacyMaskParamReq_Any(soap, tag?tag:"ns1:getPrivacyMaskParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq_Any * SOAP_FMAC4 soap_get__ns1__getPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrivacyMaskParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getPrivacyMaskParamReq(struct soap *soap, const struct _ns1__getPrivacyMaskParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any);
			soap_serialize__ns1__getPrivacyMaskParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getPrivacyMaskParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getPrivacyMaskParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getPrivacyMaskParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq * SOAP_FMAC4 soap_in__ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getPrivacyMaskParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getPrivacyMaskParamReq, sizeof(struct _ns1__getPrivacyMaskParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getPrivacyMaskParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getPrivacyMaskParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getPrivacyMaskParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getPrivacyMaskParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getPrivacyMaskParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getPrivacyMaskParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getPrivacyMaskParamReq, 0, sizeof(struct _ns1__getPrivacyMaskParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getPrivacyMaskParamReq(struct soap *soap, const struct _ns1__getPrivacyMaskParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getPrivacyMaskParamReq);
	if (soap_out__ns1__getPrivacyMaskParamReq(soap, tag?tag:"ns1:getPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq * SOAP_FMAC4 soap_get__ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVMDParamRes_Any(struct soap *soap, struct _ns1__setVMDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVMDParamRes_Any(struct soap *soap, const struct _ns1__setVMDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVMDParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setVMDParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVMDParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes_Any * SOAP_FMAC4 soap_in__ns1__setVMDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setVMDParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVMDParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVMDParamRes_Any, sizeof(struct _ns1__setVMDParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVMDParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVMDParamRes_Any, 0, sizeof(struct _ns1__setVMDParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVMDParamRes_Any(struct soap *soap, const struct _ns1__setVMDParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVMDParamRes_Any);
	if (soap_out__ns1__setVMDParamRes_Any(soap, tag?tag:"ns1:setVMDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes_Any * SOAP_FMAC4 soap_get__ns1__setVMDParamRes_Any(struct soap *soap, struct _ns1__setVMDParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVMDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVMDParamRes(struct soap *soap, const struct _ns1__setVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setVMDParamRes_Any);
			soap_serialize__ns1__setVMDParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVMDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setVMDParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVMDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setVMDParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes * SOAP_FMAC4 soap_in__ns1__setVMDParamRes(struct soap *soap, const char *tag, struct _ns1__setVMDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVMDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVMDParamRes, sizeof(struct _ns1__setVMDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVMDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setVMDParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setVMDParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setVMDParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setVMDParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setVMDParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVMDParamRes, 0, sizeof(struct _ns1__setVMDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVMDParamRes(struct soap *soap, const struct _ns1__setVMDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVMDParamRes);
	if (soap_out__ns1__setVMDParamRes(soap, tag?tag:"ns1:setVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes * SOAP_FMAC4 soap_get__ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVMDParamReq_Any(struct soap *soap, struct _ns1__setVMDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVMDParamReq_Any(struct soap *soap, const struct _ns1__setVMDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVMDParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setVMDParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVMDParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq_Any * SOAP_FMAC4 soap_in__ns1__setVMDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setVMDParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVMDParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVMDParamReq_Any, sizeof(struct _ns1__setVMDParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVMDParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVMDParamReq_Any, 0, sizeof(struct _ns1__setVMDParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVMDParamReq_Any(struct soap *soap, const struct _ns1__setVMDParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVMDParamReq_Any);
	if (soap_out__ns1__setVMDParamReq_Any(soap, tag?tag:"ns1:setVMDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq_Any * SOAP_FMAC4 soap_get__ns1__setVMDParamReq_Any(struct soap *soap, struct _ns1__setVMDParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVMDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->Enabled = NULL;
	a->Sensitivity = NULL;
	a->StartTriggerTime = NULL;
	a->EndTriggerTime = NULL;
	a->Grid = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVMDParamReq(struct soap *soap, const struct _ns1__setVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToint(soap, &a->Sensitivity);
	soap_serialize_PointerToint(soap, &a->StartTriggerTime);
	soap_serialize_PointerToint(soap, &a->EndTriggerTime);
	soap_serialize_PointerTons1__VMDGrid(soap, &a->Grid);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setVMDParamReq_Any);
			soap_serialize__ns1__setVMDParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVMDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setVMDParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVMDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Sensitivity", -1, &a->Sensitivity, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:StartTriggerTime", -1, &a->StartTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:EndTriggerTime", -1, &a->EndTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerTons1__VMDGrid(soap, "ns1:Grid", -1, &a->Grid, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setVMDParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq * SOAP_FMAC4 soap_in__ns1__setVMDParamReq(struct soap *soap, const char *tag, struct _ns1__setVMDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Sensitivity = 1;
	size_t soap_flag_StartTriggerTime = 1;
	size_t soap_flag_EndTriggerTime = 1;
	size_t soap_flag_Grid = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVMDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVMDParamReq, sizeof(struct _ns1__setVMDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVMDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Sensitivity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Sensitivity", &a->Sensitivity, "xsd:int"))
				{	soap_flag_Sensitivity--;
					continue;
				}
			if (soap_flag_StartTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:StartTriggerTime", &a->StartTriggerTime, "xsd:int"))
				{	soap_flag_StartTriggerTime--;
					continue;
				}
			if (soap_flag_EndTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:EndTriggerTime", &a->EndTriggerTime, "xsd:int"))
				{	soap_flag_EndTriggerTime--;
					continue;
				}
			if (soap_flag_Grid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VMDGrid(soap, "ns1:Grid", &a->Grid, "ns1:VMDGrid"))
				{	soap_flag_Grid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setVMDParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setVMDParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setVMDParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setVMDParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setVMDParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVMDParamReq, 0, sizeof(struct _ns1__setVMDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVMDParamReq(struct soap *soap, const struct _ns1__setVMDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVMDParamReq);
	if (soap_out__ns1__setVMDParamReq(soap, tag?tag:"ns1:setVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq * SOAP_FMAC4 soap_get__ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVMDParamRes_Any(struct soap *soap, struct _ns1__getVMDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVMDParamRes_Any(struct soap *soap, const struct _ns1__getVMDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVMDParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getVMDParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVMDParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes_Any * SOAP_FMAC4 soap_in__ns1__getVMDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getVMDParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVMDParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVMDParamRes_Any, sizeof(struct _ns1__getVMDParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVMDParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVMDParamRes_Any, 0, sizeof(struct _ns1__getVMDParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVMDParamRes_Any(struct soap *soap, const struct _ns1__getVMDParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVMDParamRes_Any);
	if (soap_out__ns1__getVMDParamRes_Any(soap, tag?tag:"ns1:getVMDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes_Any * SOAP_FMAC4 soap_get__ns1__getVMDParamRes_Any(struct soap *soap, struct _ns1__getVMDParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVMDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Enabled = NULL;
	a->Sensitivity = NULL;
	a->StartTriggerTime = NULL;
	a->EndTriggerTime = NULL;
	a->RowGranularity = NULL;
	a->ColumnGranularity = NULL;
	a->Grid = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVMDParamRes(struct soap *soap, const struct _ns1__getVMDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToint(soap, &a->Sensitivity);
	soap_serialize_PointerToint(soap, &a->StartTriggerTime);
	soap_serialize_PointerToint(soap, &a->EndTriggerTime);
	soap_serialize_PointerToint(soap, &a->RowGranularity);
	soap_serialize_PointerToint(soap, &a->ColumnGranularity);
	soap_serialize_PointerTons1__VMDGrid(soap, &a->Grid);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getVMDParamRes_Any);
			soap_serialize__ns1__getVMDParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVMDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getVMDParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVMDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Sensitivity", -1, &a->Sensitivity, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:StartTriggerTime", -1, &a->StartTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:EndTriggerTime", -1, &a->EndTriggerTime, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:RowGranularity", -1, &a->RowGranularity, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ColumnGranularity", -1, &a->ColumnGranularity, ""))
		return soap->error;
	if (soap_out_PointerTons1__VMDGrid(soap, "ns1:Grid", -1, &a->Grid, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getVMDParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes * SOAP_FMAC4 soap_in__ns1__getVMDParamRes(struct soap *soap, const char *tag, struct _ns1__getVMDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Sensitivity = 1;
	size_t soap_flag_StartTriggerTime = 1;
	size_t soap_flag_EndTriggerTime = 1;
	size_t soap_flag_RowGranularity = 1;
	size_t soap_flag_ColumnGranularity = 1;
	size_t soap_flag_Grid = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVMDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVMDParamRes, sizeof(struct _ns1__getVMDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVMDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Sensitivity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Sensitivity", &a->Sensitivity, "xsd:int"))
				{	soap_flag_Sensitivity--;
					continue;
				}
			if (soap_flag_StartTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:StartTriggerTime", &a->StartTriggerTime, "xsd:int"))
				{	soap_flag_StartTriggerTime--;
					continue;
				}
			if (soap_flag_EndTriggerTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:EndTriggerTime", &a->EndTriggerTime, "xsd:int"))
				{	soap_flag_EndTriggerTime--;
					continue;
				}
			if (soap_flag_RowGranularity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:RowGranularity", &a->RowGranularity, "xsd:int"))
				{	soap_flag_RowGranularity--;
					continue;
				}
			if (soap_flag_ColumnGranularity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ColumnGranularity", &a->ColumnGranularity, "xsd:int"))
				{	soap_flag_ColumnGranularity--;
					continue;
				}
			if (soap_flag_Grid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VMDGrid(soap, "ns1:Grid", &a->Grid, "ns1:VMDGrid"))
				{	soap_flag_Grid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getVMDParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getVMDParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getVMDParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getVMDParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getVMDParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVMDParamRes, 0, sizeof(struct _ns1__getVMDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVMDParamRes(struct soap *soap, const struct _ns1__getVMDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVMDParamRes);
	if (soap_out__ns1__getVMDParamRes(soap, tag?tag:"ns1:getVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes * SOAP_FMAC4 soap_get__ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVMDParamReq_Any(struct soap *soap, struct _ns1__getVMDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVMDParamReq_Any(struct soap *soap, const struct _ns1__getVMDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVMDParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getVMDParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVMDParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq_Any * SOAP_FMAC4 soap_in__ns1__getVMDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getVMDParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVMDParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVMDParamReq_Any, sizeof(struct _ns1__getVMDParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVMDParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVMDParamReq_Any, 0, sizeof(struct _ns1__getVMDParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVMDParamReq_Any(struct soap *soap, const struct _ns1__getVMDParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVMDParamReq_Any);
	if (soap_out__ns1__getVMDParamReq_Any(soap, tag?tag:"ns1:getVMDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq_Any * SOAP_FMAC4 soap_get__ns1__getVMDParamReq_Any(struct soap *soap, struct _ns1__getVMDParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVMDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVMDParamReq(struct soap *soap, const struct _ns1__getVMDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getVMDParamReq_Any);
			soap_serialize__ns1__getVMDParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVMDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getVMDParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVMDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getVMDParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq * SOAP_FMAC4 soap_in__ns1__getVMDParamReq(struct soap *soap, const char *tag, struct _ns1__getVMDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVMDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVMDParamReq, sizeof(struct _ns1__getVMDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVMDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getVMDParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getVMDParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getVMDParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getVMDParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getVMDParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVMDParamReq, 0, sizeof(struct _ns1__getVMDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVMDParamReq(struct soap *soap, const struct _ns1__getVMDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVMDParamReq);
	if (soap_out__ns1__getVMDParamReq(soap, tag?tag:"ns1:getVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq * SOAP_FMAC4 soap_get__ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setTimeRes_Any(struct soap *soap, struct _ns1__setTimeRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setTimeRes_Any(struct soap *soap, const struct _ns1__setTimeRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setTimeRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setTimeRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setTimeRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setTimeRes_Any * SOAP_FMAC4 soap_in__ns1__setTimeRes_Any(struct soap *soap, const char *tag, struct _ns1__setTimeRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setTimeRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setTimeRes_Any, sizeof(struct _ns1__setTimeRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setTimeRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setTimeRes_Any, 0, sizeof(struct _ns1__setTimeRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setTimeRes_Any(struct soap *soap, const struct _ns1__setTimeRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setTimeRes_Any);
	if (soap_out__ns1__setTimeRes_Any(soap, tag?tag:"ns1:setTimeRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeRes_Any * SOAP_FMAC4 soap_get__ns1__setTimeRes_Any(struct soap *soap, struct _ns1__setTimeRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setTimeRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setTimeRes(struct soap *soap, const struct _ns1__setTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setTimeRes_Any);
			soap_serialize__ns1__setTimeRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setTimeRes(struct soap *soap, const char *tag, int id, const struct _ns1__setTimeRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setTimeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setTimeRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setTimeRes * SOAP_FMAC4 soap_in__ns1__setTimeRes(struct soap *soap, const char *tag, struct _ns1__setTimeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setTimeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setTimeRes, sizeof(struct _ns1__setTimeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setTimeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setTimeRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setTimeRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setTimeRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setTimeRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setTimeRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setTimeRes, 0, sizeof(struct _ns1__setTimeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setTimeRes(struct soap *soap, const struct _ns1__setTimeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setTimeRes);
	if (soap_out__ns1__setTimeRes(soap, tag?tag:"ns1:setTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeRes * SOAP_FMAC4 soap_get__ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setTimeReq_Any(struct soap *soap, struct _ns1__setTimeReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setTimeReq_Any(struct soap *soap, const struct _ns1__setTimeReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setTimeReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setTimeReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setTimeReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setTimeReq_Any * SOAP_FMAC4 soap_in__ns1__setTimeReq_Any(struct soap *soap, const char *tag, struct _ns1__setTimeReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setTimeReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setTimeReq_Any, sizeof(struct _ns1__setTimeReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setTimeReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setTimeReq_Any, 0, sizeof(struct _ns1__setTimeReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setTimeReq_Any(struct soap *soap, const struct _ns1__setTimeReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setTimeReq_Any);
	if (soap_out__ns1__setTimeReq_Any(soap, tag?tag:"ns1:setTimeReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeReq_Any * SOAP_FMAC4 soap_get__ns1__setTimeReq_Any(struct soap *soap, struct _ns1__setTimeReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setTimeReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->Time = NULL;
	soap_default_string(soap, &a->TimeZone);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setTimeReq(struct soap *soap, const struct _ns1__setTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerTotime(soap, &a->Time);
	soap_serialize_string(soap, &a->TimeZone);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setTimeReq_Any);
			soap_serialize__ns1__setTimeReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setTimeReq(struct soap *soap, const char *tag, int id, const struct _ns1__setTimeReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setTimeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setTimeReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setTimeReq * SOAP_FMAC4 soap_in__ns1__setTimeReq(struct soap *soap, const char *tag, struct _ns1__setTimeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_TimeZone = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setTimeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setTimeReq, sizeof(struct _ns1__setTimeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setTimeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_TimeZone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TimeZone", &a->TimeZone, "xsd:string"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setTimeReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setTimeReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setTimeReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setTimeReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setTimeReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setTimeReq, 0, sizeof(struct _ns1__setTimeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setTimeReq(struct soap *soap, const struct _ns1__setTimeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setTimeReq);
	if (soap_out__ns1__setTimeReq(soap, tag?tag:"ns1:setTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeReq * SOAP_FMAC4 soap_get__ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getTimeRes_Any(struct soap *soap, struct _ns1__getTimeRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getTimeRes_Any(struct soap *soap, const struct _ns1__getTimeRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimeRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getTimeRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimeRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getTimeRes_Any * SOAP_FMAC4 soap_in__ns1__getTimeRes_Any(struct soap *soap, const char *tag, struct _ns1__getTimeRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getTimeRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimeRes_Any, sizeof(struct _ns1__getTimeRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getTimeRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTimeRes_Any, 0, sizeof(struct _ns1__getTimeRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getTimeRes_Any(struct soap *soap, const struct _ns1__getTimeRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getTimeRes_Any);
	if (soap_out__ns1__getTimeRes_Any(soap, tag?tag:"ns1:getTimeRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeRes_Any * SOAP_FMAC4 soap_get__ns1__getTimeRes_Any(struct soap *soap, struct _ns1__getTimeRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimeRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Time = NULL;
	soap_default_string(soap, &a->TimeZone);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getTimeRes(struct soap *soap, const struct _ns1__getTimeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &a->Time);
	soap_serialize_string(soap, &a->TimeZone);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getTimeRes_Any);
			soap_serialize__ns1__getTimeRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimeRes(struct soap *soap, const char *tag, int id, const struct _ns1__getTimeRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Time", -1, &a->Time, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getTimeRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getTimeRes * SOAP_FMAC4 soap_in__ns1__getTimeRes(struct soap *soap, const char *tag, struct _ns1__getTimeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_TimeZone = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getTimeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimeRes, sizeof(struct _ns1__getTimeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getTimeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_TimeZone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:TimeZone", &a->TimeZone, "xsd:string"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getTimeRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getTimeRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getTimeRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getTimeRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getTimeRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTimeRes, 0, sizeof(struct _ns1__getTimeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getTimeRes(struct soap *soap, const struct _ns1__getTimeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getTimeRes);
	if (soap_out__ns1__getTimeRes(soap, tag?tag:"ns1:getTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeRes * SOAP_FMAC4 soap_get__ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getTimeReq_Any(struct soap *soap, struct _ns1__getTimeReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getTimeReq_Any(struct soap *soap, const struct _ns1__getTimeReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimeReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getTimeReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimeReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getTimeReq_Any * SOAP_FMAC4 soap_in__ns1__getTimeReq_Any(struct soap *soap, const char *tag, struct _ns1__getTimeReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getTimeReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimeReq_Any, sizeof(struct _ns1__getTimeReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getTimeReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTimeReq_Any, 0, sizeof(struct _ns1__getTimeReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getTimeReq_Any(struct soap *soap, const struct _ns1__getTimeReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getTimeReq_Any);
	if (soap_out__ns1__getTimeReq_Any(soap, tag?tag:"ns1:getTimeReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeReq_Any * SOAP_FMAC4 soap_get__ns1__getTimeReq_Any(struct soap *soap, struct _ns1__getTimeReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimeReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getTimeReq(struct soap *soap, const struct _ns1__getTimeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getTimeReq_Any);
			soap_serialize__ns1__getTimeReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getTimeReq(struct soap *soap, const char *tag, int id, const struct _ns1__getTimeReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getTimeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getTimeReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getTimeReq * SOAP_FMAC4 soap_in__ns1__getTimeReq(struct soap *soap, const char *tag, struct _ns1__getTimeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getTimeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getTimeReq, sizeof(struct _ns1__getTimeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getTimeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getTimeReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getTimeReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getTimeReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getTimeReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getTimeReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getTimeReq, 0, sizeof(struct _ns1__getTimeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getTimeReq(struct soap *soap, const struct _ns1__getTimeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getTimeReq);
	if (soap_out__ns1__getTimeReq(soap, tag?tag:"ns1:getTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeReq * SOAP_FMAC4 soap_get__ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setOSDParamRes_Any(struct soap *soap, struct _ns1__setOSDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setOSDParamRes_Any(struct soap *soap, const struct _ns1__setOSDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setOSDParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setOSDParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setOSDParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes_Any * SOAP_FMAC4 soap_in__ns1__setOSDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setOSDParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setOSDParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setOSDParamRes_Any, sizeof(struct _ns1__setOSDParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setOSDParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setOSDParamRes_Any, 0, sizeof(struct _ns1__setOSDParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setOSDParamRes_Any(struct soap *soap, const struct _ns1__setOSDParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setOSDParamRes_Any);
	if (soap_out__ns1__setOSDParamRes_Any(soap, tag?tag:"ns1:setOSDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes_Any * SOAP_FMAC4 soap_get__ns1__setOSDParamRes_Any(struct soap *soap, struct _ns1__setOSDParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setOSDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setOSDParamRes(struct soap *soap, const struct _ns1__setOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setOSDParamRes_Any);
			soap_serialize__ns1__setOSDParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setOSDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setOSDParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setOSDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setOSDParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes * SOAP_FMAC4 soap_in__ns1__setOSDParamRes(struct soap *soap, const char *tag, struct _ns1__setOSDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setOSDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setOSDParamRes, sizeof(struct _ns1__setOSDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setOSDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setOSDParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setOSDParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setOSDParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setOSDParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setOSDParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setOSDParamRes, 0, sizeof(struct _ns1__setOSDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setOSDParamRes(struct soap *soap, const struct _ns1__setOSDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setOSDParamRes);
	if (soap_out__ns1__setOSDParamRes(soap, tag?tag:"ns1:setOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes * SOAP_FMAC4 soap_get__ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setOSDParamReq_Any(struct soap *soap, struct _ns1__setOSDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setOSDParamReq_Any(struct soap *soap, const struct _ns1__setOSDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setOSDParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setOSDParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setOSDParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq_Any * SOAP_FMAC4 soap_in__ns1__setOSDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setOSDParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setOSDParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setOSDParamReq_Any, sizeof(struct _ns1__setOSDParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setOSDParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setOSDParamReq_Any, 0, sizeof(struct _ns1__setOSDParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setOSDParamReq_Any(struct soap *soap, const struct _ns1__setOSDParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setOSDParamReq_Any);
	if (soap_out__ns1__setOSDParamReq_Any(soap, tag?tag:"ns1:setOSDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq_Any * SOAP_FMAC4 soap_get__ns1__setOSDParamReq_Any(struct soap *soap, struct _ns1__setOSDParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setOSDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->Enabled = NULL;
	a->TimestampEnabled = NULL;
	soap_default_string(soap, &a->DateTimeFormat);
	soap_default_string(soap, &a->DisplayText);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->TextPositionX = NULL;
	a->TextPositionY = NULL;
	a->TimestampPositionX = NULL;
	a->TimestampPositionY = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setOSDParamReq(struct soap *soap, const struct _ns1__setOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean(soap, &a->TimestampEnabled);
	soap_serialize_string(soap, &a->DateTimeFormat);
	soap_serialize_string(soap, &a->DisplayText);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerToint(soap, &a->FontColor);
	soap_serialize_PointerToint(soap, &a->TextPositionX);
	soap_serialize_PointerToint(soap, &a->TextPositionY);
	soap_serialize_PointerToint(soap, &a->TimestampPositionX);
	soap_serialize_PointerToint(soap, &a->TimestampPositionY);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setOSDParamReq_Any);
			soap_serialize__ns1__setOSDParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setOSDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setOSDParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setOSDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", -1, &a->TimestampEnabled, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DateTimeFormat", -1, &a->DateTimeFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DisplayText", -1, &a->DisplayText, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionX", -1, &a->TextPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionY", -1, &a->TextPositionY, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionX", -1, &a->TimestampPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionY", -1, &a->TimestampPositionY, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setOSDParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq * SOAP_FMAC4 soap_in__ns1__setOSDParamReq(struct soap *soap, const char *tag, struct _ns1__setOSDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_TimestampEnabled = 1;
	size_t soap_flag_DateTimeFormat = 1;
	size_t soap_flag_DisplayText = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_TextPositionX = 1;
	size_t soap_flag_TextPositionY = 1;
	size_t soap_flag_TimestampPositionX = 1;
	size_t soap_flag_TimestampPositionY = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setOSDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setOSDParamReq, sizeof(struct _ns1__setOSDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setOSDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_TimestampEnabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", &a->TimestampEnabled, "xsd:boolean"))
				{	soap_flag_TimestampEnabled--;
					continue;
				}
			if (soap_flag_DateTimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DateTimeFormat", &a->DateTimeFormat, "xsd:string"))
				{	soap_flag_DateTimeFormat--;
					continue;
				}
			if (soap_flag_DisplayText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DisplayText", &a->DisplayText, "xsd:string"))
				{	soap_flag_DisplayText--;
					continue;
				}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontColor", &a->FontColor, "xsd:int"))
				{	soap_flag_FontColor--;
					continue;
				}
			if (soap_flag_TextPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionX", &a->TextPositionX, "xsd:int"))
				{	soap_flag_TextPositionX--;
					continue;
				}
			if (soap_flag_TextPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionY", &a->TextPositionY, "xsd:int"))
				{	soap_flag_TextPositionY--;
					continue;
				}
			if (soap_flag_TimestampPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionX", &a->TimestampPositionX, "xsd:int"))
				{	soap_flag_TimestampPositionX--;
					continue;
				}
			if (soap_flag_TimestampPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionY", &a->TimestampPositionY, "xsd:int"))
				{	soap_flag_TimestampPositionY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setOSDParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setOSDParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setOSDParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setOSDParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setOSDParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setOSDParamReq, 0, sizeof(struct _ns1__setOSDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setOSDParamReq(struct soap *soap, const struct _ns1__setOSDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setOSDParamReq);
	if (soap_out__ns1__setOSDParamReq(soap, tag?tag:"ns1:setOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq * SOAP_FMAC4 soap_get__ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getOSDParamRes_Any(struct soap *soap, struct _ns1__getOSDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getOSDParamRes_Any(struct soap *soap, const struct _ns1__getOSDParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOSDParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getOSDParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOSDParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes_Any * SOAP_FMAC4 soap_in__ns1__getOSDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getOSDParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getOSDParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOSDParamRes_Any, sizeof(struct _ns1__getOSDParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getOSDParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOSDParamRes_Any, 0, sizeof(struct _ns1__getOSDParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getOSDParamRes_Any(struct soap *soap, const struct _ns1__getOSDParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getOSDParamRes_Any);
	if (soap_out__ns1__getOSDParamRes_Any(soap, tag?tag:"ns1:getOSDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes_Any * SOAP_FMAC4 soap_get__ns1__getOSDParamRes_Any(struct soap *soap, struct _ns1__getOSDParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOSDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->Enabled = NULL;
	a->TimestampEnabled = NULL;
	soap_default_string(soap, &a->DateTimeFormat);
	soap_default_string(soap, &a->DisplayText);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->TextPositionX = NULL;
	a->TextPositionY = NULL;
	a->TimestampPositionX = NULL;
	a->TimestampPositionY = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getOSDParamRes(struct soap *soap, const struct _ns1__getOSDParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean(soap, &a->TimestampEnabled);
	soap_serialize_string(soap, &a->DateTimeFormat);
	soap_serialize_string(soap, &a->DisplayText);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerToint(soap, &a->FontColor);
	soap_serialize_PointerToint(soap, &a->TextPositionX);
	soap_serialize_PointerToint(soap, &a->TextPositionY);
	soap_serialize_PointerToint(soap, &a->TimestampPositionX);
	soap_serialize_PointerToint(soap, &a->TimestampPositionY);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getOSDParamRes_Any);
			soap_serialize__ns1__getOSDParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOSDParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getOSDParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOSDParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", -1, &a->TimestampEnabled, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DateTimeFormat", -1, &a->DateTimeFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DisplayText", -1, &a->DisplayText, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionX", -1, &a->TextPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TextPositionY", -1, &a->TextPositionY, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionX", -1, &a->TimestampPositionX, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:TimestampPositionY", -1, &a->TimestampPositionY, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getOSDParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes * SOAP_FMAC4 soap_in__ns1__getOSDParamRes(struct soap *soap, const char *tag, struct _ns1__getOSDParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_TimestampEnabled = 1;
	size_t soap_flag_DateTimeFormat = 1;
	size_t soap_flag_DisplayText = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_TextPositionX = 1;
	size_t soap_flag_TextPositionY = 1;
	size_t soap_flag_TimestampPositionX = 1;
	size_t soap_flag_TimestampPositionY = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getOSDParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOSDParamRes, sizeof(struct _ns1__getOSDParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getOSDParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_TimestampEnabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:TimestampEnabled", &a->TimestampEnabled, "xsd:boolean"))
				{	soap_flag_TimestampEnabled--;
					continue;
				}
			if (soap_flag_DateTimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DateTimeFormat", &a->DateTimeFormat, "xsd:string"))
				{	soap_flag_DateTimeFormat--;
					continue;
				}
			if (soap_flag_DisplayText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DisplayText", &a->DisplayText, "xsd:string"))
				{	soap_flag_DisplayText--;
					continue;
				}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FontColor", &a->FontColor, "xsd:int"))
				{	soap_flag_FontColor--;
					continue;
				}
			if (soap_flag_TextPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionX", &a->TextPositionX, "xsd:int"))
				{	soap_flag_TextPositionX--;
					continue;
				}
			if (soap_flag_TextPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TextPositionY", &a->TextPositionY, "xsd:int"))
				{	soap_flag_TextPositionY--;
					continue;
				}
			if (soap_flag_TimestampPositionX && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionX", &a->TimestampPositionX, "xsd:int"))
				{	soap_flag_TimestampPositionX--;
					continue;
				}
			if (soap_flag_TimestampPositionY && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:TimestampPositionY", &a->TimestampPositionY, "xsd:int"))
				{	soap_flag_TimestampPositionY--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getOSDParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getOSDParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getOSDParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getOSDParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getOSDParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOSDParamRes, 0, sizeof(struct _ns1__getOSDParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getOSDParamRes(struct soap *soap, const struct _ns1__getOSDParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getOSDParamRes);
	if (soap_out__ns1__getOSDParamRes(soap, tag?tag:"ns1:getOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes * SOAP_FMAC4 soap_get__ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getOSDParamReq_Any(struct soap *soap, struct _ns1__getOSDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getOSDParamReq_Any(struct soap *soap, const struct _ns1__getOSDParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOSDParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getOSDParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOSDParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq_Any * SOAP_FMAC4 soap_in__ns1__getOSDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getOSDParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getOSDParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOSDParamReq_Any, sizeof(struct _ns1__getOSDParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getOSDParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOSDParamReq_Any, 0, sizeof(struct _ns1__getOSDParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getOSDParamReq_Any(struct soap *soap, const struct _ns1__getOSDParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getOSDParamReq_Any);
	if (soap_out__ns1__getOSDParamReq_Any(soap, tag?tag:"ns1:getOSDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq_Any * SOAP_FMAC4 soap_get__ns1__getOSDParamReq_Any(struct soap *soap, struct _ns1__getOSDParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOSDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getOSDParamReq(struct soap *soap, const struct _ns1__getOSDParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getOSDParamReq_Any);
			soap_serialize__ns1__getOSDParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getOSDParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getOSDParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getOSDParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getOSDParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq * SOAP_FMAC4 soap_in__ns1__getOSDParamReq(struct soap *soap, const char *tag, struct _ns1__getOSDParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getOSDParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getOSDParamReq, sizeof(struct _ns1__getOSDParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getOSDParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getOSDParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getOSDParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getOSDParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getOSDParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getOSDParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getOSDParamReq, 0, sizeof(struct _ns1__getOSDParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getOSDParamReq(struct soap *soap, const struct _ns1__getOSDParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getOSDParamReq);
	if (soap_out__ns1__getOSDParamReq(soap, tag?tag:"ns1:getOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq * SOAP_FMAC4 soap_get__ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVideoParamRes_Any(struct soap *soap, struct _ns1__setVideoParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVideoParamRes_Any(struct soap *soap, const struct _ns1__setVideoParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVideoParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setVideoParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVideoParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes_Any * SOAP_FMAC4 soap_in__ns1__setVideoParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setVideoParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVideoParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVideoParamRes_Any, sizeof(struct _ns1__setVideoParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVideoParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVideoParamRes_Any, 0, sizeof(struct _ns1__setVideoParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVideoParamRes_Any(struct soap *soap, const struct _ns1__setVideoParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVideoParamRes_Any);
	if (soap_out__ns1__setVideoParamRes_Any(soap, tag?tag:"ns1:setVideoParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes_Any * SOAP_FMAC4 soap_get__ns1__setVideoParamRes_Any(struct soap *soap, struct _ns1__setVideoParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVideoParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVideoParamRes(struct soap *soap, const struct _ns1__setVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setVideoParamRes_Any);
			soap_serialize__ns1__setVideoParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVideoParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setVideoParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVideoParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setVideoParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes * SOAP_FMAC4 soap_in__ns1__setVideoParamRes(struct soap *soap, const char *tag, struct _ns1__setVideoParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVideoParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVideoParamRes, sizeof(struct _ns1__setVideoParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVideoParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setVideoParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setVideoParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setVideoParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setVideoParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setVideoParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVideoParamRes, 0, sizeof(struct _ns1__setVideoParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVideoParamRes(struct soap *soap, const struct _ns1__setVideoParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVideoParamRes);
	if (soap_out__ns1__setVideoParamRes(soap, tag?tag:"ns1:setVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes * SOAP_FMAC4 soap_get__ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVideoParamReq_Any(struct soap *soap, struct _ns1__setVideoParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVideoParamReq_Any(struct soap *soap, const struct _ns1__setVideoParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVideoParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setVideoParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVideoParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq_Any * SOAP_FMAC4 soap_in__ns1__setVideoParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setVideoParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVideoParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVideoParamReq_Any, sizeof(struct _ns1__setVideoParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVideoParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVideoParamReq_Any, 0, sizeof(struct _ns1__setVideoParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVideoParamReq_Any(struct soap *soap, const struct _ns1__setVideoParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVideoParamReq_Any);
	if (soap_out__ns1__setVideoParamReq_Any(soap, tag?tag:"ns1:setVideoParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq_Any * SOAP_FMAC4 soap_get__ns1__setVideoParamReq_Any(struct soap *soap, struct _ns1__setVideoParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVideoParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->VideoStandard = NULL;
	a->RotationDegree = NULL;
	a->Brightness = NULL;
	a->Contrast = NULL;
	a->Saturation = NULL;
	a->Hue = NULL;
	a->Infrared = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setVideoParamReq(struct soap *soap, const struct _ns1__setVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerTons1__VideoStandard(soap, &a->VideoStandard);
	soap_serialize_PointerToint(soap, &a->RotationDegree);
	soap_serialize_PointerToint(soap, &a->Brightness);
	soap_serialize_PointerToint(soap, &a->Contrast);
	soap_serialize_PointerToint(soap, &a->Saturation);
	soap_serialize_PointerToint(soap, &a->Hue);
	soap_serialize_PointerToxsd__boolean(soap, &a->Infrared);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setVideoParamReq_Any);
			soap_serialize__ns1__setVideoParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setVideoParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setVideoParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setVideoParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", -1, &a->VideoStandard, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:RotationDegree", -1, &a->RotationDegree, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Saturation", -1, &a->Saturation, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Hue", -1, &a->Hue, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Infrared", -1, &a->Infrared, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setVideoParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq * SOAP_FMAC4 soap_in__ns1__setVideoParamReq(struct soap *soap, const char *tag, struct _ns1__setVideoParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_VideoStandard = 1;
	size_t soap_flag_RotationDegree = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Saturation = 1;
	size_t soap_flag_Hue = 1;
	size_t soap_flag_Infrared = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setVideoParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setVideoParamReq, sizeof(struct _ns1__setVideoParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setVideoParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_VideoStandard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", &a->VideoStandard, "ns1:VideoStandard"))
				{	soap_flag_VideoStandard--;
					continue;
				}
			if (soap_flag_RotationDegree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:RotationDegree", &a->RotationDegree, "xsd:int"))
				{	soap_flag_RotationDegree--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Brightness", &a->Brightness, "xsd:int"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Contrast", &a->Contrast, "xsd:int"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Saturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Saturation", &a->Saturation, "xsd:int"))
				{	soap_flag_Saturation--;
					continue;
				}
			if (soap_flag_Hue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Hue", &a->Hue, "xsd:int"))
				{	soap_flag_Hue--;
					continue;
				}
			if (soap_flag_Infrared && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Infrared", &a->Infrared, "xsd:boolean"))
				{	soap_flag_Infrared--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setVideoParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setVideoParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setVideoParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setVideoParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setVideoParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setVideoParamReq, 0, sizeof(struct _ns1__setVideoParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setVideoParamReq(struct soap *soap, const struct _ns1__setVideoParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setVideoParamReq);
	if (soap_out__ns1__setVideoParamReq(soap, tag?tag:"ns1:setVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq * SOAP_FMAC4 soap_get__ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVideoParamRes_Any(struct soap *soap, struct _ns1__getVideoParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVideoParamRes_Any(struct soap *soap, const struct _ns1__getVideoParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVideoParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getVideoParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVideoParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes_Any * SOAP_FMAC4 soap_in__ns1__getVideoParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getVideoParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVideoParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVideoParamRes_Any, sizeof(struct _ns1__getVideoParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVideoParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVideoParamRes_Any, 0, sizeof(struct _ns1__getVideoParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVideoParamRes_Any(struct soap *soap, const struct _ns1__getVideoParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVideoParamRes_Any);
	if (soap_out__ns1__getVideoParamRes_Any(soap, tag?tag:"ns1:getVideoParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes_Any * SOAP_FMAC4 soap_get__ns1__getVideoParamRes_Any(struct soap *soap, struct _ns1__getVideoParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVideoParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->VideoStandard = NULL;
	a->RotationDegree = NULL;
	a->Brightness = NULL;
	a->Contrast = NULL;
	a->Saturation = NULL;
	a->Hue = NULL;
	a->Infrared = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVideoParamRes(struct soap *soap, const struct _ns1__getVideoParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VideoStandard(soap, &a->VideoStandard);
	soap_serialize_PointerToint(soap, &a->RotationDegree);
	soap_serialize_PointerToint(soap, &a->Brightness);
	soap_serialize_PointerToint(soap, &a->Contrast);
	soap_serialize_PointerToint(soap, &a->Saturation);
	soap_serialize_PointerToint(soap, &a->Hue);
	soap_serialize_PointerToxsd__boolean(soap, &a->Infrared);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getVideoParamRes_Any);
			soap_serialize__ns1__getVideoParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVideoParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getVideoParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVideoParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", -1, &a->VideoStandard, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:RotationDegree", -1, &a->RotationDegree, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Saturation", -1, &a->Saturation, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Hue", -1, &a->Hue, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:Infrared", -1, &a->Infrared, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getVideoParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes * SOAP_FMAC4 soap_in__ns1__getVideoParamRes(struct soap *soap, const char *tag, struct _ns1__getVideoParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_VideoStandard = 1;
	size_t soap_flag_RotationDegree = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Saturation = 1;
	size_t soap_flag_Hue = 1;
	size_t soap_flag_Infrared = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVideoParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVideoParamRes, sizeof(struct _ns1__getVideoParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVideoParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_VideoStandard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VideoStandard(soap, "ns1:VideoStandard", &a->VideoStandard, "ns1:VideoStandard"))
				{	soap_flag_VideoStandard--;
					continue;
				}
			if (soap_flag_RotationDegree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:RotationDegree", &a->RotationDegree, "xsd:int"))
				{	soap_flag_RotationDegree--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Brightness", &a->Brightness, "xsd:int"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Contrast", &a->Contrast, "xsd:int"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Saturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Saturation", &a->Saturation, "xsd:int"))
				{	soap_flag_Saturation--;
					continue;
				}
			if (soap_flag_Hue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Hue", &a->Hue, "xsd:int"))
				{	soap_flag_Hue--;
					continue;
				}
			if (soap_flag_Infrared && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:Infrared", &a->Infrared, "xsd:boolean"))
				{	soap_flag_Infrared--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getVideoParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getVideoParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getVideoParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getVideoParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getVideoParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVideoParamRes, 0, sizeof(struct _ns1__getVideoParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVideoParamRes(struct soap *soap, const struct _ns1__getVideoParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVideoParamRes);
	if (soap_out__ns1__getVideoParamRes(soap, tag?tag:"ns1:getVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes * SOAP_FMAC4 soap_get__ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVideoParamReq_Any(struct soap *soap, struct _ns1__getVideoParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVideoParamReq_Any(struct soap *soap, const struct _ns1__getVideoParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVideoParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getVideoParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVideoParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq_Any * SOAP_FMAC4 soap_in__ns1__getVideoParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getVideoParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVideoParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVideoParamReq_Any, sizeof(struct _ns1__getVideoParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVideoParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVideoParamReq_Any, 0, sizeof(struct _ns1__getVideoParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVideoParamReq_Any(struct soap *soap, const struct _ns1__getVideoParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVideoParamReq_Any);
	if (soap_out__ns1__getVideoParamReq_Any(soap, tag?tag:"ns1:getVideoParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq_Any * SOAP_FMAC4 soap_get__ns1__getVideoParamReq_Any(struct soap *soap, struct _ns1__getVideoParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVideoParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getVideoParamReq(struct soap *soap, const struct _ns1__getVideoParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getVideoParamReq_Any);
			soap_serialize__ns1__getVideoParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getVideoParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getVideoParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getVideoParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getVideoParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq * SOAP_FMAC4 soap_in__ns1__getVideoParamReq(struct soap *soap, const char *tag, struct _ns1__getVideoParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getVideoParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getVideoParamReq, sizeof(struct _ns1__getVideoParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getVideoParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getVideoParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getVideoParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getVideoParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getVideoParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getVideoParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getVideoParamReq, 0, sizeof(struct _ns1__getVideoParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getVideoParamReq(struct soap *soap, const struct _ns1__getVideoParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getVideoParamReq);
	if (soap_out__ns1__getVideoParamReq(soap, tag?tag:"ns1:getVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq * SOAP_FMAC4 soap_get__ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDevLogRes_Any(struct soap *soap, struct _ns1__queryDevLogRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDevLogRes_Any(struct soap *soap, const struct _ns1__queryDevLogRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDevLogRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__queryDevLogRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDevLogRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes_Any * SOAP_FMAC4 soap_in__ns1__queryDevLogRes_Any(struct soap *soap, const char *tag, struct _ns1__queryDevLogRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDevLogRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDevLogRes_Any, sizeof(struct _ns1__queryDevLogRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDevLogRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDevLogRes_Any, 0, sizeof(struct _ns1__queryDevLogRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDevLogRes_Any(struct soap *soap, const struct _ns1__queryDevLogRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDevLogRes_Any);
	if (soap_out__ns1__queryDevLogRes_Any(soap, tag?tag:"ns1:queryDevLogRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes_Any * SOAP_FMAC4 soap_get__ns1__queryDevLogRes_Any(struct soap *soap, struct _ns1__queryDevLogRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDevLogRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->DevLog = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDevLogRes(struct soap *soap, const struct _ns1__queryDevLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfDevLog(soap, &a->DevLog);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__queryDevLogRes_Any);
			soap_serialize__ns1__queryDevLogRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDevLogRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDevLogRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDevLogRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDevLog(soap, "ns1:DevLog", -1, &a->DevLog, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__queryDevLogRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes * SOAP_FMAC4 soap_in__ns1__queryDevLogRes(struct soap *soap, const char *tag, struct _ns1__queryDevLogRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_DevLog = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDevLogRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDevLogRes, sizeof(struct _ns1__queryDevLogRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDevLogRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_DevLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDevLog(soap, "ns1:DevLog", &a->DevLog, "ns1:ArrayOfDevLog"))
				{	soap_flag_DevLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__queryDevLogRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__queryDevLogRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__queryDevLogRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__queryDevLogRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__queryDevLogRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDevLogRes, 0, sizeof(struct _ns1__queryDevLogRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDevLogRes(struct soap *soap, const struct _ns1__queryDevLogRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDevLogRes);
	if (soap_out__ns1__queryDevLogRes(soap, tag?tag:"ns1:queryDevLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes * SOAP_FMAC4 soap_get__ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDevLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDevLogReq_Any(struct soap *soap, struct _ns1__queryDevLogReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDevLogReq_Any(struct soap *soap, const struct _ns1__queryDevLogReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDevLogReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__queryDevLogReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDevLogReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq_Any * SOAP_FMAC4 soap_in__ns1__queryDevLogReq_Any(struct soap *soap, const char *tag, struct _ns1__queryDevLogReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDevLogReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDevLogReq_Any, sizeof(struct _ns1__queryDevLogReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDevLogReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDevLogReq_Any, 0, sizeof(struct _ns1__queryDevLogReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDevLogReq_Any(struct soap *soap, const struct _ns1__queryDevLogReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDevLogReq_Any);
	if (soap_out__ns1__queryDevLogReq_Any(soap, tag?tag:"ns1:queryDevLogReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq_Any * SOAP_FMAC4 soap_get__ns1__queryDevLogReq_Any(struct soap *soap, struct _ns1__queryDevLogReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDevLogReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	soap_default_int(soap, &a->MaxResult);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDevLogReq(struct soap *soap, const struct _ns1__queryDevLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->MaxResult, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__queryDevLogReq_Any);
			soap_serialize__ns1__queryDevLogReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDevLogReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDevLogReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDevLogReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:MaxResult", -1, &a->MaxResult, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__queryDevLogReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq * SOAP_FMAC4 soap_in__ns1__queryDevLogReq(struct soap *soap, const char *tag, struct _ns1__queryDevLogReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_MaxResult = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDevLogReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDevLogReq, sizeof(struct _ns1__queryDevLogReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDevLogReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_MaxResult && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:MaxResult", &a->MaxResult, "xsd:int"))
				{	soap_flag_MaxResult--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__queryDevLogReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__queryDevLogReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__queryDevLogReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__queryDevLogReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__queryDevLogReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDevLogReq, 0, sizeof(struct _ns1__queryDevLogReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_EndTime > 0 || soap_flag_MaxResult > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDevLogReq(struct soap *soap, const struct _ns1__queryDevLogReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDevLogReq);
	if (soap_out__ns1__queryDevLogReq(soap, tag?tag:"ns1:queryDevLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq * SOAP_FMAC4 soap_get__ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDevLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryLogRes_Any(struct soap *soap, struct _ns1__queryLogRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryLogRes_Any(struct soap *soap, const struct _ns1__queryLogRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryLogRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__queryLogRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryLogRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryLogRes_Any * SOAP_FMAC4 soap_in__ns1__queryLogRes_Any(struct soap *soap, const char *tag, struct _ns1__queryLogRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryLogRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryLogRes_Any, sizeof(struct _ns1__queryLogRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryLogRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryLogRes_Any, 0, sizeof(struct _ns1__queryLogRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryLogRes_Any(struct soap *soap, const struct _ns1__queryLogRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryLogRes_Any);
	if (soap_out__ns1__queryLogRes_Any(soap, tag?tag:"ns1:queryLogRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogRes_Any * SOAP_FMAC4 soap_get__ns1__queryLogRes_Any(struct soap *soap, struct _ns1__queryLogRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryLogRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->PuLogAll = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryLogRes(struct soap *soap, const struct _ns1__queryLogRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfPuLog(soap, &a->PuLogAll);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__queryLogRes_Any);
			soap_serialize__ns1__queryLogRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryLogRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryLogRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryLogRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfPuLog(soap, "ns1:PuLogAll", -1, &a->PuLogAll, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__queryLogRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryLogRes * SOAP_FMAC4 soap_in__ns1__queryLogRes(struct soap *soap, const char *tag, struct _ns1__queryLogRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_PuLogAll = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryLogRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryLogRes, sizeof(struct _ns1__queryLogRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryLogRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_PuLogAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfPuLog(soap, "ns1:PuLogAll", &a->PuLogAll, "ns1:ArrayOfPuLog"))
				{	soap_flag_PuLogAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__queryLogRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__queryLogRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__queryLogRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__queryLogRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__queryLogRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryLogRes, 0, sizeof(struct _ns1__queryLogRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryLogRes(struct soap *soap, const struct _ns1__queryLogRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryLogRes);
	if (soap_out__ns1__queryLogRes(soap, tag?tag:"ns1:queryLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogRes * SOAP_FMAC4 soap_get__ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryLogReq_Any(struct soap *soap, struct _ns1__queryLogReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryLogReq_Any(struct soap *soap, const struct _ns1__queryLogReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryLogReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__queryLogReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryLogReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryLogReq_Any * SOAP_FMAC4 soap_in__ns1__queryLogReq_Any(struct soap *soap, const char *tag, struct _ns1__queryLogReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryLogReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryLogReq_Any, sizeof(struct _ns1__queryLogReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryLogReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryLogReq_Any, 0, sizeof(struct _ns1__queryLogReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryLogReq_Any(struct soap *soap, const struct _ns1__queryLogReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryLogReq_Any);
	if (soap_out__ns1__queryLogReq_Any(soap, tag?tag:"ns1:queryLogReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogReq_Any * SOAP_FMAC4 soap_get__ns1__queryLogReq_Any(struct soap *soap, struct _ns1__queryLogReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryLogReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryLogReq(struct soap *soap, const struct _ns1__queryLogReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__queryLogReq_Any);
			soap_serialize__ns1__queryLogReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryLogReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryLogReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryLogReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__queryLogReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryLogReq * SOAP_FMAC4 soap_in__ns1__queryLogReq(struct soap *soap, const char *tag, struct _ns1__queryLogReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryLogReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryLogReq, sizeof(struct _ns1__queryLogReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryLogReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__queryLogReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__queryLogReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__queryLogReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__queryLogReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__queryLogReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryLogReq, 0, sizeof(struct _ns1__queryLogReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryLogReq(struct soap *soap, const struct _ns1__queryLogReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryLogReq);
	if (soap_out__ns1__queryLogReq(soap, tag?tag:"ns1:queryLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogReq * SOAP_FMAC4 soap_get__ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__upgradeDevVerRes_Any(struct soap *soap, struct _ns1__upgradeDevVerRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__upgradeDevVerRes_Any(struct soap *soap, const struct _ns1__upgradeDevVerRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upgradeDevVerRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__upgradeDevVerRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upgradeDevVerRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes_Any * SOAP_FMAC4 soap_in__ns1__upgradeDevVerRes_Any(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__upgradeDevVerRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upgradeDevVerRes_Any, sizeof(struct _ns1__upgradeDevVerRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__upgradeDevVerRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upgradeDevVerRes_Any, 0, sizeof(struct _ns1__upgradeDevVerRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__upgradeDevVerRes_Any(struct soap *soap, const struct _ns1__upgradeDevVerRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__upgradeDevVerRes_Any);
	if (soap_out__ns1__upgradeDevVerRes_Any(soap, tag?tag:"ns1:upgradeDevVerRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes_Any * SOAP_FMAC4 soap_get__ns1__upgradeDevVerRes_Any(struct soap *soap, struct _ns1__upgradeDevVerRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upgradeDevVerRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__upgradeDevVerRes(struct soap *soap, const struct _ns1__upgradeDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__upgradeDevVerRes_Any);
			soap_serialize__ns1__upgradeDevVerRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upgradeDevVerRes(struct soap *soap, const char *tag, int id, const struct _ns1__upgradeDevVerRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upgradeDevVerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__upgradeDevVerRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes * SOAP_FMAC4 soap_in__ns1__upgradeDevVerRes(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__upgradeDevVerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upgradeDevVerRes, sizeof(struct _ns1__upgradeDevVerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__upgradeDevVerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__upgradeDevVerRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__upgradeDevVerRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__upgradeDevVerRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__upgradeDevVerRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__upgradeDevVerRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upgradeDevVerRes, 0, sizeof(struct _ns1__upgradeDevVerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__upgradeDevVerRes(struct soap *soap, const struct _ns1__upgradeDevVerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__upgradeDevVerRes);
	if (soap_out__ns1__upgradeDevVerRes(soap, tag?tag:"ns1:upgradeDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes * SOAP_FMAC4 soap_get__ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upgradeDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__upgradeDevVerReq_Any(struct soap *soap, struct _ns1__upgradeDevVerReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__upgradeDevVerReq_Any(struct soap *soap, const struct _ns1__upgradeDevVerReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upgradeDevVerReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__upgradeDevVerReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upgradeDevVerReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq_Any * SOAP_FMAC4 soap_in__ns1__upgradeDevVerReq_Any(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__upgradeDevVerReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upgradeDevVerReq_Any, sizeof(struct _ns1__upgradeDevVerReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__upgradeDevVerReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upgradeDevVerReq_Any, 0, sizeof(struct _ns1__upgradeDevVerReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__upgradeDevVerReq_Any(struct soap *soap, const struct _ns1__upgradeDevVerReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__upgradeDevVerReq_Any);
	if (soap_out__ns1__upgradeDevVerReq_Any(soap, tag?tag:"ns1:upgradeDevVerReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq_Any * SOAP_FMAC4 soap_get__ns1__upgradeDevVerReq_Any(struct soap *soap, struct _ns1__upgradeDevVerReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upgradeDevVerReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__upgradeDevVerReq(struct soap *soap, const struct _ns1__upgradeDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__upgradeDevVerReq_Any);
			soap_serialize__ns1__upgradeDevVerReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__upgradeDevVerReq(struct soap *soap, const char *tag, int id, const struct _ns1__upgradeDevVerReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__upgradeDevVerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__upgradeDevVerReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq * SOAP_FMAC4 soap_in__ns1__upgradeDevVerReq(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__upgradeDevVerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__upgradeDevVerReq, sizeof(struct _ns1__upgradeDevVerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__upgradeDevVerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__upgradeDevVerReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__upgradeDevVerReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__upgradeDevVerReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__upgradeDevVerReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__upgradeDevVerReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__upgradeDevVerReq, 0, sizeof(struct _ns1__upgradeDevVerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__upgradeDevVerReq(struct soap *soap, const struct _ns1__upgradeDevVerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__upgradeDevVerReq);
	if (soap_out__ns1__upgradeDevVerReq(soap, tag?tag:"ns1:upgradeDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq * SOAP_FMAC4 soap_get__ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__upgradeDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDevVerRes_Any(struct soap *soap, struct _ns1__getDevVerRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDevVerRes_Any(struct soap *soap, const struct _ns1__getDevVerRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDevVerRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getDevVerRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDevVerRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDevVerRes_Any * SOAP_FMAC4 soap_in__ns1__getDevVerRes_Any(struct soap *soap, const char *tag, struct _ns1__getDevVerRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDevVerRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDevVerRes_Any, sizeof(struct _ns1__getDevVerRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDevVerRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDevVerRes_Any, 0, sizeof(struct _ns1__getDevVerRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDevVerRes_Any(struct soap *soap, const struct _ns1__getDevVerRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDevVerRes_Any);
	if (soap_out__ns1__getDevVerRes_Any(soap, tag?tag:"ns1:getDevVerRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerRes_Any * SOAP_FMAC4 soap_get__ns1__getDevVerRes_Any(struct soap *soap, struct _ns1__getDevVerRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDevVerRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->CurDevVer);
	soap_default_string(soap, &a->NewDevVer);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDevVerRes(struct soap *soap, const struct _ns1__getDevVerRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CurDevVer);
	soap_serialize_string(soap, &a->NewDevVer);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getDevVerRes_Any);
			soap_serialize__ns1__getDevVerRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDevVerRes(struct soap *soap, const char *tag, int id, const struct _ns1__getDevVerRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDevVerRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:CurDevVer", -1, &a->CurDevVer, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NewDevVer", -1, &a->NewDevVer, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getDevVerRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDevVerRes * SOAP_FMAC4 soap_in__ns1__getDevVerRes(struct soap *soap, const char *tag, struct _ns1__getDevVerRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_CurDevVer = 1;
	size_t soap_flag_NewDevVer = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDevVerRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDevVerRes, sizeof(struct _ns1__getDevVerRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDevVerRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_CurDevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:CurDevVer", &a->CurDevVer, "xsd:string"))
				{	soap_flag_CurDevVer--;
					continue;
				}
			if (soap_flag_NewDevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NewDevVer", &a->NewDevVer, "xsd:string"))
				{	soap_flag_NewDevVer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getDevVerRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getDevVerRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getDevVerRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getDevVerRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getDevVerRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDevVerRes, 0, sizeof(struct _ns1__getDevVerRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDevVerRes(struct soap *soap, const struct _ns1__getDevVerRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDevVerRes);
	if (soap_out__ns1__getDevVerRes(soap, tag?tag:"ns1:getDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerRes * SOAP_FMAC4 soap_get__ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDevVerReq_Any(struct soap *soap, struct _ns1__getDevVerReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDevVerReq_Any(struct soap *soap, const struct _ns1__getDevVerReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDevVerReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getDevVerReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDevVerReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDevVerReq_Any * SOAP_FMAC4 soap_in__ns1__getDevVerReq_Any(struct soap *soap, const char *tag, struct _ns1__getDevVerReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDevVerReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDevVerReq_Any, sizeof(struct _ns1__getDevVerReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDevVerReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDevVerReq_Any, 0, sizeof(struct _ns1__getDevVerReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDevVerReq_Any(struct soap *soap, const struct _ns1__getDevVerReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDevVerReq_Any);
	if (soap_out__ns1__getDevVerReq_Any(soap, tag?tag:"ns1:getDevVerReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerReq_Any * SOAP_FMAC4 soap_get__ns1__getDevVerReq_Any(struct soap *soap, struct _ns1__getDevVerReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDevVerReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getDevVerReq(struct soap *soap, const struct _ns1__getDevVerReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getDevVerReq_Any);
			soap_serialize__ns1__getDevVerReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDevVerReq(struct soap *soap, const char *tag, int id, const struct _ns1__getDevVerReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getDevVerReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getDevVerReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getDevVerReq * SOAP_FMAC4 soap_in__ns1__getDevVerReq(struct soap *soap, const char *tag, struct _ns1__getDevVerReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getDevVerReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getDevVerReq, sizeof(struct _ns1__getDevVerReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getDevVerReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getDevVerReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getDevVerReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getDevVerReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getDevVerReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getDevVerReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getDevVerReq, 0, sizeof(struct _ns1__getDevVerReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getDevVerReq(struct soap *soap, const struct _ns1__getDevVerReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getDevVerReq);
	if (soap_out__ns1__getDevVerReq(soap, tag?tag:"ns1:getDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerReq * SOAP_FMAC4 soap_get__ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__rebootRes_Any(struct soap *soap, struct _ns1__rebootRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__rebootRes_Any(struct soap *soap, const struct _ns1__rebootRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__rebootRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__rebootRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__rebootRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__rebootRes_Any * SOAP_FMAC4 soap_in__ns1__rebootRes_Any(struct soap *soap, const char *tag, struct _ns1__rebootRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__rebootRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__rebootRes_Any, sizeof(struct _ns1__rebootRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__rebootRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__rebootRes_Any, 0, sizeof(struct _ns1__rebootRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__rebootRes_Any(struct soap *soap, const struct _ns1__rebootRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__rebootRes_Any);
	if (soap_out__ns1__rebootRes_Any(soap, tag?tag:"ns1:rebootRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootRes_Any * SOAP_FMAC4 soap_get__ns1__rebootRes_Any(struct soap *soap, struct _ns1__rebootRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__rebootRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__rebootRes(struct soap *soap, const struct _ns1__rebootRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__rebootRes_Any);
			soap_serialize__ns1__rebootRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__rebootRes(struct soap *soap, const char *tag, int id, const struct _ns1__rebootRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__rebootRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__rebootRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__rebootRes * SOAP_FMAC4 soap_in__ns1__rebootRes(struct soap *soap, const char *tag, struct _ns1__rebootRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__rebootRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__rebootRes, sizeof(struct _ns1__rebootRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__rebootRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__rebootRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__rebootRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__rebootRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__rebootRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__rebootRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__rebootRes, 0, sizeof(struct _ns1__rebootRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__rebootRes(struct soap *soap, const struct _ns1__rebootRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__rebootRes);
	if (soap_out__ns1__rebootRes(soap, tag?tag:"ns1:rebootRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootRes * SOAP_FMAC4 soap_get__ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__rebootRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__rebootReq_Any(struct soap *soap, struct _ns1__rebootReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__rebootReq_Any(struct soap *soap, const struct _ns1__rebootReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__rebootReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__rebootReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__rebootReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__rebootReq_Any * SOAP_FMAC4 soap_in__ns1__rebootReq_Any(struct soap *soap, const char *tag, struct _ns1__rebootReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__rebootReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__rebootReq_Any, sizeof(struct _ns1__rebootReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__rebootReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__rebootReq_Any, 0, sizeof(struct _ns1__rebootReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__rebootReq_Any(struct soap *soap, const struct _ns1__rebootReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__rebootReq_Any);
	if (soap_out__ns1__rebootReq_Any(soap, tag?tag:"ns1:rebootReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootReq_Any * SOAP_FMAC4 soap_get__ns1__rebootReq_Any(struct soap *soap, struct _ns1__rebootReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__rebootReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__rebootReq(struct soap *soap, const struct _ns1__rebootReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__rebootReq_Any);
			soap_serialize__ns1__rebootReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__rebootReq(struct soap *soap, const char *tag, int id, const struct _ns1__rebootReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__rebootReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__rebootReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__rebootReq * SOAP_FMAC4 soap_in__ns1__rebootReq(struct soap *soap, const char *tag, struct _ns1__rebootReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__rebootReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__rebootReq, sizeof(struct _ns1__rebootReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__rebootReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__rebootReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__rebootReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__rebootReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__rebootReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__rebootReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__rebootReq, 0, sizeof(struct _ns1__rebootReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__rebootReq(struct soap *soap, const struct _ns1__rebootReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__rebootReq);
	if (soap_out__ns1__rebootReq(soap, tag?tag:"ns1:rebootReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootReq * SOAP_FMAC4 soap_get__ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__rebootReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setCodingParamRes_Any(struct soap *soap, struct _ns1__setCodingParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setCodingParamRes_Any(struct soap *soap, const struct _ns1__setCodingParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setCodingParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setCodingParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setCodingParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes_Any * SOAP_FMAC4 soap_in__ns1__setCodingParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setCodingParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setCodingParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setCodingParamRes_Any, sizeof(struct _ns1__setCodingParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setCodingParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setCodingParamRes_Any, 0, sizeof(struct _ns1__setCodingParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setCodingParamRes_Any(struct soap *soap, const struct _ns1__setCodingParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setCodingParamRes_Any);
	if (soap_out__ns1__setCodingParamRes_Any(soap, tag?tag:"ns1:setCodingParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes_Any * SOAP_FMAC4 soap_get__ns1__setCodingParamRes_Any(struct soap *soap, struct _ns1__setCodingParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setCodingParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setCodingParamRes(struct soap *soap, const struct _ns1__setCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setCodingParamRes_Any);
			soap_serialize__ns1__setCodingParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setCodingParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__setCodingParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setCodingParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setCodingParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes * SOAP_FMAC4 soap_in__ns1__setCodingParamRes(struct soap *soap, const char *tag, struct _ns1__setCodingParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setCodingParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setCodingParamRes, sizeof(struct _ns1__setCodingParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setCodingParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setCodingParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setCodingParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setCodingParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setCodingParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setCodingParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setCodingParamRes, 0, sizeof(struct _ns1__setCodingParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setCodingParamRes(struct soap *soap, const struct _ns1__setCodingParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setCodingParamRes);
	if (soap_out__ns1__setCodingParamRes(soap, tag?tag:"ns1:setCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes * SOAP_FMAC4 soap_get__ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setCodingParamReq_Any(struct soap *soap, struct _ns1__setCodingParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setCodingParamReq_Any(struct soap *soap, const struct _ns1__setCodingParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setCodingParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setCodingParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setCodingParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq_Any * SOAP_FMAC4 soap_in__ns1__setCodingParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setCodingParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setCodingParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setCodingParamReq_Any, sizeof(struct _ns1__setCodingParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setCodingParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setCodingParamReq_Any, 0, sizeof(struct _ns1__setCodingParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setCodingParamReq_Any(struct soap *soap, const struct _ns1__setCodingParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setCodingParamReq_Any);
	if (soap_out__ns1__setCodingParamReq_Any(soap, tag?tag:"ns1:setCodingParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq_Any * SOAP_FMAC4 soap_get__ns1__setCodingParamReq_Any(struct soap *soap, struct _ns1__setCodingParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setCodingParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	a->FrameSize = NULL;
	a->FrameRate = NULL;
	a->RateType = NULL;
	a->BitRate = NULL;
	a->ImageQuality = NULL;
	a->AudioInput = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setCodingParamReq(struct soap *soap, const struct _ns1__setCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_PointerTons1__FrameSize(soap, &a->FrameSize);
	soap_serialize_PointerToint(soap, &a->FrameRate);
	soap_serialize_PointerTons1__RateType(soap, &a->RateType);
	soap_serialize_PointerToint(soap, &a->BitRate);
	soap_serialize_PointerToint(soap, &a->ImageQuality);
	soap_serialize_PointerToxsd__boolean(soap, &a->AudioInput);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setCodingParamReq_Any);
			soap_serialize__ns1__setCodingParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setCodingParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__setCodingParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setCodingParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_PointerTons1__FrameSize(soap, "ns1:FrameSize", -1, &a->FrameSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FrameRate", -1, &a->FrameRate, ""))
		return soap->error;
	if (soap_out_PointerTons1__RateType(soap, "ns1:RateType", -1, &a->RateType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:BitRate", -1, &a->BitRate, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ImageQuality", -1, &a->ImageQuality, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:AudioInput", -1, &a->AudioInput, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setCodingParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq * SOAP_FMAC4 soap_in__ns1__setCodingParamReq(struct soap *soap, const char *tag, struct _ns1__setCodingParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_FrameSize = 1;
	size_t soap_flag_FrameRate = 1;
	size_t soap_flag_RateType = 1;
	size_t soap_flag_BitRate = 1;
	size_t soap_flag_ImageQuality = 1;
	size_t soap_flag_AudioInput = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setCodingParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setCodingParamReq, sizeof(struct _ns1__setCodingParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setCodingParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_FrameSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FrameSize(soap, "ns1:FrameSize", &a->FrameSize, "ns1:FrameSize"))
				{	soap_flag_FrameSize--;
					continue;
				}
			if (soap_flag_FrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FrameRate", &a->FrameRate, "xsd:int"))
				{	soap_flag_FrameRate--;
					continue;
				}
			if (soap_flag_RateType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RateType(soap, "ns1:RateType", &a->RateType, "ns1:RateType"))
				{	soap_flag_RateType--;
					continue;
				}
			if (soap_flag_BitRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:BitRate", &a->BitRate, "xsd:int"))
				{	soap_flag_BitRate--;
					continue;
				}
			if (soap_flag_ImageQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ImageQuality", &a->ImageQuality, "xsd:int"))
				{	soap_flag_ImageQuality--;
					continue;
				}
			if (soap_flag_AudioInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:AudioInput", &a->AudioInput, "xsd:boolean"))
				{	soap_flag_AudioInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setCodingParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setCodingParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setCodingParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setCodingParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setCodingParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setCodingParamReq, 0, sizeof(struct _ns1__setCodingParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setCodingParamReq(struct soap *soap, const struct _ns1__setCodingParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setCodingParamReq);
	if (soap_out__ns1__setCodingParamReq(soap, tag?tag:"ns1:setCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq * SOAP_FMAC4 soap_get__ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getCodingParamRes_Any(struct soap *soap, struct _ns1__getCodingParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getCodingParamRes_Any(struct soap *soap, const struct _ns1__getCodingParamRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCodingParamRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getCodingParamRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCodingParamRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes_Any * SOAP_FMAC4 soap_in__ns1__getCodingParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getCodingParamRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getCodingParamRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCodingParamRes_Any, sizeof(struct _ns1__getCodingParamRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getCodingParamRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCodingParamRes_Any, 0, sizeof(struct _ns1__getCodingParamRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getCodingParamRes_Any(struct soap *soap, const struct _ns1__getCodingParamRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getCodingParamRes_Any);
	if (soap_out__ns1__getCodingParamRes_Any(soap, tag?tag:"ns1:getCodingParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes_Any * SOAP_FMAC4 soap_get__ns1__getCodingParamRes_Any(struct soap *soap, struct _ns1__getCodingParamRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCodingParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->FrameSize = NULL;
	a->FrameRate = NULL;
	a->RateType = NULL;
	a->BitRate = NULL;
	a->ImageQuality = NULL;
	a->AudioInput = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getCodingParamRes(struct soap *soap, const struct _ns1__getCodingParamRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__FrameSize(soap, &a->FrameSize);
	soap_serialize_PointerToint(soap, &a->FrameRate);
	soap_serialize_PointerTons1__RateType(soap, &a->RateType);
	soap_serialize_PointerToint(soap, &a->BitRate);
	soap_serialize_PointerToint(soap, &a->ImageQuality);
	soap_serialize_PointerToxsd__boolean(soap, &a->AudioInput);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getCodingParamRes_Any);
			soap_serialize__ns1__getCodingParamRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCodingParamRes(struct soap *soap, const char *tag, int id, const struct _ns1__getCodingParamRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCodingParamRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__FrameSize(soap, "ns1:FrameSize", -1, &a->FrameSize, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:FrameRate", -1, &a->FrameRate, ""))
		return soap->error;
	if (soap_out_PointerTons1__RateType(soap, "ns1:RateType", -1, &a->RateType, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:BitRate", -1, &a->BitRate, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:ImageQuality", -1, &a->ImageQuality, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns1:AudioInput", -1, &a->AudioInput, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getCodingParamRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes * SOAP_FMAC4 soap_in__ns1__getCodingParamRes(struct soap *soap, const char *tag, struct _ns1__getCodingParamRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_FrameSize = 1;
	size_t soap_flag_FrameRate = 1;
	size_t soap_flag_RateType = 1;
	size_t soap_flag_BitRate = 1;
	size_t soap_flag_ImageQuality = 1;
	size_t soap_flag_AudioInput = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getCodingParamRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCodingParamRes, sizeof(struct _ns1__getCodingParamRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getCodingParamRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_FrameSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__FrameSize(soap, "ns1:FrameSize", &a->FrameSize, "ns1:FrameSize"))
				{	soap_flag_FrameSize--;
					continue;
				}
			if (soap_flag_FrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:FrameRate", &a->FrameRate, "xsd:int"))
				{	soap_flag_FrameRate--;
					continue;
				}
			if (soap_flag_RateType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RateType(soap, "ns1:RateType", &a->RateType, "ns1:RateType"))
				{	soap_flag_RateType--;
					continue;
				}
			if (soap_flag_BitRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:BitRate", &a->BitRate, "xsd:int"))
				{	soap_flag_BitRate--;
					continue;
				}
			if (soap_flag_ImageQuality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:ImageQuality", &a->ImageQuality, "xsd:int"))
				{	soap_flag_ImageQuality--;
					continue;
				}
			if (soap_flag_AudioInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns1:AudioInput", &a->AudioInput, "xsd:boolean"))
				{	soap_flag_AudioInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getCodingParamRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getCodingParamRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getCodingParamRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getCodingParamRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getCodingParamRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCodingParamRes, 0, sizeof(struct _ns1__getCodingParamRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getCodingParamRes(struct soap *soap, const struct _ns1__getCodingParamRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getCodingParamRes);
	if (soap_out__ns1__getCodingParamRes(soap, tag?tag:"ns1:getCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes * SOAP_FMAC4 soap_get__ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getCodingParamReq_Any(struct soap *soap, struct _ns1__getCodingParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getCodingParamReq_Any(struct soap *soap, const struct _ns1__getCodingParamReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCodingParamReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getCodingParamReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCodingParamReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq_Any * SOAP_FMAC4 soap_in__ns1__getCodingParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getCodingParamReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getCodingParamReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCodingParamReq_Any, sizeof(struct _ns1__getCodingParamReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getCodingParamReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCodingParamReq_Any, 0, sizeof(struct _ns1__getCodingParamReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getCodingParamReq_Any(struct soap *soap, const struct _ns1__getCodingParamReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getCodingParamReq_Any);
	if (soap_out__ns1__getCodingParamReq_Any(soap, tag?tag:"ns1:getCodingParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq_Any * SOAP_FMAC4 soap_get__ns1__getCodingParamReq_Any(struct soap *soap, struct _ns1__getCodingParamReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCodingParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getCodingParamReq(struct soap *soap, const struct _ns1__getCodingParamReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getCodingParamReq_Any);
			soap_serialize__ns1__getCodingParamReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCodingParamReq(struct soap *soap, const char *tag, int id, const struct _ns1__getCodingParamReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCodingParamReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getCodingParamReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq * SOAP_FMAC4 soap_in__ns1__getCodingParamReq(struct soap *soap, const char *tag, struct _ns1__getCodingParamReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getCodingParamReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCodingParamReq, sizeof(struct _ns1__getCodingParamReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getCodingParamReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getCodingParamReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getCodingParamReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getCodingParamReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getCodingParamReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getCodingParamReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCodingParamReq, 0, sizeof(struct _ns1__getCodingParamReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getCodingParamReq(struct soap *soap, const struct _ns1__getCodingParamReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getCodingParamReq);
	if (soap_out__ns1__getCodingParamReq(soap, tag?tag:"ns1:getCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq * SOAP_FMAC4 soap_get__ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__presetControlRes_Any(struct soap *soap, struct _ns1__presetControlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__presetControlRes_Any(struct soap *soap, const struct _ns1__presetControlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__presetControlRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__presetControlRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__presetControlRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__presetControlRes_Any * SOAP_FMAC4 soap_in__ns1__presetControlRes_Any(struct soap *soap, const char *tag, struct _ns1__presetControlRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__presetControlRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__presetControlRes_Any, sizeof(struct _ns1__presetControlRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__presetControlRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__presetControlRes_Any, 0, sizeof(struct _ns1__presetControlRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__presetControlRes_Any(struct soap *soap, const struct _ns1__presetControlRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__presetControlRes_Any);
	if (soap_out__ns1__presetControlRes_Any(soap, tag?tag:"ns1:presetControlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlRes_Any * SOAP_FMAC4 soap_get__ns1__presetControlRes_Any(struct soap *soap, struct _ns1__presetControlRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__presetControlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__presetControlRes(struct soap *soap, const struct _ns1__presetControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__presetControlRes_Any);
			soap_serialize__ns1__presetControlRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__presetControlRes(struct soap *soap, const char *tag, int id, const struct _ns1__presetControlRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__presetControlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__presetControlRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__presetControlRes * SOAP_FMAC4 soap_in__ns1__presetControlRes(struct soap *soap, const char *tag, struct _ns1__presetControlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__presetControlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__presetControlRes, sizeof(struct _ns1__presetControlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__presetControlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__presetControlRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__presetControlRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__presetControlRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__presetControlRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__presetControlRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__presetControlRes, 0, sizeof(struct _ns1__presetControlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__presetControlRes(struct soap *soap, const struct _ns1__presetControlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__presetControlRes);
	if (soap_out__ns1__presetControlRes(soap, tag?tag:"ns1:presetControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlRes * SOAP_FMAC4 soap_get__ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__presetControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__presetControlReq_Any(struct soap *soap, struct _ns1__presetControlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__presetControlReq_Any(struct soap *soap, const struct _ns1__presetControlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__presetControlReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__presetControlReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__presetControlReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__presetControlReq_Any * SOAP_FMAC4 soap_in__ns1__presetControlReq_Any(struct soap *soap, const char *tag, struct _ns1__presetControlReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__presetControlReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__presetControlReq_Any, sizeof(struct _ns1__presetControlReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__presetControlReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__presetControlReq_Any, 0, sizeof(struct _ns1__presetControlReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__presetControlReq_Any(struct soap *soap, const struct _ns1__presetControlReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__presetControlReq_Any);
	if (soap_out__ns1__presetControlReq_Any(soap, tag?tag:"ns1:presetControlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlReq_Any * SOAP_FMAC4 soap_get__ns1__presetControlReq_Any(struct soap *soap, struct _ns1__presetControlReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__presetControlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__PTZPreset(soap, &a->PtzPreset);
	soap_default_int(soap, &a->PresetNo);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__presetControlReq(struct soap *soap, const struct _ns1__presetControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_embedded(soap, &a->PresetNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__presetControlReq_Any);
			soap_serialize__ns1__presetControlReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__presetControlReq(struct soap *soap, const char *tag, int id, const struct _ns1__presetControlReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__presetControlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__PTZPreset(soap, "ns1:PtzPreset", -1, &a->PtzPreset, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:PresetNo", -1, &a->PresetNo, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__presetControlReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__presetControlReq * SOAP_FMAC4 soap_in__ns1__presetControlReq(struct soap *soap, const char *tag, struct _ns1__presetControlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_PtzPreset = 1;
	size_t soap_flag_PresetNo = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__presetControlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__presetControlReq, sizeof(struct _ns1__presetControlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__presetControlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_PtzPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PTZPreset(soap, "ns1:PtzPreset", &a->PtzPreset, "ns1:PTZPreset"))
				{	soap_flag_PtzPreset--;
					continue;
				}
			if (soap_flag_PresetNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:PresetNo", &a->PresetNo, "xsd:int"))
				{	soap_flag_PresetNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__presetControlReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__presetControlReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__presetControlReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__presetControlReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__presetControlReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__presetControlReq, 0, sizeof(struct _ns1__presetControlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_PtzPreset > 0 || soap_flag_PresetNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__presetControlReq(struct soap *soap, const struct _ns1__presetControlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__presetControlReq);
	if (soap_out__ns1__presetControlReq(soap, tag?tag:"ns1:presetControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlReq * SOAP_FMAC4 soap_get__ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__presetControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__lensControlRes_Any(struct soap *soap, struct _ns1__lensControlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__lensControlRes_Any(struct soap *soap, const struct _ns1__lensControlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__lensControlRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__lensControlRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__lensControlRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__lensControlRes_Any * SOAP_FMAC4 soap_in__ns1__lensControlRes_Any(struct soap *soap, const char *tag, struct _ns1__lensControlRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__lensControlRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__lensControlRes_Any, sizeof(struct _ns1__lensControlRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__lensControlRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__lensControlRes_Any, 0, sizeof(struct _ns1__lensControlRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__lensControlRes_Any(struct soap *soap, const struct _ns1__lensControlRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__lensControlRes_Any);
	if (soap_out__ns1__lensControlRes_Any(soap, tag?tag:"ns1:lensControlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlRes_Any * SOAP_FMAC4 soap_get__ns1__lensControlRes_Any(struct soap *soap, struct _ns1__lensControlRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__lensControlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__lensControlRes(struct soap *soap, const struct _ns1__lensControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__lensControlRes_Any);
			soap_serialize__ns1__lensControlRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__lensControlRes(struct soap *soap, const char *tag, int id, const struct _ns1__lensControlRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__lensControlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__lensControlRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__lensControlRes * SOAP_FMAC4 soap_in__ns1__lensControlRes(struct soap *soap, const char *tag, struct _ns1__lensControlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__lensControlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__lensControlRes, sizeof(struct _ns1__lensControlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__lensControlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__lensControlRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__lensControlRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__lensControlRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__lensControlRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__lensControlRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__lensControlRes, 0, sizeof(struct _ns1__lensControlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__lensControlRes(struct soap *soap, const struct _ns1__lensControlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__lensControlRes);
	if (soap_out__ns1__lensControlRes(soap, tag?tag:"ns1:lensControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlRes * SOAP_FMAC4 soap_get__ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__lensControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__lensControlReq_Any(struct soap *soap, struct _ns1__lensControlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__lensControlReq_Any(struct soap *soap, const struct _ns1__lensControlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__lensControlReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__lensControlReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__lensControlReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__lensControlReq_Any * SOAP_FMAC4 soap_in__ns1__lensControlReq_Any(struct soap *soap, const char *tag, struct _ns1__lensControlReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__lensControlReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__lensControlReq_Any, sizeof(struct _ns1__lensControlReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__lensControlReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__lensControlReq_Any, 0, sizeof(struct _ns1__lensControlReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__lensControlReq_Any(struct soap *soap, const struct _ns1__lensControlReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__lensControlReq_Any);
	if (soap_out__ns1__lensControlReq_Any(soap, tag?tag:"ns1:lensControlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlReq_Any * SOAP_FMAC4 soap_get__ns1__lensControlReq_Any(struct soap *soap, struct _ns1__lensControlReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__lensControlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__PTZLens(soap, &a->PtzLens);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__lensControlReq(struct soap *soap, const struct _ns1__lensControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__lensControlReq_Any);
			soap_serialize__ns1__lensControlReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__lensControlReq(struct soap *soap, const char *tag, int id, const struct _ns1__lensControlReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__lensControlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__PTZLens(soap, "ns1:PtzLens", -1, &a->PtzLens, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__lensControlReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__lensControlReq * SOAP_FMAC4 soap_in__ns1__lensControlReq(struct soap *soap, const char *tag, struct _ns1__lensControlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_PtzLens = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__lensControlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__lensControlReq, sizeof(struct _ns1__lensControlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__lensControlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_PtzLens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PTZLens(soap, "ns1:PtzLens", &a->PtzLens, "ns1:PTZLens"))
				{	soap_flag_PtzLens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__lensControlReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__lensControlReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__lensControlReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__lensControlReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__lensControlReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__lensControlReq, 0, sizeof(struct _ns1__lensControlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_PtzLens > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__lensControlReq(struct soap *soap, const struct _ns1__lensControlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__lensControlReq);
	if (soap_out__ns1__lensControlReq(soap, tag?tag:"ns1:lensControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlReq * SOAP_FMAC4 soap_get__ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__lensControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ptzControlRes_Any(struct soap *soap, struct _ns1__ptzControlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ptzControlRes_Any(struct soap *soap, const struct _ns1__ptzControlRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ptzControlRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__ptzControlRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ptzControlRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ptzControlRes_Any * SOAP_FMAC4 soap_in__ns1__ptzControlRes_Any(struct soap *soap, const char *tag, struct _ns1__ptzControlRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ptzControlRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ptzControlRes_Any, sizeof(struct _ns1__ptzControlRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ptzControlRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ptzControlRes_Any, 0, sizeof(struct _ns1__ptzControlRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ptzControlRes_Any(struct soap *soap, const struct _ns1__ptzControlRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ptzControlRes_Any);
	if (soap_out__ns1__ptzControlRes_Any(soap, tag?tag:"ns1:ptzControlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlRes_Any * SOAP_FMAC4 soap_get__ns1__ptzControlRes_Any(struct soap *soap, struct _ns1__ptzControlRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ptzControlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ptzControlRes(struct soap *soap, const struct _ns1__ptzControlRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__ptzControlRes_Any);
			soap_serialize__ns1__ptzControlRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ptzControlRes(struct soap *soap, const char *tag, int id, const struct _ns1__ptzControlRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ptzControlRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__ptzControlRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ptzControlRes * SOAP_FMAC4 soap_in__ns1__ptzControlRes(struct soap *soap, const char *tag, struct _ns1__ptzControlRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ptzControlRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ptzControlRes, sizeof(struct _ns1__ptzControlRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ptzControlRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__ptzControlRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__ptzControlRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__ptzControlRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__ptzControlRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__ptzControlRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ptzControlRes, 0, sizeof(struct _ns1__ptzControlRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ptzControlRes(struct soap *soap, const struct _ns1__ptzControlRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ptzControlRes);
	if (soap_out__ns1__ptzControlRes(soap, tag?tag:"ns1:ptzControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlRes * SOAP_FMAC4 soap_get__ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ptzControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ptzControlReq_Any(struct soap *soap, struct _ns1__ptzControlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ptzControlReq_Any(struct soap *soap, const struct _ns1__ptzControlReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ptzControlReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__ptzControlReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ptzControlReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ptzControlReq_Any * SOAP_FMAC4 soap_in__ns1__ptzControlReq_Any(struct soap *soap, const char *tag, struct _ns1__ptzControlReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ptzControlReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ptzControlReq_Any, sizeof(struct _ns1__ptzControlReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ptzControlReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ptzControlReq_Any, 0, sizeof(struct _ns1__ptzControlReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ptzControlReq_Any(struct soap *soap, const struct _ns1__ptzControlReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ptzControlReq_Any);
	if (soap_out__ns1__ptzControlReq_Any(soap, tag?tag:"ns1:ptzControlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlReq_Any * SOAP_FMAC4 soap_get__ns1__ptzControlReq_Any(struct soap *soap, struct _ns1__ptzControlReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ptzControlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__PTZDirection(soap, &a->PtzDirection);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ptzControlReq(struct soap *soap, const struct _ns1__ptzControlReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__ptzControlReq_Any);
			soap_serialize__ns1__ptzControlReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ptzControlReq(struct soap *soap, const char *tag, int id, const struct _ns1__ptzControlReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ptzControlReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__PTZDirection(soap, "ns1:PtzDirection", -1, &a->PtzDirection, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__ptzControlReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ptzControlReq * SOAP_FMAC4 soap_in__ns1__ptzControlReq(struct soap *soap, const char *tag, struct _ns1__ptzControlReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_PtzDirection = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ptzControlReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ptzControlReq, sizeof(struct _ns1__ptzControlReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ptzControlReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_PtzDirection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PTZDirection(soap, "ns1:PtzDirection", &a->PtzDirection, "ns1:PTZDirection"))
				{	soap_flag_PtzDirection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__ptzControlReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__ptzControlReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__ptzControlReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__ptzControlReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__ptzControlReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ptzControlReq, 0, sizeof(struct _ns1__ptzControlReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_PtzDirection > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ptzControlReq(struct soap *soap, const struct _ns1__ptzControlReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__ptzControlReq);
	if (soap_out__ns1__ptzControlReq(soap, tag?tag:"ns1:ptzControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlReq * SOAP_FMAC4 soap_get__ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ptzControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceRes_Any(struct soap *soap, struct _ns1__nullifyDeviceRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceRes_Any(struct soap *soap, const struct _ns1__nullifyDeviceRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes_Any * SOAP_FMAC4 soap_in__ns1__nullifyDeviceRes_Any(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceRes_Any, sizeof(struct _ns1__nullifyDeviceRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceRes_Any, 0, sizeof(struct _ns1__nullifyDeviceRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceRes_Any(struct soap *soap, const struct _ns1__nullifyDeviceRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceRes_Any);
	if (soap_out__ns1__nullifyDeviceRes_Any(soap, tag?tag:"ns1:nullifyDeviceRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes_Any * SOAP_FMAC4 soap_get__ns1__nullifyDeviceRes_Any(struct soap *soap, struct _ns1__nullifyDeviceRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceRes(struct soap *soap, const struct _ns1__nullifyDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__nullifyDeviceRes_Any);
			soap_serialize__ns1__nullifyDeviceRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceRes(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__nullifyDeviceRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes * SOAP_FMAC4 soap_in__ns1__nullifyDeviceRes(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceRes, sizeof(struct _ns1__nullifyDeviceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__nullifyDeviceRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__nullifyDeviceRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__nullifyDeviceRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__nullifyDeviceRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__nullifyDeviceRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceRes, 0, sizeof(struct _ns1__nullifyDeviceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceRes(struct soap *soap, const struct _ns1__nullifyDeviceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceRes);
	if (soap_out__ns1__nullifyDeviceRes(soap, tag?tag:"ns1:nullifyDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes * SOAP_FMAC4 soap_get__ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceReq_Any(struct soap *soap, struct _ns1__nullifyDeviceReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceReq_Any(struct soap *soap, const struct _ns1__nullifyDeviceReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq_Any * SOAP_FMAC4 soap_in__ns1__nullifyDeviceReq_Any(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceReq_Any, sizeof(struct _ns1__nullifyDeviceReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceReq_Any, 0, sizeof(struct _ns1__nullifyDeviceReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceReq_Any(struct soap *soap, const struct _ns1__nullifyDeviceReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceReq_Any);
	if (soap_out__ns1__nullifyDeviceReq_Any(soap, tag?tag:"ns1:nullifyDeviceReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq_Any * SOAP_FMAC4 soap_get__ns1__nullifyDeviceReq_Any(struct soap *soap, struct _ns1__nullifyDeviceReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_string(soap, &a->DevKey);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__nullifyDeviceReq(struct soap *soap, const struct _ns1__nullifyDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_string(soap, &a->DevKey);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__nullifyDeviceReq_Any);
			soap_serialize__ns1__nullifyDeviceReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__nullifyDeviceReq(struct soap *soap, const char *tag, int id, const struct _ns1__nullifyDeviceReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__nullifyDeviceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevKey", -1, &a->DevKey, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__nullifyDeviceReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq * SOAP_FMAC4 soap_in__ns1__nullifyDeviceReq(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_DevKey = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__nullifyDeviceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__nullifyDeviceReq, sizeof(struct _ns1__nullifyDeviceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__nullifyDeviceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_DevKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevKey", &a->DevKey, "xsd:string"))
				{	soap_flag_DevKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__nullifyDeviceReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__nullifyDeviceReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__nullifyDeviceReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__nullifyDeviceReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__nullifyDeviceReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__nullifyDeviceReq, 0, sizeof(struct _ns1__nullifyDeviceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__nullifyDeviceReq(struct soap *soap, const struct _ns1__nullifyDeviceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__nullifyDeviceReq);
	if (soap_out__ns1__nullifyDeviceReq(soap, tag?tag:"ns1:nullifyDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq * SOAP_FMAC4 soap_get__ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__nullifyDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceRes_Any(struct soap *soap, struct _ns1__addDeviceRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceRes_Any(struct soap *soap, const struct _ns1__addDeviceRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceRes_Any * SOAP_FMAC4 soap_in__ns1__addDeviceRes_Any(struct soap *soap, const char *tag, struct _ns1__addDeviceRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceRes_Any, sizeof(struct _ns1__addDeviceRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceRes_Any, 0, sizeof(struct _ns1__addDeviceRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceRes_Any(struct soap *soap, const struct _ns1__addDeviceRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceRes_Any);
	if (soap_out__ns1__addDeviceRes_Any(soap, tag?tag:"ns1:addDeviceRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceRes_Any * SOAP_FMAC4 soap_get__ns1__addDeviceRes_Any(struct soap *soap, struct _ns1__addDeviceRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceRes(struct soap *soap, const struct _ns1__addDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__addDeviceRes_Any);
			soap_serialize__ns1__addDeviceRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceRes(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__addDeviceRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceRes * SOAP_FMAC4 soap_in__ns1__addDeviceRes(struct soap *soap, const char *tag, struct _ns1__addDeviceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceRes, sizeof(struct _ns1__addDeviceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__addDeviceRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__addDeviceRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__addDeviceRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__addDeviceRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__addDeviceRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceRes, 0, sizeof(struct _ns1__addDeviceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceRes(struct soap *soap, const struct _ns1__addDeviceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceRes);
	if (soap_out__ns1__addDeviceRes(soap, tag?tag:"ns1:addDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceRes * SOAP_FMAC4 soap_get__ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceReq_Any(struct soap *soap, struct _ns1__addDeviceReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceReq_Any(struct soap *soap, const struct _ns1__addDeviceReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceReq_Any * SOAP_FMAC4 soap_in__ns1__addDeviceReq_Any(struct soap *soap, const char *tag, struct _ns1__addDeviceReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceReq_Any, sizeof(struct _ns1__addDeviceReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceReq_Any, 0, sizeof(struct _ns1__addDeviceReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceReq_Any(struct soap *soap, const struct _ns1__addDeviceReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceReq_Any);
	if (soap_out__ns1__addDeviceReq_Any(soap, tag?tag:"ns1:addDeviceReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceReq_Any * SOAP_FMAC4 soap_get__ns1__addDeviceReq_Any(struct soap *soap, struct _ns1__addDeviceReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->DeviceAll = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__addDeviceReq(struct soap *soap, const struct _ns1__addDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerTons1__ArrayOfDevice(soap, &a->DeviceAll);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__addDeviceReq_Any);
			soap_serialize__ns1__addDeviceReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addDeviceReq(struct soap *soap, const char *tag, int id, const struct _ns1__addDeviceReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addDeviceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDevice(soap, "ns1:DeviceAll", -1, &a->DeviceAll, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__addDeviceReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__addDeviceReq * SOAP_FMAC4 soap_in__ns1__addDeviceReq(struct soap *soap, const char *tag, struct _ns1__addDeviceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DeviceAll = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__addDeviceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addDeviceReq, sizeof(struct _ns1__addDeviceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__addDeviceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DeviceAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDevice(soap, "ns1:DeviceAll", &a->DeviceAll, "ns1:ArrayOfDevice"))
				{	soap_flag_DeviceAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__addDeviceReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__addDeviceReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__addDeviceReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__addDeviceReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__addDeviceReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addDeviceReq, 0, sizeof(struct _ns1__addDeviceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__addDeviceReq(struct soap *soap, const struct _ns1__addDeviceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__addDeviceReq);
	if (soap_out__ns1__addDeviceReq(soap, tag?tag:"ns1:addDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceReq * SOAP_FMAC4 soap_get__ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateChannelNameRes_Any(struct soap *soap, struct _ns1__updateChannelNameRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateChannelNameRes_Any(struct soap *soap, const struct _ns1__updateChannelNameRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateChannelNameRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updateChannelNameRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateChannelNameRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes_Any * SOAP_FMAC4 soap_in__ns1__updateChannelNameRes_Any(struct soap *soap, const char *tag, struct _ns1__updateChannelNameRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateChannelNameRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateChannelNameRes_Any, sizeof(struct _ns1__updateChannelNameRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateChannelNameRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateChannelNameRes_Any, 0, sizeof(struct _ns1__updateChannelNameRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateChannelNameRes_Any(struct soap *soap, const struct _ns1__updateChannelNameRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateChannelNameRes_Any);
	if (soap_out__ns1__updateChannelNameRes_Any(soap, tag?tag:"ns1:updateChannelNameRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes_Any * SOAP_FMAC4 soap_get__ns1__updateChannelNameRes_Any(struct soap *soap, struct _ns1__updateChannelNameRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateChannelNameRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateChannelNameRes(struct soap *soap, const struct _ns1__updateChannelNameRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updateChannelNameRes_Any);
			soap_serialize__ns1__updateChannelNameRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateChannelNameRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateChannelNameRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateChannelNameRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updateChannelNameRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes * SOAP_FMAC4 soap_in__ns1__updateChannelNameRes(struct soap *soap, const char *tag, struct _ns1__updateChannelNameRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateChannelNameRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateChannelNameRes, sizeof(struct _ns1__updateChannelNameRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateChannelNameRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updateChannelNameRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updateChannelNameRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updateChannelNameRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updateChannelNameRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updateChannelNameRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateChannelNameRes, 0, sizeof(struct _ns1__updateChannelNameRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateChannelNameRes(struct soap *soap, const struct _ns1__updateChannelNameRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateChannelNameRes);
	if (soap_out__ns1__updateChannelNameRes(soap, tag?tag:"ns1:updateChannelNameRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes * SOAP_FMAC4 soap_get__ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateChannelNameRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateChannelNameReq_Any(struct soap *soap, struct _ns1__updateChannelNameReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateChannelNameReq_Any(struct soap *soap, const struct _ns1__updateChannelNameReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateChannelNameReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updateChannelNameReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateChannelNameReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq_Any * SOAP_FMAC4 soap_in__ns1__updateChannelNameReq_Any(struct soap *soap, const char *tag, struct _ns1__updateChannelNameReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateChannelNameReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateChannelNameReq_Any, sizeof(struct _ns1__updateChannelNameReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateChannelNameReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateChannelNameReq_Any, 0, sizeof(struct _ns1__updateChannelNameReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateChannelNameReq_Any(struct soap *soap, const struct _ns1__updateChannelNameReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateChannelNameReq_Any);
	if (soap_out__ns1__updateChannelNameReq_Any(soap, tag?tag:"ns1:updateChannelNameReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq_Any * SOAP_FMAC4 soap_get__ns1__updateChannelNameReq_Any(struct soap *soap, struct _ns1__updateChannelNameReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateChannelNameReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->ChannelName);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateChannelNameReq(struct soap *soap, const struct _ns1__updateChannelNameReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ChannelName);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updateChannelNameReq_Any);
			soap_serialize__ns1__updateChannelNameReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateChannelNameReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateChannelNameReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateChannelNameReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ChannelName", -1, &a->ChannelName, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updateChannelNameReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq * SOAP_FMAC4 soap_in__ns1__updateChannelNameReq(struct soap *soap, const char *tag, struct _ns1__updateChannelNameReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_ChannelName = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateChannelNameReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateChannelNameReq, sizeof(struct _ns1__updateChannelNameReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateChannelNameReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_ChannelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ChannelName", &a->ChannelName, "xsd:string"))
				{	soap_flag_ChannelName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updateChannelNameReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updateChannelNameReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updateChannelNameReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updateChannelNameReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updateChannelNameReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateChannelNameReq, 0, sizeof(struct _ns1__updateChannelNameReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateChannelNameReq(struct soap *soap, const struct _ns1__updateChannelNameReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateChannelNameReq);
	if (soap_out__ns1__updateChannelNameReq(soap, tag?tag:"ns1:updateChannelNameReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq * SOAP_FMAC4 soap_get__ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateChannelNameReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLogoutRes_Any(struct soap *soap, struct _ns1__userLogoutRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLogoutRes_Any(struct soap *soap, const struct _ns1__userLogoutRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLogoutRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__userLogoutRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLogoutRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLogoutRes_Any * SOAP_FMAC4 soap_in__ns1__userLogoutRes_Any(struct soap *soap, const char *tag, struct _ns1__userLogoutRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLogoutRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLogoutRes_Any, sizeof(struct _ns1__userLogoutRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLogoutRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLogoutRes_Any, 0, sizeof(struct _ns1__userLogoutRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLogoutRes_Any(struct soap *soap, const struct _ns1__userLogoutRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLogoutRes_Any);
	if (soap_out__ns1__userLogoutRes_Any(soap, tag?tag:"ns1:userLogoutRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutRes_Any * SOAP_FMAC4 soap_get__ns1__userLogoutRes_Any(struct soap *soap, struct _ns1__userLogoutRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLogoutRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLogoutRes(struct soap *soap, const struct _ns1__userLogoutRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__userLogoutRes_Any);
			soap_serialize__ns1__userLogoutRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLogoutRes(struct soap *soap, const char *tag, int id, const struct _ns1__userLogoutRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLogoutRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__userLogoutRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLogoutRes * SOAP_FMAC4 soap_in__ns1__userLogoutRes(struct soap *soap, const char *tag, struct _ns1__userLogoutRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLogoutRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLogoutRes, sizeof(struct _ns1__userLogoutRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLogoutRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__userLogoutRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__userLogoutRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__userLogoutRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__userLogoutRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__userLogoutRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLogoutRes, 0, sizeof(struct _ns1__userLogoutRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLogoutRes(struct soap *soap, const struct _ns1__userLogoutRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLogoutRes);
	if (soap_out__ns1__userLogoutRes(soap, tag?tag:"ns1:userLogoutRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutRes * SOAP_FMAC4 soap_get__ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLogoutRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLogoutReq_Any(struct soap *soap, struct _ns1__userLogoutReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLogoutReq_Any(struct soap *soap, const struct _ns1__userLogoutReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLogoutReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__userLogoutReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLogoutReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLogoutReq_Any * SOAP_FMAC4 soap_in__ns1__userLogoutReq_Any(struct soap *soap, const char *tag, struct _ns1__userLogoutReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLogoutReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLogoutReq_Any, sizeof(struct _ns1__userLogoutReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLogoutReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLogoutReq_Any, 0, sizeof(struct _ns1__userLogoutReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLogoutReq_Any(struct soap *soap, const struct _ns1__userLogoutReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLogoutReq_Any);
	if (soap_out__ns1__userLogoutReq_Any(soap, tag?tag:"ns1:userLogoutReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutReq_Any * SOAP_FMAC4 soap_get__ns1__userLogoutReq_Any(struct soap *soap, struct _ns1__userLogoutReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLogoutReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLogoutReq(struct soap *soap, const struct _ns1__userLogoutReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__userLogoutReq_Any);
			soap_serialize__ns1__userLogoutReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLogoutReq(struct soap *soap, const char *tag, int id, const struct _ns1__userLogoutReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLogoutReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__userLogoutReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLogoutReq * SOAP_FMAC4 soap_in__ns1__userLogoutReq(struct soap *soap, const char *tag, struct _ns1__userLogoutReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLogoutReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLogoutReq, sizeof(struct _ns1__userLogoutReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLogoutReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__userLogoutReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__userLogoutReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__userLogoutReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__userLogoutReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__userLogoutReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLogoutReq, 0, sizeof(struct _ns1__userLogoutReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLogoutReq(struct soap *soap, const struct _ns1__userLogoutReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLogoutReq);
	if (soap_out__ns1__userLogoutReq(soap, tag?tag:"ns1:userLogoutReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutReq * SOAP_FMAC4 soap_get__ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLogoutReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLoginRes_Any(struct soap *soap, struct _ns1__userLoginRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLoginRes_Any(struct soap *soap, const struct _ns1__userLoginRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLoginRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__userLoginRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLoginRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLoginRes_Any * SOAP_FMAC4 soap_in__ns1__userLoginRes_Any(struct soap *soap, const char *tag, struct _ns1__userLoginRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLoginRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLoginRes_Any, sizeof(struct _ns1__userLoginRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLoginRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLoginRes_Any, 0, sizeof(struct _ns1__userLoginRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLoginRes_Any(struct soap *soap, const struct _ns1__userLoginRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLoginRes_Any);
	if (soap_out__ns1__userLoginRes_Any(soap, tag?tag:"ns1:userLoginRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginRes_Any * SOAP_FMAC4 soap_get__ns1__userLoginRes_Any(struct soap *soap, struct _ns1__userLoginRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLoginRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLoginRes(struct soap *soap, struct _ns1__userLoginRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->LoginSession);
	a->NodeList = NULL;
	soap_default_string(soap, &a->Username);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLoginRes(struct soap *soap, const struct _ns1__userLoginRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_PointerTons1__ArrayOfDev(soap, &a->NodeList);
	soap_serialize_string(soap, &a->Username);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__userLoginRes_Any);
			soap_serialize__ns1__userLoginRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLoginRes(struct soap *soap, const char *tag, int id, const struct _ns1__userLoginRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLoginRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDev(soap, "ns1:NodeList", -1, &a->NodeList, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__userLoginRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLoginRes * SOAP_FMAC4 soap_in__ns1__userLoginRes(struct soap *soap, const char *tag, struct _ns1__userLoginRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_NodeList = 1;
	size_t soap_flag_Username = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLoginRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLoginRes, sizeof(struct _ns1__userLoginRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLoginRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_NodeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfDev(soap, "ns1:NodeList", &a->NodeList, "ns1:ArrayOfDev"))
				{	soap_flag_NodeList--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__userLoginRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__userLoginRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__userLoginRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__userLoginRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__userLoginRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLoginRes, 0, sizeof(struct _ns1__userLoginRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLoginRes(struct soap *soap, const struct _ns1__userLoginRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLoginRes);
	if (soap_out__ns1__userLoginRes(soap, tag?tag:"ns1:userLoginRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginRes * SOAP_FMAC4 soap_get__ns1__userLoginRes(struct soap *soap, struct _ns1__userLoginRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLoginRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLoginReq_Any(struct soap *soap, struct _ns1__userLoginReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLoginReq_Any(struct soap *soap, const struct _ns1__userLoginReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLoginReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__userLoginReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLoginReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLoginReq_Any * SOAP_FMAC4 soap_in__ns1__userLoginReq_Any(struct soap *soap, const char *tag, struct _ns1__userLoginReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLoginReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLoginReq_Any, sizeof(struct _ns1__userLoginReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLoginReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLoginReq_Any, 0, sizeof(struct _ns1__userLoginReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLoginReq_Any(struct soap *soap, const struct _ns1__userLoginReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLoginReq_Any);
	if (soap_out__ns1__userLoginReq_Any(soap, tag?tag:"ns1:userLoginReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginReq_Any * SOAP_FMAC4 soap_get__ns1__userLoginReq_Any(struct soap *soap, struct _ns1__userLoginReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLoginReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__userLoginReq(struct soap *soap, struct _ns1__userLoginReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_ns1__PwdType(soap, &a->PwdType);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->Version);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__userLoginReq(struct soap *soap, const struct _ns1__userLoginReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->Version);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__userLoginReq_Any);
			soap_serialize__ns1__userLoginReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userLoginReq(struct soap *soap, const char *tag, int id, const struct _ns1__userLoginReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userLoginReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_ns1__PwdType(soap, "ns1:PwdType", -1, &a->PwdType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Version", -1, &a->Version, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__userLoginReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__userLoginReq * SOAP_FMAC4 soap_in__ns1__userLoginReq(struct soap *soap, const char *tag, struct _ns1__userLoginReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_PwdType = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Version = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__userLoginReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userLoginReq, sizeof(struct _ns1__userLoginReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__userLoginReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_PwdType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__PwdType(soap, "ns1:PwdType", &a->PwdType, "ns1:PwdType"))
				{	soap_flag_PwdType--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Version", &a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__userLoginReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__userLoginReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__userLoginReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__userLoginReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__userLoginReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userLoginReq, 0, sizeof(struct _ns1__userLoginReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PwdType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__userLoginReq(struct soap *soap, const struct _ns1__userLoginReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__userLoginReq);
	if (soap_out__ns1__userLoginReq(soap, tag?tag:"ns1:userLoginReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginReq * SOAP_FMAC4 soap_get__ns1__userLoginReq(struct soap *soap, struct _ns1__userLoginReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userLoginReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__byeRes_Any(struct soap *soap, struct _ns1__byeRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__byeRes_Any(struct soap *soap, const struct _ns1__byeRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__byeRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__byeRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__byeRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__byeRes_Any * SOAP_FMAC4 soap_in__ns1__byeRes_Any(struct soap *soap, const char *tag, struct _ns1__byeRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__byeRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__byeRes_Any, sizeof(struct _ns1__byeRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__byeRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__byeRes_Any, 0, sizeof(struct _ns1__byeRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__byeRes_Any(struct soap *soap, const struct _ns1__byeRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__byeRes_Any);
	if (soap_out__ns1__byeRes_Any(soap, tag?tag:"ns1:byeRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeRes_Any * SOAP_FMAC4 soap_get__ns1__byeRes_Any(struct soap *soap, struct _ns1__byeRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__byeRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__byeRes(struct soap *soap, struct _ns1__byeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__byeRes(struct soap *soap, const struct _ns1__byeRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__byeRes_Any);
			soap_serialize__ns1__byeRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__byeRes(struct soap *soap, const char *tag, int id, const struct _ns1__byeRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__byeRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__byeRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__byeRes * SOAP_FMAC4 soap_in__ns1__byeRes(struct soap *soap, const char *tag, struct _ns1__byeRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__byeRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__byeRes, sizeof(struct _ns1__byeRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__byeRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__byeRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__byeRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__byeRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__byeRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__byeRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__byeRes, 0, sizeof(struct _ns1__byeRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__byeRes(struct soap *soap, const struct _ns1__byeRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__byeRes);
	if (soap_out__ns1__byeRes(soap, tag?tag:"ns1:byeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeRes * SOAP_FMAC4 soap_get__ns1__byeRes(struct soap *soap, struct _ns1__byeRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__byeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__byeReq_Any(struct soap *soap, struct _ns1__byeReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__byeReq_Any(struct soap *soap, const struct _ns1__byeReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__byeReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__byeReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__byeReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__byeReq_Any * SOAP_FMAC4 soap_in__ns1__byeReq_Any(struct soap *soap, const char *tag, struct _ns1__byeReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__byeReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__byeReq_Any, sizeof(struct _ns1__byeReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__byeReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__byeReq_Any, 0, sizeof(struct _ns1__byeReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__byeReq_Any(struct soap *soap, const struct _ns1__byeReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__byeReq_Any);
	if (soap_out__ns1__byeReq_Any(soap, tag?tag:"ns1:byeReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeReq_Any * SOAP_FMAC4 soap_get__ns1__byeReq_Any(struct soap *soap, struct _ns1__byeReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__byeReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__byeReq(struct soap *soap, struct _ns1__byeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_string(soap, &a->DialogID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__byeReq(struct soap *soap, const struct _ns1__byeReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DialogID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__byeReq_Any);
			soap_serialize__ns1__byeReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__byeReq(struct soap *soap, const char *tag, int id, const struct _ns1__byeReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__byeReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__byeReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__byeReq * SOAP_FMAC4 soap_in__ns1__byeReq(struct soap *soap, const char *tag, struct _ns1__byeReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_DialogID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__byeReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__byeReq, sizeof(struct _ns1__byeReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__byeReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__byeReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__byeReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__byeReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__byeReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__byeReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__byeReq, 0, sizeof(struct _ns1__byeReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__byeReq(struct soap *soap, const struct _ns1__byeReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__byeReq);
	if (soap_out__ns1__byeReq(soap, tag?tag:"ns1:byeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeReq * SOAP_FMAC4 soap_get__ns1__byeReq(struct soap *soap, struct _ns1__byeReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__byeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__inviteRes_Any(struct soap *soap, struct _ns1__inviteRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__inviteRes_Any(struct soap *soap, const struct _ns1__inviteRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__inviteRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__inviteRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__inviteRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__inviteRes_Any * SOAP_FMAC4 soap_in__ns1__inviteRes_Any(struct soap *soap, const char *tag, struct _ns1__inviteRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__inviteRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__inviteRes_Any, sizeof(struct _ns1__inviteRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__inviteRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__inviteRes_Any, 0, sizeof(struct _ns1__inviteRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__inviteRes_Any(struct soap *soap, const struct _ns1__inviteRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__inviteRes_Any);
	if (soap_out__ns1__inviteRes_Any(soap, tag?tag:"ns1:inviteRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteRes_Any * SOAP_FMAC4 soap_get__ns1__inviteRes_Any(struct soap *soap, struct _ns1__inviteRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__inviteRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__inviteRes(struct soap *soap, struct _ns1__inviteRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->DialogID);
	soap_default_string(soap, &a->SDPMessage);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__inviteRes(struct soap *soap, const struct _ns1__inviteRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DialogID);
	soap_serialize_string(soap, &a->SDPMessage);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__inviteRes_Any);
			soap_serialize__ns1__inviteRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__inviteRes(struct soap *soap, const char *tag, int id, const struct _ns1__inviteRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__inviteRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SDPMessage", -1, &a->SDPMessage, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__inviteRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__inviteRes * SOAP_FMAC4 soap_in__ns1__inviteRes(struct soap *soap, const char *tag, struct _ns1__inviteRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_DialogID = 1;
	size_t soap_flag_SDPMessage = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__inviteRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__inviteRes, sizeof(struct _ns1__inviteRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__inviteRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap_flag_SDPMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SDPMessage", &a->SDPMessage, "xsd:string"))
				{	soap_flag_SDPMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__inviteRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__inviteRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__inviteRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__inviteRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__inviteRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__inviteRes, 0, sizeof(struct _ns1__inviteRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__inviteRes(struct soap *soap, const struct _ns1__inviteRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__inviteRes);
	if (soap_out__ns1__inviteRes(soap, tag?tag:"ns1:inviteRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteRes * SOAP_FMAC4 soap_get__ns1__inviteRes(struct soap *soap, struct _ns1__inviteRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__inviteRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__inviteReq_Any(struct soap *soap, struct _ns1__inviteReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__inviteReq_Any(struct soap *soap, const struct _ns1__inviteReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__inviteReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__inviteReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__inviteReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__inviteReq_Any * SOAP_FMAC4 soap_in__ns1__inviteReq_Any(struct soap *soap, const char *tag, struct _ns1__inviteReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__inviteReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__inviteReq_Any, sizeof(struct _ns1__inviteReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__inviteReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__inviteReq_Any, 0, sizeof(struct _ns1__inviteReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__inviteReq_Any(struct soap *soap, const struct _ns1__inviteReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__inviteReq_Any);
	if (soap_out__ns1__inviteReq_Any(soap, tag?tag:"ns1:inviteReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteReq_Any * SOAP_FMAC4 soap_get__ns1__inviteReq_Any(struct soap *soap, struct _ns1__inviteReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__inviteReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__inviteReq(struct soap *soap, struct _ns1__inviteReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_ns1__StreamType(soap, &a->StreamType);
	soap_default_string(soap, &a->DialogID);
	soap_default_string(soap, &a->SDPMessage);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__inviteReq(struct soap *soap, const struct _ns1__inviteReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DialogID);
	soap_serialize_string(soap, &a->SDPMessage);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__inviteReq_Any);
			soap_serialize__ns1__inviteReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__inviteReq(struct soap *soap, const char *tag, int id, const struct _ns1__inviteReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__inviteReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_ns1__StreamType(soap, "ns1:StreamType", -1, &a->StreamType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DialogID", -1, &a->DialogID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SDPMessage", -1, &a->SDPMessage, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__inviteReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__inviteReq * SOAP_FMAC4 soap_in__ns1__inviteReq(struct soap *soap, const char *tag, struct _ns1__inviteReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_StreamType = 1;
	size_t soap_flag_DialogID = 1;
	size_t soap_flag_SDPMessage = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__inviteReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__inviteReq, sizeof(struct _ns1__inviteReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__inviteReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_StreamType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StreamType(soap, "ns1:StreamType", &a->StreamType, "ns1:StreamType"))
				{	soap_flag_StreamType--;
					continue;
				}
			if (soap_flag_DialogID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DialogID", &a->DialogID, "xsd:string"))
				{	soap_flag_DialogID--;
					continue;
				}
			if (soap_flag_SDPMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SDPMessage", &a->SDPMessage, "xsd:string"))
				{	soap_flag_SDPMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__inviteReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__inviteReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__inviteReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__inviteReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__inviteReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__inviteReq, 0, sizeof(struct _ns1__inviteReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_StreamType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__inviteReq(struct soap *soap, const struct _ns1__inviteReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__inviteReq);
	if (soap_out__ns1__inviteReq(soap, tag?tag:"ns1:inviteReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteReq * SOAP_FMAC4 soap_get__ns1__inviteReq(struct soap *soap, struct _ns1__inviteReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__inviteReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setAuxiliaryRes_Any(struct soap *soap, struct _ns1__setAuxiliaryRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setAuxiliaryRes_Any(struct soap *soap, const struct _ns1__setAuxiliaryRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setAuxiliaryRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setAuxiliaryRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setAuxiliaryRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes_Any * SOAP_FMAC4 soap_in__ns1__setAuxiliaryRes_Any(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setAuxiliaryRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setAuxiliaryRes_Any, sizeof(struct _ns1__setAuxiliaryRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setAuxiliaryRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setAuxiliaryRes_Any, 0, sizeof(struct _ns1__setAuxiliaryRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setAuxiliaryRes_Any(struct soap *soap, const struct _ns1__setAuxiliaryRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setAuxiliaryRes_Any);
	if (soap_out__ns1__setAuxiliaryRes_Any(soap, tag?tag:"ns1:setAuxiliaryRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes_Any * SOAP_FMAC4 soap_get__ns1__setAuxiliaryRes_Any(struct soap *soap, struct _ns1__setAuxiliaryRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setAuxiliaryRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setAuxiliaryRes(struct soap *soap, const struct _ns1__setAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setAuxiliaryRes_Any);
			soap_serialize__ns1__setAuxiliaryRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setAuxiliaryRes(struct soap *soap, const char *tag, int id, const struct _ns1__setAuxiliaryRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setAuxiliaryRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setAuxiliaryRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes * SOAP_FMAC4 soap_in__ns1__setAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setAuxiliaryRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setAuxiliaryRes, sizeof(struct _ns1__setAuxiliaryRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setAuxiliaryRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setAuxiliaryRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setAuxiliaryRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setAuxiliaryRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setAuxiliaryRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setAuxiliaryRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setAuxiliaryRes, 0, sizeof(struct _ns1__setAuxiliaryRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setAuxiliaryRes(struct soap *soap, const struct _ns1__setAuxiliaryRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setAuxiliaryRes);
	if (soap_out__ns1__setAuxiliaryRes(soap, tag?tag:"ns1:setAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes * SOAP_FMAC4 soap_get__ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setAuxiliaryReq_Any(struct soap *soap, struct _ns1__setAuxiliaryReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setAuxiliaryReq_Any(struct soap *soap, const struct _ns1__setAuxiliaryReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setAuxiliaryReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__setAuxiliaryReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setAuxiliaryReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq_Any * SOAP_FMAC4 soap_in__ns1__setAuxiliaryReq_Any(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setAuxiliaryReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setAuxiliaryReq_Any, sizeof(struct _ns1__setAuxiliaryReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setAuxiliaryReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setAuxiliaryReq_Any, 0, sizeof(struct _ns1__setAuxiliaryReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setAuxiliaryReq_Any(struct soap *soap, const struct _ns1__setAuxiliaryReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setAuxiliaryReq_Any);
	if (soap_out__ns1__setAuxiliaryReq_Any(soap, tag?tag:"ns1:setAuxiliaryReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq_Any * SOAP_FMAC4 soap_get__ns1__setAuxiliaryReq_Any(struct soap *soap, struct _ns1__setAuxiliaryReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setAuxiliaryReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->Auxiliary = NULL;
	a->AuxiliaryState = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__setAuxiliaryReq(struct soap *soap, const struct _ns1__setAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_PointerTons1__AuxiliaryType(soap, &a->Auxiliary);
	soap_serialize_PointerTons1__AuxiliaryState(soap, &a->AuxiliaryState);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__setAuxiliaryReq_Any);
			soap_serialize__ns1__setAuxiliaryReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setAuxiliaryReq(struct soap *soap, const char *tag, int id, const struct _ns1__setAuxiliaryReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setAuxiliaryReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuxiliaryType(soap, "ns1:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", -1, &a->AuxiliaryState, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__setAuxiliaryReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq * SOAP_FMAC4 soap_in__ns1__setAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Auxiliary = 1;
	size_t soap_flag_AuxiliaryState = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__setAuxiliaryReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setAuxiliaryReq, sizeof(struct _ns1__setAuxiliaryReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__setAuxiliaryReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuxiliaryType(soap, "ns1:Auxiliary", &a->Auxiliary, "ns1:AuxiliaryType"))
				{	soap_flag_Auxiliary--;
					continue;
				}
			if (soap_flag_AuxiliaryState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", &a->AuxiliaryState, "ns1:AuxiliaryState"))
				{	soap_flag_AuxiliaryState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__setAuxiliaryReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__setAuxiliaryReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__setAuxiliaryReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__setAuxiliaryReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__setAuxiliaryReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setAuxiliaryReq, 0, sizeof(struct _ns1__setAuxiliaryReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__setAuxiliaryReq(struct soap *soap, const struct _ns1__setAuxiliaryReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__setAuxiliaryReq);
	if (soap_out__ns1__setAuxiliaryReq(soap, tag?tag:"ns1:setAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq * SOAP_FMAC4 soap_get__ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAuxiliaryRes_Any(struct soap *soap, struct _ns1__getAuxiliaryRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAuxiliaryRes_Any(struct soap *soap, const struct _ns1__getAuxiliaryRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAuxiliaryRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getAuxiliaryRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAuxiliaryRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes_Any * SOAP_FMAC4 soap_in__ns1__getAuxiliaryRes_Any(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAuxiliaryRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAuxiliaryRes_Any, sizeof(struct _ns1__getAuxiliaryRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAuxiliaryRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAuxiliaryRes_Any, 0, sizeof(struct _ns1__getAuxiliaryRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAuxiliaryRes_Any(struct soap *soap, const struct _ns1__getAuxiliaryRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAuxiliaryRes_Any);
	if (soap_out__ns1__getAuxiliaryRes_Any(soap, tag?tag:"ns1:getAuxiliaryRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes_Any * SOAP_FMAC4 soap_get__ns1__getAuxiliaryRes_Any(struct soap *soap, struct _ns1__getAuxiliaryRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAuxiliaryRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->AuxiliaryState = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAuxiliaryRes(struct soap *soap, const struct _ns1__getAuxiliaryRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AuxiliaryState(soap, &a->AuxiliaryState);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getAuxiliaryRes_Any);
			soap_serialize__ns1__getAuxiliaryRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAuxiliaryRes(struct soap *soap, const char *tag, int id, const struct _ns1__getAuxiliaryRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAuxiliaryRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", -1, &a->AuxiliaryState, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getAuxiliaryRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes * SOAP_FMAC4 soap_in__ns1__getAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_AuxiliaryState = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAuxiliaryRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAuxiliaryRes, sizeof(struct _ns1__getAuxiliaryRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAuxiliaryRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_AuxiliaryState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuxiliaryState(soap, "ns1:AuxiliaryState", &a->AuxiliaryState, "ns1:AuxiliaryState"))
				{	soap_flag_AuxiliaryState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getAuxiliaryRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getAuxiliaryRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getAuxiliaryRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getAuxiliaryRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getAuxiliaryRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAuxiliaryRes, 0, sizeof(struct _ns1__getAuxiliaryRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAuxiliaryRes(struct soap *soap, const struct _ns1__getAuxiliaryRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAuxiliaryRes);
	if (soap_out__ns1__getAuxiliaryRes(soap, tag?tag:"ns1:getAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes * SOAP_FMAC4 soap_get__ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAuxiliaryReq_Any(struct soap *soap, struct _ns1__getAuxiliaryReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAuxiliaryReq_Any(struct soap *soap, const struct _ns1__getAuxiliaryReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAuxiliaryReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getAuxiliaryReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAuxiliaryReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq_Any * SOAP_FMAC4 soap_in__ns1__getAuxiliaryReq_Any(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAuxiliaryReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAuxiliaryReq_Any, sizeof(struct _ns1__getAuxiliaryReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAuxiliaryReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAuxiliaryReq_Any, 0, sizeof(struct _ns1__getAuxiliaryReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAuxiliaryReq_Any(struct soap *soap, const struct _ns1__getAuxiliaryReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAuxiliaryReq_Any);
	if (soap_out__ns1__getAuxiliaryReq_Any(soap, tag?tag:"ns1:getAuxiliaryReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq_Any * SOAP_FMAC4 soap_get__ns1__getAuxiliaryReq_Any(struct soap *soap, struct _ns1__getAuxiliaryReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAuxiliaryReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	soap_default_ns1__AuxiliaryType(soap, &a->Auxiliary);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAuxiliaryReq(struct soap *soap, const struct _ns1__getAuxiliaryReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->Auxiliary, SOAP_TYPE_ns1__AuxiliaryType);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getAuxiliaryReq_Any);
			soap_serialize__ns1__getAuxiliaryReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAuxiliaryReq(struct soap *soap, const char *tag, int id, const struct _ns1__getAuxiliaryReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAuxiliaryReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_ns1__AuxiliaryType(soap, "ns1:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getAuxiliaryReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq * SOAP_FMAC4 soap_in__ns1__getAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	size_t soap_flag_Auxiliary = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAuxiliaryReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAuxiliaryReq, sizeof(struct _ns1__getAuxiliaryReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAuxiliaryReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__AuxiliaryType(soap, "ns1:Auxiliary", &a->Auxiliary, "ns1:AuxiliaryType"))
				{	soap_flag_Auxiliary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getAuxiliaryReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getAuxiliaryReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getAuxiliaryReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getAuxiliaryReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getAuxiliaryReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAuxiliaryReq, 0, sizeof(struct _ns1__getAuxiliaryReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Auxiliary > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAuxiliaryReq(struct soap *soap, const struct _ns1__getAuxiliaryReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAuxiliaryReq);
	if (soap_out__ns1__getAuxiliaryReq(soap, tag?tag:"ns1:getAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq * SOAP_FMAC4 soap_get__ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getBackPasswordRes_Any(struct soap *soap, struct _ns1__getBackPasswordRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getBackPasswordRes_Any(struct soap *soap, const struct _ns1__getBackPasswordRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBackPasswordRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getBackPasswordRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBackPasswordRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes_Any * SOAP_FMAC4 soap_in__ns1__getBackPasswordRes_Any(struct soap *soap, const char *tag, struct _ns1__getBackPasswordRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getBackPasswordRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBackPasswordRes_Any, sizeof(struct _ns1__getBackPasswordRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getBackPasswordRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBackPasswordRes_Any, 0, sizeof(struct _ns1__getBackPasswordRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getBackPasswordRes_Any(struct soap *soap, const struct _ns1__getBackPasswordRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getBackPasswordRes_Any);
	if (soap_out__ns1__getBackPasswordRes_Any(soap, tag?tag:"ns1:getBackPasswordRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes_Any * SOAP_FMAC4 soap_get__ns1__getBackPasswordRes_Any(struct soap *soap, struct _ns1__getBackPasswordRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBackPasswordRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getBackPasswordRes(struct soap *soap, const struct _ns1__getBackPasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getBackPasswordRes_Any);
			soap_serialize__ns1__getBackPasswordRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBackPasswordRes(struct soap *soap, const char *tag, int id, const struct _ns1__getBackPasswordRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBackPasswordRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getBackPasswordRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes * SOAP_FMAC4 soap_in__ns1__getBackPasswordRes(struct soap *soap, const char *tag, struct _ns1__getBackPasswordRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getBackPasswordRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBackPasswordRes, sizeof(struct _ns1__getBackPasswordRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getBackPasswordRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getBackPasswordRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getBackPasswordRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getBackPasswordRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getBackPasswordRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getBackPasswordRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBackPasswordRes, 0, sizeof(struct _ns1__getBackPasswordRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getBackPasswordRes(struct soap *soap, const struct _ns1__getBackPasswordRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getBackPasswordRes);
	if (soap_out__ns1__getBackPasswordRes(soap, tag?tag:"ns1:getBackPasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes * SOAP_FMAC4 soap_get__ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBackPasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getBackPasswordReq_Any(struct soap *soap, struct _ns1__getBackPasswordReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getBackPasswordReq_Any(struct soap *soap, const struct _ns1__getBackPasswordReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBackPasswordReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getBackPasswordReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBackPasswordReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq_Any * SOAP_FMAC4 soap_in__ns1__getBackPasswordReq_Any(struct soap *soap, const char *tag, struct _ns1__getBackPasswordReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getBackPasswordReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBackPasswordReq_Any, sizeof(struct _ns1__getBackPasswordReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getBackPasswordReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBackPasswordReq_Any, 0, sizeof(struct _ns1__getBackPasswordReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getBackPasswordReq_Any(struct soap *soap, const struct _ns1__getBackPasswordReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getBackPasswordReq_Any);
	if (soap_out__ns1__getBackPasswordReq_Any(soap, tag?tag:"ns1:getBackPasswordReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq_Any * SOAP_FMAC4 soap_get__ns1__getBackPasswordReq_Any(struct soap *soap, struct _ns1__getBackPasswordReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBackPasswordReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_ns1__DeliveryType(soap, &a->GetBackType);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getBackPasswordReq(struct soap *soap, const struct _ns1__getBackPasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getBackPasswordReq_Any);
			soap_serialize__ns1__getBackPasswordReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getBackPasswordReq(struct soap *soap, const char *tag, int id, const struct _ns1__getBackPasswordReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getBackPasswordReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_ns1__DeliveryType(soap, "ns1:GetBackType", -1, &a->GetBackType, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getBackPasswordReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq * SOAP_FMAC4 soap_in__ns1__getBackPasswordReq(struct soap *soap, const char *tag, struct _ns1__getBackPasswordReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_GetBackType = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getBackPasswordReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getBackPasswordReq, sizeof(struct _ns1__getBackPasswordReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getBackPasswordReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_GetBackType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DeliveryType(soap, "ns1:GetBackType", &a->GetBackType, "ns1:DeliveryType"))
				{	soap_flag_GetBackType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getBackPasswordReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getBackPasswordReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getBackPasswordReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getBackPasswordReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getBackPasswordReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getBackPasswordReq, 0, sizeof(struct _ns1__getBackPasswordReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetBackType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getBackPasswordReq(struct soap *soap, const struct _ns1__getBackPasswordReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getBackPasswordReq);
	if (soap_out__ns1__getBackPasswordReq(soap, tag?tag:"ns1:getBackPasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq * SOAP_FMAC4 soap_get__ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getBackPasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountRes_Any(struct soap *soap, struct _ns1__getAccountRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountRes_Any(struct soap *soap, const struct _ns1__getAccountRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountRes_Any * SOAP_FMAC4 soap_in__ns1__getAccountRes_Any(struct soap *soap, const char *tag, struct _ns1__getAccountRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountRes_Any, sizeof(struct _ns1__getAccountRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountRes_Any, 0, sizeof(struct _ns1__getAccountRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountRes_Any(struct soap *soap, const struct _ns1__getAccountRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountRes_Any);
	if (soap_out__ns1__getAccountRes_Any(soap, tag?tag:"ns1:getAccountRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountRes_Any * SOAP_FMAC4 soap_get__ns1__getAccountRes_Any(struct soap *soap, struct _ns1__getAccountRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Email);
	soap_default_string(soap, &a->MobileTel);
	a->Country = NULL;
	a->CountryTelCode = NULL;
	soap_default_string(soap, &a->IDCard);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountRes(struct soap *soap, const struct _ns1__getAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Email);
	soap_serialize_string(soap, &a->MobileTel);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->Country);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->CountryTelCode);
	soap_serialize_string(soap, &a->IDCard);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getAccountRes_Any);
			soap_serialize__ns1__getAccountRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountRes(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Email", -1, &a->Email, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MobileTel", -1, &a->MobileTel, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", -1, &a->Country, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", -1, &a->CountryTelCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IDCard", -1, &a->IDCard, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getAccountRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountRes * SOAP_FMAC4 soap_in__ns1__getAccountRes(struct soap *soap, const char *tag, struct _ns1__getAccountRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Email = 1;
	size_t soap_flag_MobileTel = 1;
	size_t soap_flag_Country = 1;
	size_t soap_flag_CountryTelCode = 1;
	size_t soap_flag_IDCard = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountRes, sizeof(struct _ns1__getAccountRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Email", &a->Email, "xsd:string"))
				{	soap_flag_Email--;
					continue;
				}
			if (soap_flag_MobileTel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MobileTel", &a->MobileTel, "xsd:string"))
				{	soap_flag_MobileTel--;
					continue;
				}
			if (soap_flag_Country && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", &a->Country, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_Country--;
					continue;
				}
			if (soap_flag_CountryTelCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", &a->CountryTelCode, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_CountryTelCode--;
					continue;
				}
			if (soap_flag_IDCard && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IDCard", &a->IDCard, "xsd:string"))
				{	soap_flag_IDCard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getAccountRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getAccountRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getAccountRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getAccountRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getAccountRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountRes, 0, sizeof(struct _ns1__getAccountRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountRes(struct soap *soap, const struct _ns1__getAccountRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountRes);
	if (soap_out__ns1__getAccountRes(soap, tag?tag:"ns1:getAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountRes * SOAP_FMAC4 soap_get__ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountReq_Any(struct soap *soap, struct _ns1__getAccountReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountReq_Any(struct soap *soap, const struct _ns1__getAccountReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountReq_Any * SOAP_FMAC4 soap_in__ns1__getAccountReq_Any(struct soap *soap, const char *tag, struct _ns1__getAccountReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountReq_Any, sizeof(struct _ns1__getAccountReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountReq_Any, 0, sizeof(struct _ns1__getAccountReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountReq_Any(struct soap *soap, const struct _ns1__getAccountReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountReq_Any);
	if (soap_out__ns1__getAccountReq_Any(soap, tag?tag:"ns1:getAccountReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountReq_Any * SOAP_FMAC4 soap_get__ns1__getAccountReq_Any(struct soap *soap, struct _ns1__getAccountReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__getAccountReq(struct soap *soap, const struct _ns1__getAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__getAccountReq_Any);
			soap_serialize__ns1__getAccountReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getAccountReq(struct soap *soap, const char *tag, int id, const struct _ns1__getAccountReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getAccountReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__getAccountReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__getAccountReq * SOAP_FMAC4 soap_in__ns1__getAccountReq(struct soap *soap, const char *tag, struct _ns1__getAccountReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__getAccountReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getAccountReq, sizeof(struct _ns1__getAccountReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__getAccountReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__getAccountReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__getAccountReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__getAccountReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__getAccountReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__getAccountReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getAccountReq, 0, sizeof(struct _ns1__getAccountReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__getAccountReq(struct soap *soap, const struct _ns1__getAccountReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__getAccountReq);
	if (soap_out__ns1__getAccountReq(soap, tag?tag:"ns1:getAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountReq * SOAP_FMAC4 soap_get__ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAppleTokenRes_Any(struct soap *soap, struct _ns1__updateAppleTokenRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAppleTokenRes_Any(struct soap *soap, const struct _ns1__updateAppleTokenRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAppleTokenRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updateAppleTokenRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAppleTokenRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes_Any * SOAP_FMAC4 soap_in__ns1__updateAppleTokenRes_Any(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAppleTokenRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAppleTokenRes_Any, sizeof(struct _ns1__updateAppleTokenRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAppleTokenRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAppleTokenRes_Any, 0, sizeof(struct _ns1__updateAppleTokenRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAppleTokenRes_Any(struct soap *soap, const struct _ns1__updateAppleTokenRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAppleTokenRes_Any);
	if (soap_out__ns1__updateAppleTokenRes_Any(soap, tag?tag:"ns1:updateAppleTokenRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes_Any * SOAP_FMAC4 soap_get__ns1__updateAppleTokenRes_Any(struct soap *soap, struct _ns1__updateAppleTokenRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAppleTokenRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAppleTokenRes(struct soap *soap, const struct _ns1__updateAppleTokenRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updateAppleTokenRes_Any);
			soap_serialize__ns1__updateAppleTokenRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAppleTokenRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateAppleTokenRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAppleTokenRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updateAppleTokenRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes * SOAP_FMAC4 soap_in__ns1__updateAppleTokenRes(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAppleTokenRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAppleTokenRes, sizeof(struct _ns1__updateAppleTokenRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAppleTokenRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updateAppleTokenRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updateAppleTokenRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updateAppleTokenRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updateAppleTokenRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updateAppleTokenRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAppleTokenRes, 0, sizeof(struct _ns1__updateAppleTokenRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAppleTokenRes(struct soap *soap, const struct _ns1__updateAppleTokenRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAppleTokenRes);
	if (soap_out__ns1__updateAppleTokenRes(soap, tag?tag:"ns1:updateAppleTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes * SOAP_FMAC4 soap_get__ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAppleTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAppleTokenReq_Any(struct soap *soap, struct _ns1__updateAppleTokenReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAppleTokenReq_Any(struct soap *soap, const struct _ns1__updateAppleTokenReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAppleTokenReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updateAppleTokenReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAppleTokenReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq_Any * SOAP_FMAC4 soap_in__ns1__updateAppleTokenReq_Any(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAppleTokenReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAppleTokenReq_Any, sizeof(struct _ns1__updateAppleTokenReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAppleTokenReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAppleTokenReq_Any, 0, sizeof(struct _ns1__updateAppleTokenReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAppleTokenReq_Any(struct soap *soap, const struct _ns1__updateAppleTokenReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAppleTokenReq_Any);
	if (soap_out__ns1__updateAppleTokenReq_Any(soap, tag?tag:"ns1:updateAppleTokenReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq_Any * SOAP_FMAC4 soap_get__ns1__updateAppleTokenReq_Any(struct soap *soap, struct _ns1__updateAppleTokenReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAppleTokenReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->AppleUDID);
	soap_default_string(soap, &a->DeviceToken);
	soap_default_xsd__boolean(soap, &a->APNs);
	soap_default_string(soap, &a->AppleOS);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAppleTokenReq(struct soap *soap, const struct _ns1__updateAppleTokenReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->AppleUDID);
	soap_serialize_string(soap, &a->DeviceToken);
	soap_embedded(soap, &a->APNs, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->AppleOS);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updateAppleTokenReq_Any);
			soap_serialize__ns1__updateAppleTokenReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAppleTokenReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateAppleTokenReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAppleTokenReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppleUDID", -1, &a->AppleUDID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DeviceToken", -1, &a->DeviceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:APNs", -1, &a->APNs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AppleOS", -1, &a->AppleOS, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updateAppleTokenReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq * SOAP_FMAC4 soap_in__ns1__updateAppleTokenReq(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_AppleUDID = 1;
	size_t soap_flag_DeviceToken = 1;
	size_t soap_flag_APNs = 1;
	size_t soap_flag_AppleOS = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAppleTokenReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAppleTokenReq, sizeof(struct _ns1__updateAppleTokenReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAppleTokenReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_AppleUDID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppleUDID", &a->AppleUDID, "xsd:string"))
				{	soap_flag_AppleUDID--;
					continue;
				}
			if (soap_flag_DeviceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DeviceToken", &a->DeviceToken, "xsd:string"))
				{	soap_flag_DeviceToken--;
					continue;
				}
			if (soap_flag_APNs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:APNs", &a->APNs, "xsd:boolean"))
				{	soap_flag_APNs--;
					continue;
				}
			if (soap_flag_AppleOS && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AppleOS", &a->AppleOS, "xsd:string"))
				{	soap_flag_AppleOS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updateAppleTokenReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updateAppleTokenReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updateAppleTokenReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updateAppleTokenReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updateAppleTokenReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAppleTokenReq, 0, sizeof(struct _ns1__updateAppleTokenReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_APNs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAppleTokenReq(struct soap *soap, const struct _ns1__updateAppleTokenReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAppleTokenReq);
	if (soap_out__ns1__updateAppleTokenReq(soap, tag?tag:"ns1:updateAppleTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq * SOAP_FMAC4 soap_get__ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAppleTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceRes_Any(struct soap *soap, struct _ns1__queryDeviceRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceRes_Any(struct soap *soap, const struct _ns1__queryDeviceRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes_Any * SOAP_FMAC4 soap_in__ns1__queryDeviceRes_Any(struct soap *soap, const char *tag, struct _ns1__queryDeviceRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceRes_Any, sizeof(struct _ns1__queryDeviceRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceRes_Any, 0, sizeof(struct _ns1__queryDeviceRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceRes_Any(struct soap *soap, const struct _ns1__queryDeviceRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceRes_Any);
	if (soap_out__ns1__queryDeviceRes_Any(soap, tag?tag:"ns1:queryDeviceRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes_Any * SOAP_FMAC4 soap_get__ns1__queryDeviceRes_Any(struct soap *soap, struct _ns1__queryDeviceRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->NodeList = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceRes(struct soap *soap, const struct _ns1__queryDeviceRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ArrayOfNodeDetails(soap, &a->NodeList);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__queryDeviceRes_Any);
			soap_serialize__ns1__queryDeviceRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceRes(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfNodeDetails(soap, "ns1:NodeList", -1, &a->NodeList, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__queryDeviceRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes * SOAP_FMAC4 soap_in__ns1__queryDeviceRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	size_t soap_flag_NodeList = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceRes, sizeof(struct _ns1__queryDeviceRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_NodeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfNodeDetails(soap, "ns1:NodeList", &a->NodeList, "ns1:ArrayOfNodeDetails"))
				{	soap_flag_NodeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__queryDeviceRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__queryDeviceRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__queryDeviceRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__queryDeviceRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__queryDeviceRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceRes, 0, sizeof(struct _ns1__queryDeviceRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceRes(struct soap *soap, const struct _ns1__queryDeviceRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceRes);
	if (soap_out__ns1__queryDeviceRes(soap, tag?tag:"ns1:queryDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes * SOAP_FMAC4 soap_get__ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceReq_Any(struct soap *soap, struct _ns1__queryDeviceReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceReq_Any(struct soap *soap, const struct _ns1__queryDeviceReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq_Any * SOAP_FMAC4 soap_in__ns1__queryDeviceReq_Any(struct soap *soap, const char *tag, struct _ns1__queryDeviceReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceReq_Any, sizeof(struct _ns1__queryDeviceReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceReq_Any, 0, sizeof(struct _ns1__queryDeviceReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceReq_Any(struct soap *soap, const struct _ns1__queryDeviceReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceReq_Any);
	if (soap_out__ns1__queryDeviceReq_Any(soap, tag?tag:"ns1:queryDeviceReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq_Any * SOAP_FMAC4 soap_get__ns1__queryDeviceReq_Any(struct soap *soap, struct _ns1__queryDeviceReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->DevID);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__queryDeviceReq(struct soap *soap, const struct _ns1__queryDeviceReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->DevID);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__queryDeviceReq_Any);
			soap_serialize__ns1__queryDeviceReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__queryDeviceReq(struct soap *soap, const char *tag, int id, const struct _ns1__queryDeviceReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__queryDeviceReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__queryDeviceReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq * SOAP_FMAC4 soap_in__ns1__queryDeviceReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_DevID = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__queryDeviceReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__queryDeviceReq, sizeof(struct _ns1__queryDeviceReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__queryDeviceReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__queryDeviceReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__queryDeviceReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__queryDeviceReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__queryDeviceReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__queryDeviceReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__queryDeviceReq, 0, sizeof(struct _ns1__queryDeviceReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__queryDeviceReq(struct soap *soap, const struct _ns1__queryDeviceReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__queryDeviceReq);
	if (soap_out__ns1__queryDeviceReq(soap, tag?tag:"ns1:queryDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq * SOAP_FMAC4 soap_get__ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__queryDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updatePasswordRes_Any(struct soap *soap, struct _ns1__updatePasswordRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updatePasswordRes_Any(struct soap *soap, const struct _ns1__updatePasswordRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updatePasswordRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updatePasswordRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updatePasswordRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes_Any * SOAP_FMAC4 soap_in__ns1__updatePasswordRes_Any(struct soap *soap, const char *tag, struct _ns1__updatePasswordRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updatePasswordRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updatePasswordRes_Any, sizeof(struct _ns1__updatePasswordRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updatePasswordRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updatePasswordRes_Any, 0, sizeof(struct _ns1__updatePasswordRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updatePasswordRes_Any(struct soap *soap, const struct _ns1__updatePasswordRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updatePasswordRes_Any);
	if (soap_out__ns1__updatePasswordRes_Any(soap, tag?tag:"ns1:updatePasswordRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes_Any * SOAP_FMAC4 soap_get__ns1__updatePasswordRes_Any(struct soap *soap, struct _ns1__updatePasswordRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updatePasswordRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updatePasswordRes(struct soap *soap, const struct _ns1__updatePasswordRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updatePasswordRes_Any);
			soap_serialize__ns1__updatePasswordRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updatePasswordRes(struct soap *soap, const char *tag, int id, const struct _ns1__updatePasswordRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updatePasswordRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updatePasswordRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes * SOAP_FMAC4 soap_in__ns1__updatePasswordRes(struct soap *soap, const char *tag, struct _ns1__updatePasswordRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updatePasswordRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updatePasswordRes, sizeof(struct _ns1__updatePasswordRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updatePasswordRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updatePasswordRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updatePasswordRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updatePasswordRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updatePasswordRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updatePasswordRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updatePasswordRes, 0, sizeof(struct _ns1__updatePasswordRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updatePasswordRes(struct soap *soap, const struct _ns1__updatePasswordRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updatePasswordRes);
	if (soap_out__ns1__updatePasswordRes(soap, tag?tag:"ns1:updatePasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes * SOAP_FMAC4 soap_get__ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updatePasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updatePasswordReq_Any(struct soap *soap, struct _ns1__updatePasswordReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updatePasswordReq_Any(struct soap *soap, const struct _ns1__updatePasswordReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updatePasswordReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updatePasswordReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updatePasswordReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq_Any * SOAP_FMAC4 soap_in__ns1__updatePasswordReq_Any(struct soap *soap, const char *tag, struct _ns1__updatePasswordReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updatePasswordReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updatePasswordReq_Any, sizeof(struct _ns1__updatePasswordReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updatePasswordReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updatePasswordReq_Any, 0, sizeof(struct _ns1__updatePasswordReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updatePasswordReq_Any(struct soap *soap, const struct _ns1__updatePasswordReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updatePasswordReq_Any);
	if (soap_out__ns1__updatePasswordReq_Any(soap, tag?tag:"ns1:updatePasswordReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq_Any * SOAP_FMAC4 soap_get__ns1__updatePasswordReq_Any(struct soap *soap, struct _ns1__updatePasswordReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updatePasswordReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->NewPassword);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updatePasswordReq(struct soap *soap, const struct _ns1__updatePasswordReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->NewPassword);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updatePasswordReq_Any);
			soap_serialize__ns1__updatePasswordReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updatePasswordReq(struct soap *soap, const char *tag, int id, const struct _ns1__updatePasswordReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updatePasswordReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:NewPassword", -1, &a->NewPassword, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updatePasswordReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq * SOAP_FMAC4 soap_in__ns1__updatePasswordReq(struct soap *soap, const char *tag, struct _ns1__updatePasswordReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_NewPassword = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updatePasswordReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updatePasswordReq, sizeof(struct _ns1__updatePasswordReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updatePasswordReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_NewPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NewPassword", &a->NewPassword, "xsd:string"))
				{	soap_flag_NewPassword--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updatePasswordReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updatePasswordReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updatePasswordReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updatePasswordReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updatePasswordReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updatePasswordReq, 0, sizeof(struct _ns1__updatePasswordReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updatePasswordReq(struct soap *soap, const struct _ns1__updatePasswordReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updatePasswordReq);
	if (soap_out__ns1__updatePasswordReq(soap, tag?tag:"ns1:updatePasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq * SOAP_FMAC4 soap_get__ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updatePasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountRes_Any(struct soap *soap, struct _ns1__updateAccountRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountRes_Any(struct soap *soap, const struct _ns1__updateAccountRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountRes_Any * SOAP_FMAC4 soap_in__ns1__updateAccountRes_Any(struct soap *soap, const char *tag, struct _ns1__updateAccountRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountRes_Any, sizeof(struct _ns1__updateAccountRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountRes_Any, 0, sizeof(struct _ns1__updateAccountRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountRes_Any(struct soap *soap, const struct _ns1__updateAccountRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountRes_Any);
	if (soap_out__ns1__updateAccountRes_Any(soap, tag?tag:"ns1:updateAccountRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountRes_Any * SOAP_FMAC4 soap_get__ns1__updateAccountRes_Any(struct soap *soap, struct _ns1__updateAccountRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountRes(struct soap *soap, const struct _ns1__updateAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updateAccountRes_Any);
			soap_serialize__ns1__updateAccountRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountRes(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updateAccountRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountRes * SOAP_FMAC4 soap_in__ns1__updateAccountRes(struct soap *soap, const char *tag, struct _ns1__updateAccountRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountRes, sizeof(struct _ns1__updateAccountRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updateAccountRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updateAccountRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updateAccountRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updateAccountRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updateAccountRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountRes, 0, sizeof(struct _ns1__updateAccountRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountRes(struct soap *soap, const struct _ns1__updateAccountRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountRes);
	if (soap_out__ns1__updateAccountRes(soap, tag?tag:"ns1:updateAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountRes * SOAP_FMAC4 soap_get__ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountReq_Any(struct soap *soap, struct _ns1__updateAccountReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountReq_Any(struct soap *soap, const struct _ns1__updateAccountReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountReq_Any * SOAP_FMAC4 soap_in__ns1__updateAccountReq_Any(struct soap *soap, const char *tag, struct _ns1__updateAccountReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountReq_Any, sizeof(struct _ns1__updateAccountReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountReq_Any, 0, sizeof(struct _ns1__updateAccountReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountReq_Any(struct soap *soap, const struct _ns1__updateAccountReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountReq_Any);
	if (soap_out__ns1__updateAccountReq_Any(soap, tag?tag:"ns1:updateAccountReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountReq_Any * SOAP_FMAC4 soap_get__ns1__updateAccountReq_Any(struct soap *soap, struct _ns1__updateAccountReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->LoginSession);
	soap_default_string(soap, &a->Username);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__updateAccountReq(struct soap *soap, const struct _ns1__updateAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->LoginSession);
	soap_serialize_string(soap, &a->Username);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__updateAccountReq_Any);
			soap_serialize__ns1__updateAccountReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__updateAccountReq(struct soap *soap, const char *tag, int id, const struct _ns1__updateAccountReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__updateAccountReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LoginSession", -1, &a->LoginSession, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__updateAccountReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__updateAccountReq * SOAP_FMAC4 soap_in__ns1__updateAccountReq(struct soap *soap, const char *tag, struct _ns1__updateAccountReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_LoginSession = 1;
	size_t soap_flag_Username = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__updateAccountReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__updateAccountReq, sizeof(struct _ns1__updateAccountReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__updateAccountReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_LoginSession && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginSession", &a->LoginSession, "xsd:string"))
				{	soap_flag_LoginSession--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__updateAccountReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__updateAccountReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__updateAccountReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__updateAccountReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__updateAccountReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__updateAccountReq, 0, sizeof(struct _ns1__updateAccountReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__updateAccountReq(struct soap *soap, const struct _ns1__updateAccountReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__updateAccountReq);
	if (soap_out__ns1__updateAccountReq(soap, tag?tag:"ns1:updateAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountReq * SOAP_FMAC4 soap_get__ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__updateAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createAccountRes_Any(struct soap *soap, struct _ns1__createAccountRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createAccountRes_Any(struct soap *soap, const struct _ns1__createAccountRes_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createAccountRes_Any(struct soap *soap, const char *tag, int id, const struct _ns1__createAccountRes_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createAccountRes_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createAccountRes_Any * SOAP_FMAC4 soap_in__ns1__createAccountRes_Any(struct soap *soap, const char *tag, struct _ns1__createAccountRes_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__createAccountRes_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createAccountRes_Any, sizeof(struct _ns1__createAccountRes_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createAccountRes_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountRes_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createAccountRes_Any, 0, sizeof(struct _ns1__createAccountRes_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createAccountRes_Any(struct soap *soap, const struct _ns1__createAccountRes_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__createAccountRes_Any);
	if (soap_out__ns1__createAccountRes_Any(soap, tag?tag:"ns1:createAccountRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountRes_Any * SOAP_FMAC4 soap_get__ns1__createAccountRes_Any(struct soap *soap, struct _ns1__createAccountRes_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createAccountRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns1__MCUResult(soap, &a->result);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createAccountRes(struct soap *soap, const struct _ns1__createAccountRes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__createAccountRes_Any);
			soap_serialize__ns1__createAccountRes_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createAccountRes(struct soap *soap, const char *tag, int id, const struct _ns1__createAccountRes *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createAccountRes), type))
		return soap->error;
	soap_element_result(soap, "ns1:result");
	if (soap_out_ns1__MCUResult(soap, "ns1:result", -1, &a->result, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__createAccountRes_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createAccountRes * SOAP_FMAC4 soap_in__ns1__createAccountRes(struct soap *soap, const char *tag, struct _ns1__createAccountRes *a, const char *type)
{
	size_t soap_flag_result = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__createAccountRes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createAccountRes, sizeof(struct _ns1__createAccountRes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createAccountRes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MCUResult(soap, "ns1:result", &a->result, "ns1:MCUResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__createAccountRes_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__createAccountRes_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__createAccountRes_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__createAccountRes_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__createAccountRes_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountRes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createAccountRes, 0, sizeof(struct _ns1__createAccountRes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createAccountRes(struct soap *soap, const struct _ns1__createAccountRes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__createAccountRes);
	if (soap_out__ns1__createAccountRes(soap, tag?tag:"ns1:createAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountRes * SOAP_FMAC4 soap_get__ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createAccountReq_Any(struct soap *soap, struct _ns1__createAccountReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createAccountReq_Any(struct soap *soap, const struct _ns1__createAccountReq_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createAccountReq_Any(struct soap *soap, const char *tag, int id, const struct _ns1__createAccountReq_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createAccountReq_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createAccountReq_Any * SOAP_FMAC4 soap_in__ns1__createAccountReq_Any(struct soap *soap, const char *tag, struct _ns1__createAccountReq_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__createAccountReq_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createAccountReq_Any, sizeof(struct _ns1__createAccountReq_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createAccountReq_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountReq_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createAccountReq_Any, 0, sizeof(struct _ns1__createAccountReq_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createAccountReq_Any(struct soap *soap, const struct _ns1__createAccountReq_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__createAccountReq_Any);
	if (soap_out__ns1__createAccountReq_Any(soap, tag?tag:"ns1:createAccountReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountReq_Any * SOAP_FMAC4 soap_get__ns1__createAccountReq_Any(struct soap *soap, struct _ns1__createAccountReq_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createAccountReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Account);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_string(soap, &a->Email);
	soap_default_string(soap, &a->MobileTel);
	a->SecurityQuestion = NULL;
	soap_default_string(soap, &a->SecurityAnswer);
	a->Country = NULL;
	a->CountryTelCode = NULL;
	soap_default_string(soap, &a->IDCard);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__createAccountReq(struct soap *soap, const struct _ns1__createAccountReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Account);
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_string(soap, &a->Email);
	soap_serialize_string(soap, &a->MobileTel);
	soap_serialize_PointerToint(soap, &a->SecurityQuestion);
	soap_serialize_string(soap, &a->SecurityAnswer);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->Country);
	soap_serialize_PointerTons1__CountryAbbr2ISO3166(soap, &a->CountryTelCode);
	soap_serialize_string(soap, &a->IDCard);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__createAccountReq_Any);
			soap_serialize__ns1__createAccountReq_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__createAccountReq(struct soap *soap, const char *tag, int id, const struct _ns1__createAccountReq *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__createAccountReq), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:Account", -1, &a->Account, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Email", -1, &a->Email, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:MobileTel", -1, &a->MobileTel, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:SecurityQuestion", -1, &a->SecurityQuestion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:SecurityAnswer", -1, &a->SecurityAnswer, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", -1, &a->Country, ""))
		return soap->error;
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", -1, &a->CountryTelCode, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:IDCard", -1, &a->IDCard, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__createAccountReq_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__createAccountReq * SOAP_FMAC4 soap_in__ns1__createAccountReq(struct soap *soap, const char *tag, struct _ns1__createAccountReq *a, const char *type)
{
	size_t soap_flag_Account = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Email = 1;
	size_t soap_flag_MobileTel = 1;
	size_t soap_flag_SecurityQuestion = 1;
	size_t soap_flag_SecurityAnswer = 1;
	size_t soap_flag_Country = 1;
	size_t soap_flag_CountryTelCode = 1;
	size_t soap_flag_IDCard = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__createAccountReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__createAccountReq, sizeof(struct _ns1__createAccountReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__createAccountReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Account", &a->Account, "xsd:string"))
				{	soap_flag_Account--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Email", &a->Email, "xsd:string"))
				{	soap_flag_Email--;
					continue;
				}
			if (soap_flag_MobileTel && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:MobileTel", &a->MobileTel, "xsd:string"))
				{	soap_flag_MobileTel--;
					continue;
				}
			if (soap_flag_SecurityQuestion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:SecurityQuestion", &a->SecurityQuestion, "xsd:int"))
				{	soap_flag_SecurityQuestion--;
					continue;
				}
			if (soap_flag_SecurityAnswer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SecurityAnswer", &a->SecurityAnswer, "xsd:string"))
				{	soap_flag_SecurityAnswer--;
					continue;
				}
			if (soap_flag_Country && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:Country", &a->Country, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_Country--;
					continue;
				}
			if (soap_flag_CountryTelCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CountryAbbr2ISO3166(soap, "ns1:CountryTelCode", &a->CountryTelCode, "ns1:CountryAbbr2ISO3166"))
				{	soap_flag_CountryTelCode--;
					continue;
				}
			if (soap_flag_IDCard && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IDCard", &a->IDCard, "xsd:string"))
				{	soap_flag_IDCard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__createAccountReq_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__createAccountReq_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__createAccountReq_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__createAccountReq_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__createAccountReq_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__createAccountReq, 0, sizeof(struct _ns1__createAccountReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__createAccountReq(struct soap *soap, const struct _ns1__createAccountReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__createAccountReq);
	if (soap_out__ns1__createAccountReq(soap, tag?tag:"ns1:createAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountReq * SOAP_FMAC4 soap_get__ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__createAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__VODRecord_Any(struct soap *soap, struct _ns1__VODRecord_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__VODRecord_Any(struct soap *soap, const struct _ns1__VODRecord_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__VODRecord_Any(struct soap *soap, const char *tag, int id, const struct _ns1__VODRecord_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__VODRecord_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__VODRecord_Any * SOAP_FMAC4 soap_in__ns1__VODRecord_Any(struct soap *soap, const char *tag, struct _ns1__VODRecord_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__VODRecord_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__VODRecord_Any, sizeof(struct _ns1__VODRecord_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__VODRecord_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__VODRecord_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__VODRecord_Any, 0, sizeof(struct _ns1__VODRecord_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__VODRecord_Any(struct soap *soap, const struct _ns1__VODRecord_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__VODRecord_Any);
	if (soap_out__ns1__VODRecord_Any(soap, tag?tag:"ns1:VODRecord-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__VODRecord_Any * SOAP_FMAC4 soap_get__ns1__VODRecord_Any(struct soap *soap, struct _ns1__VODRecord_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__VODRecord_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VODRecord(struct soap *soap, struct ns1__VODRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->StartTime);
	soap_default_time(soap, &a->EndTime);
	a->FileSize = NULL;
	soap_default_string(soap, &a->ContentType);
	soap_default_string(soap, &a->Desc);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VODRecord(struct soap *soap, const struct ns1__VODRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->EndTime, SOAP_TYPE_time);
	soap_serialize_PointerToLONG64(soap, &a->FileSize);
	soap_serialize_string(soap, &a->ContentType);
	soap_serialize_string(soap, &a->Desc);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__VODRecord_Any);
			soap_serialize__ns1__VODRecord_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VODRecord(struct soap *soap, const char *tag, int id, const struct ns1__VODRecord *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VODRecord), type))
		return soap->error;
	if (soap_out_time(soap, "ns1:StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:EndTime", -1, &a->EndTime, ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns1:FileSize", -1, &a->FileSize, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ContentType", -1, &a->ContentType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Desc", -1, &a->Desc, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__VODRecord_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VODRecord * SOAP_FMAC4 soap_in_ns1__VODRecord(struct soap *soap, const char *tag, struct ns1__VODRecord *a, const char *type)
{
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_EndTime = 1;
	size_t soap_flag_FileSize = 1;
	size_t soap_flag_ContentType = 1;
	size_t soap_flag_Desc = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VODRecord *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VODRecord, sizeof(struct ns1__VODRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VODRecord(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_EndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:EndTime", &a->EndTime, "xsd:dateTime"))
				{	soap_flag_EndTime--;
					continue;
				}
			if (soap_flag_FileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns1:FileSize", &a->FileSize, "xsd:long"))
				{	soap_flag_FileSize--;
					continue;
				}
			if (soap_flag_ContentType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ContentType", &a->ContentType, "xsd:string"))
				{	soap_flag_ContentType--;
					continue;
				}
			if (soap_flag_Desc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Desc", &a->Desc, "xsd:string"))
				{	soap_flag_Desc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__VODRecord_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__VODRecord_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__VODRecord_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__VODRecord_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__VODRecord_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VODRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VODRecord, 0, sizeof(struct ns1__VODRecord), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_EndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VODRecord(struct soap *soap, const struct ns1__VODRecord *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VODRecord);
	if (soap_out_ns1__VODRecord(soap, tag?tag:"ns1:VODRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VODRecord * SOAP_FMAC4 soap_get_ns1__VODRecord(struct soap *soap, struct ns1__VODRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VODRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__PrivacyMaskRegion_Any(struct soap *soap, struct _ns1__PrivacyMaskRegion_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__PrivacyMaskRegion_Any(struct soap *soap, const struct _ns1__PrivacyMaskRegion_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PrivacyMaskRegion_Any(struct soap *soap, const char *tag, int id, const struct _ns1__PrivacyMaskRegion_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PrivacyMaskRegion_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__PrivacyMaskRegion_Any * SOAP_FMAC4 soap_in__ns1__PrivacyMaskRegion_Any(struct soap *soap, const char *tag, struct _ns1__PrivacyMaskRegion_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__PrivacyMaskRegion_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PrivacyMaskRegion_Any, sizeof(struct _ns1__PrivacyMaskRegion_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__PrivacyMaskRegion_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__PrivacyMaskRegion_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PrivacyMaskRegion_Any, 0, sizeof(struct _ns1__PrivacyMaskRegion_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__PrivacyMaskRegion_Any(struct soap *soap, const struct _ns1__PrivacyMaskRegion_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__PrivacyMaskRegion_Any);
	if (soap_out__ns1__PrivacyMaskRegion_Any(soap, tag?tag:"ns1:PrivacyMaskRegion-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__PrivacyMaskRegion_Any * SOAP_FMAC4 soap_get__ns1__PrivacyMaskRegion_Any(struct soap *soap, struct _ns1__PrivacyMaskRegion_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PrivacyMaskRegion_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Left);
	soap_default_int(soap, &a->Top);
	soap_default_int(soap, &a->Right);
	soap_default_int(soap, &a->Bottom);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PrivacyMaskRegion(struct soap *soap, const struct ns1__PrivacyMaskRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Left, SOAP_TYPE_int);
	soap_embedded(soap, &a->Top, SOAP_TYPE_int);
	soap_embedded(soap, &a->Right, SOAP_TYPE_int);
	soap_embedded(soap, &a->Bottom, SOAP_TYPE_int);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__PrivacyMaskRegion_Any);
			soap_serialize__ns1__PrivacyMaskRegion_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PrivacyMaskRegion(struct soap *soap, const char *tag, int id, const struct ns1__PrivacyMaskRegion *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PrivacyMaskRegion), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:Left", -1, &a->Left, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Top", -1, &a->Top, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Right", -1, &a->Right, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:Bottom", -1, &a->Bottom, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__PrivacyMaskRegion_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion * SOAP_FMAC4 soap_in_ns1__PrivacyMaskRegion(struct soap *soap, const char *tag, struct ns1__PrivacyMaskRegion *a, const char *type)
{
	size_t soap_flag_Left = 1;
	size_t soap_flag_Top = 1;
	size_t soap_flag_Right = 1;
	size_t soap_flag_Bottom = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PrivacyMaskRegion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PrivacyMaskRegion, sizeof(struct ns1__PrivacyMaskRegion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PrivacyMaskRegion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Left && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Left", &a->Left, "xsd:int"))
				{	soap_flag_Left--;
					continue;
				}
			if (soap_flag_Top && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Top", &a->Top, "xsd:int"))
				{	soap_flag_Top--;
					continue;
				}
			if (soap_flag_Right && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Right", &a->Right, "xsd:int"))
				{	soap_flag_Right--;
					continue;
				}
			if (soap_flag_Bottom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Bottom", &a->Bottom, "xsd:int"))
				{	soap_flag_Bottom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__PrivacyMaskRegion_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__PrivacyMaskRegion_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__PrivacyMaskRegion_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__PrivacyMaskRegion_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__PrivacyMaskRegion_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PrivacyMaskRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PrivacyMaskRegion, 0, sizeof(struct ns1__PrivacyMaskRegion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Left > 0 || soap_flag_Top > 0 || soap_flag_Right > 0 || soap_flag_Bottom > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PrivacyMaskRegion(struct soap *soap, const struct ns1__PrivacyMaskRegion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PrivacyMaskRegion);
	if (soap_out_ns1__PrivacyMaskRegion(soap, tag?tag:"ns1:PrivacyMaskRegion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion * SOAP_FMAC4 soap_get_ns1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PrivacyMaskRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__VMDGrid_Any(struct soap *soap, struct _ns1__VMDGrid_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__VMDGrid_Any(struct soap *soap, const struct _ns1__VMDGrid_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__VMDGrid_Any(struct soap *soap, const char *tag, int id, const struct _ns1__VMDGrid_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__VMDGrid_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__VMDGrid_Any * SOAP_FMAC4 soap_in__ns1__VMDGrid_Any(struct soap *soap, const char *tag, struct _ns1__VMDGrid_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__VMDGrid_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__VMDGrid_Any, sizeof(struct _ns1__VMDGrid_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__VMDGrid_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__VMDGrid_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__VMDGrid_Any, 0, sizeof(struct _ns1__VMDGrid_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__VMDGrid_Any(struct soap *soap, const struct _ns1__VMDGrid_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__VMDGrid_Any);
	if (soap_out__ns1__VMDGrid_Any(soap, tag?tag:"ns1:VMDGrid-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__VMDGrid_Any * SOAP_FMAC4 soap_get__ns1__VMDGrid_Any(struct soap *soap, struct _ns1__VMDGrid_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__VMDGrid_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRow = 0;
	a->Row = NULL;
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VMDGrid(struct soap *soap, const struct ns1__VMDGrid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Row)
	{	int i;
		for (i = 0; i < a->__sizeRow; i++)
		{
			soap_serialize_string(soap, a->Row + i);
		}
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__VMDGrid_Any);
			soap_serialize__ns1__VMDGrid_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VMDGrid(struct soap *soap, const char *tag, int id, const struct ns1__VMDGrid *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VMDGrid), type))
		return soap->error;
	if (a->Row)
	{	int i;
		for (i = 0; i < a->__sizeRow; i++)
			if (soap_out_string(soap, "ns1:Row", -1, a->Row + i, ""))
				return soap->error;
	}
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__VMDGrid_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VMDGrid * SOAP_FMAC4 soap_in_ns1__VMDGrid(struct soap *soap, const char *tag, struct ns1__VMDGrid *a, const char *type)
{
	struct soap_blist *soap_blist_Row = NULL;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VMDGrid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VMDGrid, sizeof(struct ns1__VMDGrid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VMDGrid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Row", 1, NULL))
			{	if (a->Row == NULL)
				{	if (soap_blist_Row == NULL)
						soap_blist_Row = soap_new_block(soap);
					a->Row = (char **)soap_push_block(soap, soap_blist_Row, sizeof(char *));
					if (a->Row == NULL)
						return NULL;
					*a->Row = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns1:Row", a->Row, "xsd:string"))
				{	a->__sizeRow++;
					a->Row = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__VMDGrid_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__VMDGrid_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__VMDGrid_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__VMDGrid_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Row)
			soap_pop_block(soap, soap_blist_Row);
		if (a->__sizeRow)
			a->Row = (char **)soap_save_block(soap, soap_blist_Row, NULL, 1);
		else
		{	a->Row = NULL;
			if (soap_blist_Row)
				soap_end_block(soap, soap_blist_Row);
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__VMDGrid_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VMDGrid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VMDGrid, 0, sizeof(struct ns1__VMDGrid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VMDGrid(struct soap *soap, const struct ns1__VMDGrid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VMDGrid);
	if (soap_out_ns1__VMDGrid(soap, tag?tag:"ns1:VMDGrid", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VMDGrid * SOAP_FMAC4 soap_get_ns1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VMDGrid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__DevLog_Any(struct soap *soap, struct _ns1__DevLog_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__DevLog_Any(struct soap *soap, const struct _ns1__DevLog_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DevLog_Any(struct soap *soap, const char *tag, int id, const struct _ns1__DevLog_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DevLog_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__DevLog_Any * SOAP_FMAC4 soap_in__ns1__DevLog_Any(struct soap *soap, const char *tag, struct _ns1__DevLog_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__DevLog_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DevLog_Any, sizeof(struct _ns1__DevLog_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__DevLog_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__DevLog_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DevLog_Any, 0, sizeof(struct _ns1__DevLog_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__DevLog_Any(struct soap *soap, const struct _ns1__DevLog_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__DevLog_Any);
	if (soap_out__ns1__DevLog_Any(soap, tag?tag:"ns1:DevLog-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DevLog_Any * SOAP_FMAC4 soap_get__ns1__DevLog_Any(struct soap *soap, struct _ns1__DevLog_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DevLog_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DevLog(struct soap *soap, struct ns1__DevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->ChannelName);
	soap_default_int(soap, &a->LogType);
	soap_default_string(soap, &a->LogDesc);
	soap_default_time(soap, &a->LogTime);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DevLog(struct soap *soap, const struct ns1__DevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ChannelName);
	soap_embedded(soap, &a->LogType, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->LogDesc);
	soap_embedded(soap, &a->LogTime, SOAP_TYPE_time);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__DevLog_Any);
			soap_serialize__ns1__DevLog_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DevLog(struct soap *soap, const char *tag, int id, const struct ns1__DevLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DevLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ChannelName", -1, &a->ChannelName, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:LogType", -1, &a->LogType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LogDesc", -1, &a->LogDesc, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LogTime", -1, &a->LogTime, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__DevLog_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DevLog * SOAP_FMAC4 soap_in_ns1__DevLog(struct soap *soap, const char *tag, struct ns1__DevLog *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_ChannelName = 1;
	size_t soap_flag_LogType = 1;
	size_t soap_flag_LogDesc = 1;
	size_t soap_flag_LogTime = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DevLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DevLog, sizeof(struct ns1__DevLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DevLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_ChannelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ChannelName", &a->ChannelName, "xsd:string"))
				{	soap_flag_ChannelName--;
					continue;
				}
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:LogType", &a->LogType, "xsd:int"))
				{	soap_flag_LogType--;
					continue;
				}
			if (soap_flag_LogDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LogDesc", &a->LogDesc, "xsd:string"))
				{	soap_flag_LogDesc--;
					continue;
				}
			if (soap_flag_LogTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LogTime", &a->LogTime, "xsd:dateTime"))
				{	soap_flag_LogTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__DevLog_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__DevLog_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__DevLog_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__DevLog_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__DevLog_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DevLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DevLog, 0, sizeof(struct ns1__DevLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_LogType > 0 || soap_flag_LogTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DevLog(struct soap *soap, const struct ns1__DevLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DevLog);
	if (soap_out_ns1__DevLog(soap, tag?tag:"ns1:DevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DevLog * SOAP_FMAC4 soap_get_ns1__DevLog(struct soap *soap, struct ns1__DevLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDevLog = 0;
	a->DevLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDevLog(struct soap *soap, const struct ns1__ArrayOfDevLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->DevLog)
	{	int i;
		for (i = 0; i < a->__sizeDevLog; i++)
		{
			soap_embedded(soap, a->DevLog + i, SOAP_TYPE_ns1__DevLog);
			soap_serialize_ns1__DevLog(soap, a->DevLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDevLog(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDevLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDevLog), type))
		return soap->error;
	if (a->DevLog)
	{	int i;
		for (i = 0; i < a->__sizeDevLog; i++)
			if (soap_out_ns1__DevLog(soap, "ns1:DevLog", -1, a->DevLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog * SOAP_FMAC4 soap_in_ns1__ArrayOfDevLog(struct soap *soap, const char *tag, struct ns1__ArrayOfDevLog *a, const char *type)
{
	struct soap_blist *soap_blist_DevLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDevLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDevLog, sizeof(struct ns1__ArrayOfDevLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDevLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:DevLog", 1, NULL))
			{	if (a->DevLog == NULL)
				{	if (soap_blist_DevLog == NULL)
						soap_blist_DevLog = soap_new_block(soap);
					a->DevLog = (struct ns1__DevLog *)soap_push_block(soap, soap_blist_DevLog, sizeof(struct ns1__DevLog));
					if (a->DevLog == NULL)
						return NULL;
					soap_default_ns1__DevLog(soap, a->DevLog);
				}
				soap_revert(soap);
				if (soap_in_ns1__DevLog(soap, "ns1:DevLog", a->DevLog, "ns1:DevLog"))
				{	a->__sizeDevLog++;
					a->DevLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DevLog)
			soap_pop_block(soap, soap_blist_DevLog);
		if (a->__sizeDevLog)
			a->DevLog = (struct ns1__DevLog *)soap_save_block(soap, soap_blist_DevLog, NULL, 1);
		else
		{	a->DevLog = NULL;
			if (soap_blist_DevLog)
				soap_end_block(soap, soap_blist_DevLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDevLog, 0, sizeof(struct ns1__ArrayOfDevLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDevLog(struct soap *soap, const struct ns1__ArrayOfDevLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDevLog);
	if (soap_out_ns1__ArrayOfDevLog(soap, tag?tag:"ns1:ArrayOfDevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog * SOAP_FMAC4 soap_get_ns1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__PuLog_Any(struct soap *soap, struct _ns1__PuLog_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__PuLog_Any(struct soap *soap, const struct _ns1__PuLog_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PuLog_Any(struct soap *soap, const char *tag, int id, const struct _ns1__PuLog_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PuLog_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__PuLog_Any * SOAP_FMAC4 soap_in__ns1__PuLog_Any(struct soap *soap, const char *tag, struct _ns1__PuLog_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__PuLog_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PuLog_Any, sizeof(struct _ns1__PuLog_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__PuLog_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__PuLog_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PuLog_Any, 0, sizeof(struct _ns1__PuLog_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__PuLog_Any(struct soap *soap, const struct _ns1__PuLog_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__PuLog_Any);
	if (soap_out__ns1__PuLog_Any(soap, tag?tag:"ns1:PuLog-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__PuLog_Any * SOAP_FMAC4 soap_get__ns1__PuLog_Any(struct soap *soap, struct _ns1__PuLog_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PuLog_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PuLog(struct soap *soap, struct ns1__PuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->ChannelName);
	soap_default_int(soap, &a->LogType);
	soap_default_string(soap, &a->LogDesc);
	soap_default_string(soap, &a->AddTime);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PuLog(struct soap *soap, const struct ns1__PuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->ChannelName);
	soap_embedded(soap, &a->LogType, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->LogDesc);
	soap_serialize_string(soap, &a->AddTime);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__PuLog_Any);
			soap_serialize__ns1__PuLog_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PuLog(struct soap *soap, const char *tag, int id, const struct ns1__PuLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PuLog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:ChannelName", -1, &a->ChannelName, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:LogType", -1, &a->LogType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:LogDesc", -1, &a->LogDesc, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:AddTime", -1, &a->AddTime, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__PuLog_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__PuLog * SOAP_FMAC4 soap_in_ns1__PuLog(struct soap *soap, const char *tag, struct ns1__PuLog *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_ChannelName = 1;
	size_t soap_flag_LogType = 1;
	size_t soap_flag_LogDesc = 1;
	size_t soap_flag_AddTime = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__PuLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PuLog, sizeof(struct ns1__PuLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__PuLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_ChannelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ChannelName", &a->ChannelName, "xsd:string"))
				{	soap_flag_ChannelName--;
					continue;
				}
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:LogType", &a->LogType, "xsd:int"))
				{	soap_flag_LogType--;
					continue;
				}
			if (soap_flag_LogDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LogDesc", &a->LogDesc, "xsd:string"))
				{	soap_flag_LogDesc--;
					continue;
				}
			if (soap_flag_AddTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:AddTime", &a->AddTime, "xsd:string"))
				{	soap_flag_AddTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__PuLog_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__PuLog_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__PuLog_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__PuLog_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__PuLog_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__PuLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PuLog, 0, sizeof(struct ns1__PuLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_LogType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PuLog(struct soap *soap, const struct ns1__PuLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__PuLog);
	if (soap_out_ns1__PuLog(soap, tag?tag:"ns1:PuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PuLog * SOAP_FMAC4 soap_get_ns1__PuLog(struct soap *soap, struct ns1__PuLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePuLog = 0;
	a->PuLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfPuLog(struct soap *soap, const struct ns1__ArrayOfPuLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PuLog)
	{	int i;
		for (i = 0; i < a->__sizePuLog; i++)
		{
			soap_embedded(soap, a->PuLog + i, SOAP_TYPE_ns1__PuLog);
			soap_serialize_ns1__PuLog(soap, a->PuLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfPuLog(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfPuLog *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfPuLog), type))
		return soap->error;
	if (a->PuLog)
	{	int i;
		for (i = 0; i < a->__sizePuLog; i++)
			if (soap_out_ns1__PuLog(soap, "ns1:PuLog", -1, a->PuLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog * SOAP_FMAC4 soap_in_ns1__ArrayOfPuLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPuLog *a, const char *type)
{
	struct soap_blist *soap_blist_PuLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfPuLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfPuLog, sizeof(struct ns1__ArrayOfPuLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfPuLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PuLog", 1, NULL))
			{	if (a->PuLog == NULL)
				{	if (soap_blist_PuLog == NULL)
						soap_blist_PuLog = soap_new_block(soap);
					a->PuLog = (struct ns1__PuLog *)soap_push_block(soap, soap_blist_PuLog, sizeof(struct ns1__PuLog));
					if (a->PuLog == NULL)
						return NULL;
					soap_default_ns1__PuLog(soap, a->PuLog);
				}
				soap_revert(soap);
				if (soap_in_ns1__PuLog(soap, "ns1:PuLog", a->PuLog, "ns1:PuLog"))
				{	a->__sizePuLog++;
					a->PuLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PuLog)
			soap_pop_block(soap, soap_blist_PuLog);
		if (a->__sizePuLog)
			a->PuLog = (struct ns1__PuLog *)soap_save_block(soap, soap_blist_PuLog, NULL, 1);
		else
		{	a->PuLog = NULL;
			if (soap_blist_PuLog)
				soap_end_block(soap, soap_blist_PuLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPuLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfPuLog, 0, sizeof(struct ns1__ArrayOfPuLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfPuLog(struct soap *soap, const struct ns1__ArrayOfPuLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfPuLog);
	if (soap_out_ns1__ArrayOfPuLog(soap, tag?tag:"ns1:ArrayOfPuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog * SOAP_FMAC4 soap_get_ns1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfPuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__Device_Any(struct soap *soap, struct _ns1__Device_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__Device_Any(struct soap *soap, const struct _ns1__Device_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Device_Any(struct soap *soap, const char *tag, int id, const struct _ns1__Device_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Device_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__Device_Any * SOAP_FMAC4 soap_in__ns1__Device_Any(struct soap *soap, const char *tag, struct _ns1__Device_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__Device_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Device_Any, sizeof(struct _ns1__Device_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__Device_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__Device_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Device_Any, 0, sizeof(struct _ns1__Device_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__Device_Any(struct soap *soap, const struct _ns1__Device_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__Device_Any);
	if (soap_out__ns1__Device_Any(soap, tag?tag:"ns1:Device-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Device_Any * SOAP_FMAC4 soap_get__ns1__Device_Any(struct soap *soap, struct _ns1__Device_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Device_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Device(struct soap *soap, struct ns1__Device *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_string(soap, &a->DevKey);
	soap_default_string(soap, &a->DevName);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Device(struct soap *soap, const struct ns1__Device *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_serialize_string(soap, &a->DevKey);
	soap_serialize_string(soap, &a->DevName);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__Device_Any);
			soap_serialize__ns1__Device_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Device(struct soap *soap, const char *tag, int id, const struct ns1__Device *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Device), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevKey", -1, &a->DevKey, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevName", -1, &a->DevName, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__Device_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Device * SOAP_FMAC4 soap_in_ns1__Device(struct soap *soap, const char *tag, struct ns1__Device *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_DevKey = 1;
	size_t soap_flag_DevName = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Device *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Device, sizeof(struct ns1__Device), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Device(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_DevKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevKey", &a->DevKey, "xsd:string"))
				{	soap_flag_DevKey--;
					continue;
				}
			if (soap_flag_DevName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevName", &a->DevName, "xsd:string"))
				{	soap_flag_DevName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__Device_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__Device_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__Device_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__Device_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__Device_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Device *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Device, 0, sizeof(struct ns1__Device), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Device(struct soap *soap, const struct ns1__Device *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Device);
	if (soap_out_ns1__Device(soap, tag?tag:"ns1:Device", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Device * SOAP_FMAC4 soap_get_ns1__Device(struct soap *soap, struct ns1__Device *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Device(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDevice = 0;
	a->Device = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDevice(struct soap *soap, const struct ns1__ArrayOfDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Device)
	{	int i;
		for (i = 0; i < a->__sizeDevice; i++)
		{
			soap_embedded(soap, a->Device + i, SOAP_TYPE_ns1__Device);
			soap_serialize_ns1__Device(soap, a->Device + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDevice(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDevice *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDevice), type))
		return soap->error;
	if (a->Device)
	{	int i;
		for (i = 0; i < a->__sizeDevice; i++)
			if (soap_out_ns1__Device(soap, "ns1:Device", -1, a->Device + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice * SOAP_FMAC4 soap_in_ns1__ArrayOfDevice(struct soap *soap, const char *tag, struct ns1__ArrayOfDevice *a, const char *type)
{
	struct soap_blist *soap_blist_Device = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDevice, sizeof(struct ns1__ArrayOfDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Device", 1, NULL))
			{	if (a->Device == NULL)
				{	if (soap_blist_Device == NULL)
						soap_blist_Device = soap_new_block(soap);
					a->Device = (struct ns1__Device *)soap_push_block(soap, soap_blist_Device, sizeof(struct ns1__Device));
					if (a->Device == NULL)
						return NULL;
					soap_default_ns1__Device(soap, a->Device);
				}
				soap_revert(soap);
				if (soap_in_ns1__Device(soap, "ns1:Device", a->Device, "ns1:Device"))
				{	a->__sizeDevice++;
					a->Device = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Device)
			soap_pop_block(soap, soap_blist_Device);
		if (a->__sizeDevice)
			a->Device = (struct ns1__Device *)soap_save_block(soap, soap_blist_Device, NULL, 1);
		else
		{	a->Device = NULL;
			if (soap_blist_Device)
				soap_end_block(soap, soap_blist_Device);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDevice, 0, sizeof(struct ns1__ArrayOfDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDevice(struct soap *soap, const struct ns1__ArrayOfDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDevice);
	if (soap_out_ns1__ArrayOfDevice(soap, tag?tag:"ns1:ArrayOfDevice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice * SOAP_FMAC4 soap_get_ns1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__Dev_Any(struct soap *soap, struct _ns1__Dev_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__Dev_Any(struct soap *soap, const struct _ns1__Dev_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Dev_Any(struct soap *soap, const char *tag, int id, const struct _ns1__Dev_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Dev_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__Dev_Any * SOAP_FMAC4 soap_in__ns1__Dev_Any(struct soap *soap, const char *tag, struct _ns1__Dev_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__Dev_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Dev_Any, sizeof(struct _ns1__Dev_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__Dev_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__Dev_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Dev_Any, 0, sizeof(struct _ns1__Dev_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__Dev_Any(struct soap *soap, const struct _ns1__Dev_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__Dev_Any);
	if (soap_out__ns1__Dev_Any(soap, tag?tag:"ns1:Dev-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Dev_Any * SOAP_FMAC4 soap_get__ns1__Dev_Any(struct soap *soap, struct _ns1__Dev_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Dev_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Dev(struct soap *soap, struct ns1__Dev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->OnLine);
	soap_default_xsd__boolean(soap, &a->PtzFlag);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Dev(struct soap *soap, const struct ns1__Dev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Name);
	soap_embedded(soap, &a->OnLine, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->PtzFlag, SOAP_TYPE_xsd__boolean);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__Dev_Any);
			soap_serialize__ns1__Dev_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Dev(struct soap *soap, const char *tag, int id, const struct ns1__Dev *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Dev), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:OnLine", -1, &a->OnLine, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:PtzFlag", -1, &a->PtzFlag, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__Dev_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Dev * SOAP_FMAC4 soap_in_ns1__Dev(struct soap *soap, const char *tag, struct ns1__Dev *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_OnLine = 1;
	size_t soap_flag_PtzFlag = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Dev *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Dev, sizeof(struct ns1__Dev), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Dev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_OnLine && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:OnLine", &a->OnLine, "xsd:boolean"))
				{	soap_flag_OnLine--;
					continue;
				}
			if (soap_flag_PtzFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:PtzFlag", &a->PtzFlag, "xsd:boolean"))
				{	soap_flag_PtzFlag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__Dev_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__Dev_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__Dev_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__Dev_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__Dev_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Dev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Dev, 0, sizeof(struct ns1__Dev), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_OnLine > 0 || soap_flag_PtzFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Dev(struct soap *soap, const struct ns1__Dev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Dev);
	if (soap_out_ns1__Dev(soap, tag?tag:"ns1:Dev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Dev * SOAP_FMAC4 soap_get_ns1__Dev(struct soap *soap, struct ns1__Dev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Dev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDev = 0;
	a->Dev = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfDev(struct soap *soap, const struct ns1__ArrayOfDev *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dev)
	{	int i;
		for (i = 0; i < a->__sizeDev; i++)
		{
			soap_embedded(soap, a->Dev + i, SOAP_TYPE_ns1__Dev);
			soap_serialize_ns1__Dev(soap, a->Dev + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDev(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfDev *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDev), type))
		return soap->error;
	if (a->Dev)
	{	int i;
		for (i = 0; i < a->__sizeDev; i++)
			if (soap_out_ns1__Dev(soap, "ns1:Dev", -1, a->Dev + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfDev * SOAP_FMAC4 soap_in_ns1__ArrayOfDev(struct soap *soap, const char *tag, struct ns1__ArrayOfDev *a, const char *type)
{
	struct soap_blist *soap_blist_Dev = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfDev *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDev, sizeof(struct ns1__ArrayOfDev), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfDev(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Dev", 1, NULL))
			{	if (a->Dev == NULL)
				{	if (soap_blist_Dev == NULL)
						soap_blist_Dev = soap_new_block(soap);
					a->Dev = (struct ns1__Dev *)soap_push_block(soap, soap_blist_Dev, sizeof(struct ns1__Dev));
					if (a->Dev == NULL)
						return NULL;
					soap_default_ns1__Dev(soap, a->Dev);
				}
				soap_revert(soap);
				if (soap_in_ns1__Dev(soap, "ns1:Dev", a->Dev, "ns1:Dev"))
				{	a->__sizeDev++;
					a->Dev = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dev)
			soap_pop_block(soap, soap_blist_Dev);
		if (a->__sizeDev)
			a->Dev = (struct ns1__Dev *)soap_save_block(soap, soap_blist_Dev, NULL, 1);
		else
		{	a->Dev = NULL;
			if (soap_blist_Dev)
				soap_end_block(soap, soap_blist_Dev);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDev *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDev, 0, sizeof(struct ns1__ArrayOfDev), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfDev(struct soap *soap, const struct ns1__ArrayOfDev *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDev);
	if (soap_out_ns1__ArrayOfDev(soap, tag?tag:"ns1:ArrayOfDev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDev * SOAP_FMAC4 soap_get_ns1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__NodeDetails_Any(struct soap *soap, struct _ns1__NodeDetails_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__NodeDetails_Any(struct soap *soap, const struct _ns1__NodeDetails_Any *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NodeDetails_Any(struct soap *soap, const char *tag, int id, const struct _ns1__NodeDetails_Any *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__NodeDetails_Any), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__NodeDetails_Any * SOAP_FMAC4 soap_in__ns1__NodeDetails_Any(struct soap *soap, const char *tag, struct _ns1__NodeDetails_Any *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__NodeDetails_Any *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__NodeDetails_Any, sizeof(struct _ns1__NodeDetails_Any), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__NodeDetails_Any(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__NodeDetails_Any *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__NodeDetails_Any, 0, sizeof(struct _ns1__NodeDetails_Any), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__NodeDetails_Any(struct soap *soap, const struct _ns1__NodeDetails_Any *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__NodeDetails_Any);
	if (soap_out__ns1__NodeDetails_Any(soap, tag?tag:"ns1:NodeDetails-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__NodeDetails_Any * SOAP_FMAC4 soap_get__ns1__NodeDetails_Any(struct soap *soap, struct _ns1__NodeDetails_Any *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NodeDetails_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->DevID);
	soap_default_int(soap, &a->ChannelNo);
	soap_default_string(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->OnLine);
	soap_default_xsd__boolean(soap, &a->PtzFlag);
	soap_default_int(soap, &a->SecurityArea);
	soap_default_xsd__boolean(soap, &a->EStoreFlag);
	soap_default_string(soap, &a->UpnpIP);
	soap_default_int(soap, &a->UpnpPort);
	soap_default_string(soap, &a->DevVer);
	soap_default_int(soap, &a->CurVideoNum);
	soap_default_time(soap, &a->LastUpdated);
	a->__sizeAny = 0;
	a->Any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__NodeDetails(struct soap *soap, const struct ns1__NodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DevID);
	soap_embedded(soap, &a->ChannelNo, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->Name);
	soap_embedded(soap, &a->OnLine, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->PtzFlag, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SecurityArea, SOAP_TYPE_int);
	soap_embedded(soap, &a->EStoreFlag, SOAP_TYPE_xsd__boolean);
	soap_serialize_string(soap, &a->UpnpIP);
	soap_embedded(soap, &a->UpnpPort, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->DevVer);
	soap_embedded(soap, &a->CurVideoNum, SOAP_TYPE_int);
	soap_embedded(soap, &a->LastUpdated, SOAP_TYPE_time);
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
		{
			soap_embedded(soap, a->Any + i, SOAP_TYPE__ns1__NodeDetails_Any);
			soap_serialize__ns1__NodeDetails_Any(soap, a->Any + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NodeDetails(struct soap *soap, const char *tag, int id, const struct ns1__NodeDetails *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NodeDetails), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevID", -1, &a->DevID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ChannelNo", -1, &a->ChannelNo, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:OnLine", -1, &a->OnLine, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:PtzFlag", -1, &a->PtzFlag, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:SecurityArea", -1, &a->SecurityArea, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:EStoreFlag", -1, &a->EStoreFlag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:UpnpIP", -1, &a->UpnpIP, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:UpnpPort", -1, &a->UpnpPort, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:DevVer", -1, &a->DevVer, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:CurVideoNum", -1, &a->CurVideoNum, ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastUpdated", -1, &a->LastUpdated, ""))
		return soap->error;
	if (a->Any)
	{	int i;
		for (i = 0; i < a->__sizeAny; i++)
			if (soap_out__ns1__NodeDetails_Any(soap, "ns1:Any", -1, a->Any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__NodeDetails * SOAP_FMAC4 soap_in_ns1__NodeDetails(struct soap *soap, const char *tag, struct ns1__NodeDetails *a, const char *type)
{
	size_t soap_flag_DevID = 1;
	size_t soap_flag_ChannelNo = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_OnLine = 1;
	size_t soap_flag_PtzFlag = 1;
	size_t soap_flag_SecurityArea = 1;
	size_t soap_flag_EStoreFlag = 1;
	size_t soap_flag_UpnpIP = 1;
	size_t soap_flag_UpnpPort = 1;
	size_t soap_flag_DevVer = 1;
	size_t soap_flag_CurVideoNum = 1;
	size_t soap_flag_LastUpdated = 1;
	struct soap_blist *soap_blist_Any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__NodeDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NodeDetails, sizeof(struct ns1__NodeDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__NodeDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DevID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevID", &a->DevID, "xsd:string"))
				{	soap_flag_DevID--;
					continue;
				}
			if (soap_flag_ChannelNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ChannelNo", &a->ChannelNo, "xsd:int"))
				{	soap_flag_ChannelNo--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_OnLine && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:OnLine", &a->OnLine, "xsd:boolean"))
				{	soap_flag_OnLine--;
					continue;
				}
			if (soap_flag_PtzFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:PtzFlag", &a->PtzFlag, "xsd:boolean"))
				{	soap_flag_PtzFlag--;
					continue;
				}
			if (soap_flag_SecurityArea && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:SecurityArea", &a->SecurityArea, "xsd:int"))
				{	soap_flag_SecurityArea--;
					continue;
				}
			if (soap_flag_EStoreFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:EStoreFlag", &a->EStoreFlag, "xsd:boolean"))
				{	soap_flag_EStoreFlag--;
					continue;
				}
			if (soap_flag_UpnpIP && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpnpIP", &a->UpnpIP, "xsd:string"))
				{	soap_flag_UpnpIP--;
					continue;
				}
			if (soap_flag_UpnpPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:UpnpPort", &a->UpnpPort, "xsd:int"))
				{	soap_flag_UpnpPort--;
					continue;
				}
			if (soap_flag_DevVer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:DevVer", &a->DevVer, "xsd:string"))
				{	soap_flag_DevVer--;
					continue;
				}
			if (soap_flag_CurVideoNum && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:CurVideoNum", &a->CurVideoNum, "xsd:int"))
				{	soap_flag_CurVideoNum--;
					continue;
				}
			if (soap_flag_LastUpdated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastUpdated", &a->LastUpdated, "xsd:dateTime"))
				{	soap_flag_LastUpdated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Any", 1, NULL))
			{	if (a->Any == NULL)
				{	if (soap_blist_Any == NULL)
						soap_blist_Any = soap_new_block(soap);
					a->Any = (struct _ns1__NodeDetails_Any *)soap_push_block(soap, soap_blist_Any, sizeof(struct _ns1__NodeDetails_Any));
					if (a->Any == NULL)
						return NULL;
					soap_default__ns1__NodeDetails_Any(soap, a->Any);
				}
				soap_revert(soap);
				if (soap_in__ns1__NodeDetails_Any(soap, "ns1:Any", a->Any, ""))
				{	a->__sizeAny++;
					a->Any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Any)
			soap_pop_block(soap, soap_blist_Any);
		if (a->__sizeAny)
			a->Any = (struct _ns1__NodeDetails_Any *)soap_save_block(soap, soap_blist_Any, NULL, 1);
		else
		{	a->Any = NULL;
			if (soap_blist_Any)
				soap_end_block(soap, soap_blist_Any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__NodeDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NodeDetails, 0, sizeof(struct ns1__NodeDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ChannelNo > 0 || soap_flag_OnLine > 0 || soap_flag_PtzFlag > 0 || soap_flag_SecurityArea > 0 || soap_flag_EStoreFlag > 0 || soap_flag_UpnpPort > 0 || soap_flag_CurVideoNum > 0 || soap_flag_LastUpdated > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__NodeDetails(struct soap *soap, const struct ns1__NodeDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__NodeDetails);
	if (soap_out_ns1__NodeDetails(soap, tag?tag:"ns1:NodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__NodeDetails * SOAP_FMAC4 soap_get_ns1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNodeDetails = 0;
	a->NodeDetails = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ArrayOfNodeDetails(struct soap *soap, const struct ns1__ArrayOfNodeDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NodeDetails)
	{	int i;
		for (i = 0; i < a->__sizeNodeDetails; i++)
		{
			soap_embedded(soap, a->NodeDetails + i, SOAP_TYPE_ns1__NodeDetails);
			soap_serialize_ns1__NodeDetails(soap, a->NodeDetails + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfNodeDetails(struct soap *soap, const char *tag, int id, const struct ns1__ArrayOfNodeDetails *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfNodeDetails), type))
		return soap->error;
	if (a->NodeDetails)
	{	int i;
		for (i = 0; i < a->__sizeNodeDetails; i++)
			if (soap_out_ns1__NodeDetails(soap, "ns1:NodeDetails", -1, a->NodeDetails + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails * SOAP_FMAC4 soap_in_ns1__ArrayOfNodeDetails(struct soap *soap, const char *tag, struct ns1__ArrayOfNodeDetails *a, const char *type)
{
	struct soap_blist *soap_blist_NodeDetails = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ArrayOfNodeDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfNodeDetails, sizeof(struct ns1__ArrayOfNodeDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ArrayOfNodeDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:NodeDetails", 1, NULL))
			{	if (a->NodeDetails == NULL)
				{	if (soap_blist_NodeDetails == NULL)
						soap_blist_NodeDetails = soap_new_block(soap);
					a->NodeDetails = (struct ns1__NodeDetails *)soap_push_block(soap, soap_blist_NodeDetails, sizeof(struct ns1__NodeDetails));
					if (a->NodeDetails == NULL)
						return NULL;
					soap_default_ns1__NodeDetails(soap, a->NodeDetails);
				}
				soap_revert(soap);
				if (soap_in_ns1__NodeDetails(soap, "ns1:NodeDetails", a->NodeDetails, "ns1:NodeDetails"))
				{	a->__sizeNodeDetails++;
					a->NodeDetails = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NodeDetails)
			soap_pop_block(soap, soap_blist_NodeDetails);
		if (a->__sizeNodeDetails)
			a->NodeDetails = (struct ns1__NodeDetails *)soap_save_block(soap, soap_blist_NodeDetails, NULL, 1);
		else
		{	a->NodeDetails = NULL;
			if (soap_blist_NodeDetails)
				soap_end_block(soap, soap_blist_NodeDetails);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfNodeDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfNodeDetails, 0, sizeof(struct ns1__ArrayOfNodeDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ArrayOfNodeDetails(struct soap *soap, const struct ns1__ArrayOfNodeDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfNodeDetails);
	if (soap_out_ns1__ArrayOfNodeDetails(soap, tag?tag:"ns1:ArrayOfNodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails * SOAP_FMAC4 soap_get_ns1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfNodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__vodSearchRes))
		soap_serialize__ns1__vodSearchRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__vodSearchRes(struct soap *soap, const char *tag, int id, struct _ns1__vodSearchRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__vodSearchRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__vodSearchRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__vodSearchRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__vodSearchRes(struct soap *soap, const char *tag, struct _ns1__vodSearchRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__vodSearchRes **)soap_malloc(soap, sizeof(struct _ns1__vodSearchRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__vodSearchRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__vodSearchRes, sizeof(struct _ns1__vodSearchRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__vodSearchRes);
	if (soap_out_PointerTo_ns1__vodSearchRes(soap, tag?tag:"ns1:vodSearchRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__vodSearchRes(struct soap *soap, struct _ns1__vodSearchRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__vodSearchRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__vodSearchReq))
		soap_serialize__ns1__vodSearchReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__vodSearchReq(struct soap *soap, const char *tag, int id, struct _ns1__vodSearchReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__vodSearchReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__vodSearchReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__vodSearchReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__vodSearchReq(struct soap *soap, const char *tag, struct _ns1__vodSearchReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__vodSearchReq **)soap_malloc(soap, sizeof(struct _ns1__vodSearchReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__vodSearchReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__vodSearchReq, sizeof(struct _ns1__vodSearchReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__vodSearchReq);
	if (soap_out_PointerTo_ns1__vodSearchReq(soap, tag?tag:"ns1:vodSearchReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__vodSearchReq(struct soap *soap, struct _ns1__vodSearchReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__vodSearchReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVODUrlRes))
		soap_serialize__ns1__getVODUrlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVODUrlRes(struct soap *soap, const char *tag, int id, struct _ns1__getVODUrlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVODUrlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVODUrlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVODUrlRes(struct soap *soap, const char *tag, struct _ns1__getVODUrlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVODUrlRes **)soap_malloc(soap, sizeof(struct _ns1__getVODUrlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVODUrlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVODUrlRes, sizeof(struct _ns1__getVODUrlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVODUrlRes);
	if (soap_out_PointerTo_ns1__getVODUrlRes(soap, tag?tag:"ns1:getVODUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVODUrlRes(struct soap *soap, struct _ns1__getVODUrlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVODUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVODUrlReq))
		soap_serialize__ns1__getVODUrlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVODUrlReq(struct soap *soap, const char *tag, int id, struct _ns1__getVODUrlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVODUrlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVODUrlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVODUrlReq(struct soap *soap, const char *tag, struct _ns1__getVODUrlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVODUrlReq **)soap_malloc(soap, sizeof(struct _ns1__getVODUrlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVODUrlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVODUrlReq, sizeof(struct _ns1__getVODUrlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVODUrlReq);
	if (soap_out_PointerTo_ns1__getVODUrlReq(soap, tag?tag:"ns1:getVODUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVODUrlReq(struct soap *soap, struct _ns1__getVODUrlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVODUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPlayUrlRes))
		soap_serialize__ns1__getPlayUrlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPlayUrlRes(struct soap *soap, const char *tag, int id, struct _ns1__getPlayUrlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPlayUrlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPlayUrlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPlayUrlRes(struct soap *soap, const char *tag, struct _ns1__getPlayUrlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPlayUrlRes **)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPlayUrlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPlayUrlRes, sizeof(struct _ns1__getPlayUrlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPlayUrlRes);
	if (soap_out_PointerTo_ns1__getPlayUrlRes(soap, tag?tag:"ns1:getPlayUrlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPlayUrlRes(struct soap *soap, struct _ns1__getPlayUrlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPlayUrlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPlayUrlReq))
		soap_serialize__ns1__getPlayUrlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPlayUrlReq(struct soap *soap, const char *tag, int id, struct _ns1__getPlayUrlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPlayUrlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPlayUrlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPlayUrlReq(struct soap *soap, const char *tag, struct _ns1__getPlayUrlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPlayUrlReq **)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPlayUrlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPlayUrlReq, sizeof(struct _ns1__getPlayUrlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPlayUrlReq);
	if (soap_out_PointerTo_ns1__getPlayUrlReq(soap, tag?tag:"ns1:getPlayUrlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPlayUrlReq(struct soap *soap, struct _ns1__getPlayUrlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPlayUrlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPrivacyMaskParamRes))
		soap_serialize__ns1__setPrivacyMaskParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setPrivacyMaskParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPrivacyMaskParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPrivacyMaskParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPrivacyMaskParamRes **)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setPrivacyMaskParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPrivacyMaskParamRes, sizeof(struct _ns1__setPrivacyMaskParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes);
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamRes(soap, tag?tag:"ns1:setPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPrivacyMaskParamRes(struct soap *soap, struct _ns1__setPrivacyMaskParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPrivacyMaskParamReq))
		soap_serialize__ns1__setPrivacyMaskParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setPrivacyMaskParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPrivacyMaskParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPrivacyMaskParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPrivacyMaskParamReq **)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setPrivacyMaskParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPrivacyMaskParamReq, sizeof(struct _ns1__setPrivacyMaskParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq);
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamReq(soap, tag?tag:"ns1:setPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPrivacyMaskParamReq(struct soap *soap, struct _ns1__setPrivacyMaskParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrivacyMaskParamRes))
		soap_serialize__ns1__getPrivacyMaskParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getPrivacyMaskParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrivacyMaskParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPrivacyMaskParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPrivacyMaskParamRes **)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPrivacyMaskParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrivacyMaskParamRes, sizeof(struct _ns1__getPrivacyMaskParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes);
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamRes(soap, tag?tag:"ns1:getPrivacyMaskParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrivacyMaskParamRes(struct soap *soap, struct _ns1__getPrivacyMaskParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrivacyMaskParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrivacyMaskParamReq))
		soap_serialize__ns1__getPrivacyMaskParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getPrivacyMaskParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrivacyMaskParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPrivacyMaskParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPrivacyMaskParamReq **)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPrivacyMaskParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrivacyMaskParamReq, sizeof(struct _ns1__getPrivacyMaskParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq);
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamReq(soap, tag?tag:"ns1:getPrivacyMaskParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrivacyMaskParamReq(struct soap *soap, struct _ns1__getPrivacyMaskParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrivacyMaskParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVMDParamRes))
		soap_serialize__ns1__setVMDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVMDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setVMDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVMDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVMDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVMDParamRes(struct soap *soap, const char *tag, struct _ns1__setVMDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVMDParamRes **)soap_malloc(soap, sizeof(struct _ns1__setVMDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVMDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVMDParamRes, sizeof(struct _ns1__setVMDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVMDParamRes);
	if (soap_out_PointerTo_ns1__setVMDParamRes(soap, tag?tag:"ns1:setVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVMDParamRes(struct soap *soap, struct _ns1__setVMDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVMDParamReq))
		soap_serialize__ns1__setVMDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVMDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setVMDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVMDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVMDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVMDParamReq(struct soap *soap, const char *tag, struct _ns1__setVMDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVMDParamReq **)soap_malloc(soap, sizeof(struct _ns1__setVMDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVMDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVMDParamReq, sizeof(struct _ns1__setVMDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVMDParamReq);
	if (soap_out_PointerTo_ns1__setVMDParamReq(soap, tag?tag:"ns1:setVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVMDParamReq(struct soap *soap, struct _ns1__setVMDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVMDParamRes))
		soap_serialize__ns1__getVMDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVMDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getVMDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVMDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVMDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVMDParamRes(struct soap *soap, const char *tag, struct _ns1__getVMDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVMDParamRes **)soap_malloc(soap, sizeof(struct _ns1__getVMDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVMDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVMDParamRes, sizeof(struct _ns1__getVMDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVMDParamRes);
	if (soap_out_PointerTo_ns1__getVMDParamRes(soap, tag?tag:"ns1:getVMDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVMDParamRes(struct soap *soap, struct _ns1__getVMDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVMDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVMDParamReq))
		soap_serialize__ns1__getVMDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVMDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getVMDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVMDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVMDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVMDParamReq(struct soap *soap, const char *tag, struct _ns1__getVMDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVMDParamReq **)soap_malloc(soap, sizeof(struct _ns1__getVMDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVMDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVMDParamReq, sizeof(struct _ns1__getVMDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVMDParamReq);
	if (soap_out_PointerTo_ns1__getVMDParamReq(soap, tag?tag:"ns1:getVMDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVMDParamReq(struct soap *soap, struct _ns1__getVMDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVMDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setTimeRes))
		soap_serialize__ns1__setTimeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setTimeRes(struct soap *soap, const char *tag, int id, struct _ns1__setTimeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setTimeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setTimeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setTimeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setTimeRes(struct soap *soap, const char *tag, struct _ns1__setTimeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setTimeRes **)soap_malloc(soap, sizeof(struct _ns1__setTimeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setTimeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setTimeRes, sizeof(struct _ns1__setTimeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setTimeRes);
	if (soap_out_PointerTo_ns1__setTimeRes(soap, tag?tag:"ns1:setTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setTimeRes(struct soap *soap, struct _ns1__setTimeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setTimeReq))
		soap_serialize__ns1__setTimeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setTimeReq(struct soap *soap, const char *tag, int id, struct _ns1__setTimeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setTimeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setTimeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setTimeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setTimeReq(struct soap *soap, const char *tag, struct _ns1__setTimeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setTimeReq **)soap_malloc(soap, sizeof(struct _ns1__setTimeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setTimeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setTimeReq, sizeof(struct _ns1__setTimeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setTimeReq);
	if (soap_out_PointerTo_ns1__setTimeReq(soap, tag?tag:"ns1:setTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setTimeReq(struct soap *soap, struct _ns1__setTimeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTimeRes))
		soap_serialize__ns1__getTimeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTimeRes(struct soap *soap, const char *tag, int id, struct _ns1__getTimeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTimeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getTimeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getTimeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTimeRes(struct soap *soap, const char *tag, struct _ns1__getTimeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getTimeRes **)soap_malloc(soap, sizeof(struct _ns1__getTimeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getTimeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTimeRes, sizeof(struct _ns1__getTimeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTimeRes);
	if (soap_out_PointerTo_ns1__getTimeRes(soap, tag?tag:"ns1:getTimeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTimeRes(struct soap *soap, struct _ns1__getTimeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTimeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTimeReq))
		soap_serialize__ns1__getTimeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTimeReq(struct soap *soap, const char *tag, int id, struct _ns1__getTimeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTimeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getTimeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getTimeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTimeReq(struct soap *soap, const char *tag, struct _ns1__getTimeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getTimeReq **)soap_malloc(soap, sizeof(struct _ns1__getTimeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getTimeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTimeReq, sizeof(struct _ns1__getTimeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTimeReq);
	if (soap_out_PointerTo_ns1__getTimeReq(soap, tag?tag:"ns1:getTimeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTimeReq(struct soap *soap, struct _ns1__getTimeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTimeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setOSDParamRes))
		soap_serialize__ns1__setOSDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setOSDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setOSDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setOSDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setOSDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setOSDParamRes(struct soap *soap, const char *tag, struct _ns1__setOSDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setOSDParamRes **)soap_malloc(soap, sizeof(struct _ns1__setOSDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setOSDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setOSDParamRes, sizeof(struct _ns1__setOSDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setOSDParamRes);
	if (soap_out_PointerTo_ns1__setOSDParamRes(soap, tag?tag:"ns1:setOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setOSDParamRes(struct soap *soap, struct _ns1__setOSDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setOSDParamReq))
		soap_serialize__ns1__setOSDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setOSDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setOSDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setOSDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setOSDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setOSDParamReq(struct soap *soap, const char *tag, struct _ns1__setOSDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setOSDParamReq **)soap_malloc(soap, sizeof(struct _ns1__setOSDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setOSDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setOSDParamReq, sizeof(struct _ns1__setOSDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setOSDParamReq);
	if (soap_out_PointerTo_ns1__setOSDParamReq(soap, tag?tag:"ns1:setOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setOSDParamReq(struct soap *soap, struct _ns1__setOSDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOSDParamRes))
		soap_serialize__ns1__getOSDParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOSDParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getOSDParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOSDParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getOSDParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOSDParamRes(struct soap *soap, const char *tag, struct _ns1__getOSDParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getOSDParamRes **)soap_malloc(soap, sizeof(struct _ns1__getOSDParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getOSDParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOSDParamRes, sizeof(struct _ns1__getOSDParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOSDParamRes);
	if (soap_out_PointerTo_ns1__getOSDParamRes(soap, tag?tag:"ns1:getOSDParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOSDParamRes(struct soap *soap, struct _ns1__getOSDParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOSDParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOSDParamReq))
		soap_serialize__ns1__getOSDParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOSDParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getOSDParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOSDParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getOSDParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOSDParamReq(struct soap *soap, const char *tag, struct _ns1__getOSDParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getOSDParamReq **)soap_malloc(soap, sizeof(struct _ns1__getOSDParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getOSDParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOSDParamReq, sizeof(struct _ns1__getOSDParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOSDParamReq);
	if (soap_out_PointerTo_ns1__getOSDParamReq(soap, tag?tag:"ns1:getOSDParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOSDParamReq(struct soap *soap, struct _ns1__getOSDParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOSDParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVideoParamRes))
		soap_serialize__ns1__setVideoParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVideoParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setVideoParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVideoParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVideoParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVideoParamRes(struct soap *soap, const char *tag, struct _ns1__setVideoParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVideoParamRes **)soap_malloc(soap, sizeof(struct _ns1__setVideoParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVideoParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVideoParamRes, sizeof(struct _ns1__setVideoParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVideoParamRes);
	if (soap_out_PointerTo_ns1__setVideoParamRes(soap, tag?tag:"ns1:setVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVideoParamRes(struct soap *soap, struct _ns1__setVideoParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVideoParamReq))
		soap_serialize__ns1__setVideoParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVideoParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setVideoParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVideoParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVideoParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVideoParamReq(struct soap *soap, const char *tag, struct _ns1__setVideoParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVideoParamReq **)soap_malloc(soap, sizeof(struct _ns1__setVideoParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVideoParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVideoParamReq, sizeof(struct _ns1__setVideoParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVideoParamReq);
	if (soap_out_PointerTo_ns1__setVideoParamReq(soap, tag?tag:"ns1:setVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVideoParamReq(struct soap *soap, struct _ns1__setVideoParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVideoParamRes))
		soap_serialize__ns1__getVideoParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVideoParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getVideoParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVideoParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVideoParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVideoParamRes(struct soap *soap, const char *tag, struct _ns1__getVideoParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVideoParamRes **)soap_malloc(soap, sizeof(struct _ns1__getVideoParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVideoParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVideoParamRes, sizeof(struct _ns1__getVideoParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVideoParamRes);
	if (soap_out_PointerTo_ns1__getVideoParamRes(soap, tag?tag:"ns1:getVideoParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVideoParamRes(struct soap *soap, struct _ns1__getVideoParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVideoParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVideoParamReq))
		soap_serialize__ns1__getVideoParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVideoParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getVideoParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVideoParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVideoParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVideoParamReq(struct soap *soap, const char *tag, struct _ns1__getVideoParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVideoParamReq **)soap_malloc(soap, sizeof(struct _ns1__getVideoParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVideoParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVideoParamReq, sizeof(struct _ns1__getVideoParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVideoParamReq);
	if (soap_out_PointerTo_ns1__getVideoParamReq(soap, tag?tag:"ns1:getVideoParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVideoParamReq(struct soap *soap, struct _ns1__getVideoParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVideoParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDevLogRes))
		soap_serialize__ns1__queryDevLogRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDevLogRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDevLogRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDevLogRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDevLogRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDevLogRes(struct soap *soap, const char *tag, struct _ns1__queryDevLogRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDevLogRes **)soap_malloc(soap, sizeof(struct _ns1__queryDevLogRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDevLogRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDevLogRes, sizeof(struct _ns1__queryDevLogRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDevLogRes);
	if (soap_out_PointerTo_ns1__queryDevLogRes(soap, tag?tag:"ns1:queryDevLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDevLogRes(struct soap *soap, struct _ns1__queryDevLogRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDevLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDevLogReq))
		soap_serialize__ns1__queryDevLogReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDevLogReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDevLogReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDevLogReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDevLogReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDevLogReq(struct soap *soap, const char *tag, struct _ns1__queryDevLogReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDevLogReq **)soap_malloc(soap, sizeof(struct _ns1__queryDevLogReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDevLogReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDevLogReq, sizeof(struct _ns1__queryDevLogReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDevLogReq);
	if (soap_out_PointerTo_ns1__queryDevLogReq(soap, tag?tag:"ns1:queryDevLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDevLogReq(struct soap *soap, struct _ns1__queryDevLogReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDevLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryLogRes))
		soap_serialize__ns1__queryLogRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryLogRes(struct soap *soap, const char *tag, int id, struct _ns1__queryLogRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryLogRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryLogRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryLogRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryLogRes(struct soap *soap, const char *tag, struct _ns1__queryLogRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryLogRes **)soap_malloc(soap, sizeof(struct _ns1__queryLogRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryLogRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryLogRes, sizeof(struct _ns1__queryLogRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryLogRes);
	if (soap_out_PointerTo_ns1__queryLogRes(soap, tag?tag:"ns1:queryLogRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryLogRes(struct soap *soap, struct _ns1__queryLogRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryLogRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryLogReq))
		soap_serialize__ns1__queryLogReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryLogReq(struct soap *soap, const char *tag, int id, struct _ns1__queryLogReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryLogReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryLogReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryLogReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryLogReq(struct soap *soap, const char *tag, struct _ns1__queryLogReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryLogReq **)soap_malloc(soap, sizeof(struct _ns1__queryLogReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryLogReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryLogReq, sizeof(struct _ns1__queryLogReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryLogReq);
	if (soap_out_PointerTo_ns1__queryLogReq(soap, tag?tag:"ns1:queryLogReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryLogReq(struct soap *soap, struct _ns1__queryLogReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryLogReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upgradeDevVerRes))
		soap_serialize__ns1__upgradeDevVerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, const char *tag, int id, struct _ns1__upgradeDevVerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upgradeDevVerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__upgradeDevVerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__upgradeDevVerRes **)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__upgradeDevVerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upgradeDevVerRes, sizeof(struct _ns1__upgradeDevVerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes);
	if (soap_out_PointerTo_ns1__upgradeDevVerRes(soap, tag?tag:"ns1:upgradeDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__upgradeDevVerRes(struct soap *soap, struct _ns1__upgradeDevVerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upgradeDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upgradeDevVerReq))
		soap_serialize__ns1__upgradeDevVerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, const char *tag, int id, struct _ns1__upgradeDevVerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upgradeDevVerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__upgradeDevVerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__upgradeDevVerReq **)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__upgradeDevVerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upgradeDevVerReq, sizeof(struct _ns1__upgradeDevVerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq);
	if (soap_out_PointerTo_ns1__upgradeDevVerReq(soap, tag?tag:"ns1:upgradeDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__upgradeDevVerReq(struct soap *soap, struct _ns1__upgradeDevVerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upgradeDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDevVerRes))
		soap_serialize__ns1__getDevVerRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDevVerRes(struct soap *soap, const char *tag, int id, struct _ns1__getDevVerRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDevVerRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDevVerRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDevVerRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDevVerRes(struct soap *soap, const char *tag, struct _ns1__getDevVerRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDevVerRes **)soap_malloc(soap, sizeof(struct _ns1__getDevVerRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getDevVerRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDevVerRes, sizeof(struct _ns1__getDevVerRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDevVerRes);
	if (soap_out_PointerTo_ns1__getDevVerRes(soap, tag?tag:"ns1:getDevVerRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDevVerRes(struct soap *soap, struct _ns1__getDevVerRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDevVerRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDevVerReq))
		soap_serialize__ns1__getDevVerReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDevVerReq(struct soap *soap, const char *tag, int id, struct _ns1__getDevVerReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDevVerReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDevVerReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDevVerReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDevVerReq(struct soap *soap, const char *tag, struct _ns1__getDevVerReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDevVerReq **)soap_malloc(soap, sizeof(struct _ns1__getDevVerReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getDevVerReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDevVerReq, sizeof(struct _ns1__getDevVerReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDevVerReq);
	if (soap_out_PointerTo_ns1__getDevVerReq(soap, tag?tag:"ns1:getDevVerReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDevVerReq(struct soap *soap, struct _ns1__getDevVerReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDevVerReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__rebootRes))
		soap_serialize__ns1__rebootRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__rebootRes(struct soap *soap, const char *tag, int id, struct _ns1__rebootRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__rebootRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__rebootRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__rebootRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__rebootRes(struct soap *soap, const char *tag, struct _ns1__rebootRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__rebootRes **)soap_malloc(soap, sizeof(struct _ns1__rebootRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__rebootRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__rebootRes, sizeof(struct _ns1__rebootRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__rebootRes);
	if (soap_out_PointerTo_ns1__rebootRes(soap, tag?tag:"ns1:rebootRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__rebootRes(struct soap *soap, struct _ns1__rebootRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__rebootRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__rebootReq))
		soap_serialize__ns1__rebootReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__rebootReq(struct soap *soap, const char *tag, int id, struct _ns1__rebootReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__rebootReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__rebootReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__rebootReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__rebootReq(struct soap *soap, const char *tag, struct _ns1__rebootReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__rebootReq **)soap_malloc(soap, sizeof(struct _ns1__rebootReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__rebootReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__rebootReq, sizeof(struct _ns1__rebootReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__rebootReq);
	if (soap_out_PointerTo_ns1__rebootReq(soap, tag?tag:"ns1:rebootReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__rebootReq(struct soap *soap, struct _ns1__rebootReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__rebootReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setCodingParamRes))
		soap_serialize__ns1__setCodingParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setCodingParamRes(struct soap *soap, const char *tag, int id, struct _ns1__setCodingParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setCodingParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setCodingParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setCodingParamRes(struct soap *soap, const char *tag, struct _ns1__setCodingParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setCodingParamRes **)soap_malloc(soap, sizeof(struct _ns1__setCodingParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setCodingParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setCodingParamRes, sizeof(struct _ns1__setCodingParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setCodingParamRes);
	if (soap_out_PointerTo_ns1__setCodingParamRes(soap, tag?tag:"ns1:setCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setCodingParamRes(struct soap *soap, struct _ns1__setCodingParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setCodingParamReq))
		soap_serialize__ns1__setCodingParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setCodingParamReq(struct soap *soap, const char *tag, int id, struct _ns1__setCodingParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setCodingParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setCodingParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setCodingParamReq(struct soap *soap, const char *tag, struct _ns1__setCodingParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setCodingParamReq **)soap_malloc(soap, sizeof(struct _ns1__setCodingParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setCodingParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setCodingParamReq, sizeof(struct _ns1__setCodingParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setCodingParamReq);
	if (soap_out_PointerTo_ns1__setCodingParamReq(soap, tag?tag:"ns1:setCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setCodingParamReq(struct soap *soap, struct _ns1__setCodingParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCodingParamRes))
		soap_serialize__ns1__getCodingParamRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCodingParamRes(struct soap *soap, const char *tag, int id, struct _ns1__getCodingParamRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCodingParamRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getCodingParamRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCodingParamRes(struct soap *soap, const char *tag, struct _ns1__getCodingParamRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getCodingParamRes **)soap_malloc(soap, sizeof(struct _ns1__getCodingParamRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getCodingParamRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCodingParamRes, sizeof(struct _ns1__getCodingParamRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCodingParamRes);
	if (soap_out_PointerTo_ns1__getCodingParamRes(soap, tag?tag:"ns1:getCodingParamRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCodingParamRes(struct soap *soap, struct _ns1__getCodingParamRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCodingParamRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCodingParamReq))
		soap_serialize__ns1__getCodingParamReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCodingParamReq(struct soap *soap, const char *tag, int id, struct _ns1__getCodingParamReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCodingParamReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getCodingParamReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCodingParamReq(struct soap *soap, const char *tag, struct _ns1__getCodingParamReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getCodingParamReq **)soap_malloc(soap, sizeof(struct _ns1__getCodingParamReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getCodingParamReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCodingParamReq, sizeof(struct _ns1__getCodingParamReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCodingParamReq);
	if (soap_out_PointerTo_ns1__getCodingParamReq(soap, tag?tag:"ns1:getCodingParamReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCodingParamReq(struct soap *soap, struct _ns1__getCodingParamReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCodingParamReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__presetControlRes))
		soap_serialize__ns1__presetControlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__presetControlRes(struct soap *soap, const char *tag, int id, struct _ns1__presetControlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__presetControlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__presetControlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__presetControlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__presetControlRes(struct soap *soap, const char *tag, struct _ns1__presetControlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__presetControlRes **)soap_malloc(soap, sizeof(struct _ns1__presetControlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__presetControlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__presetControlRes, sizeof(struct _ns1__presetControlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__presetControlRes);
	if (soap_out_PointerTo_ns1__presetControlRes(soap, tag?tag:"ns1:presetControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__presetControlRes(struct soap *soap, struct _ns1__presetControlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__presetControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__presetControlReq))
		soap_serialize__ns1__presetControlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__presetControlReq(struct soap *soap, const char *tag, int id, struct _ns1__presetControlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__presetControlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__presetControlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__presetControlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__presetControlReq(struct soap *soap, const char *tag, struct _ns1__presetControlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__presetControlReq **)soap_malloc(soap, sizeof(struct _ns1__presetControlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__presetControlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__presetControlReq, sizeof(struct _ns1__presetControlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__presetControlReq);
	if (soap_out_PointerTo_ns1__presetControlReq(soap, tag?tag:"ns1:presetControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__presetControlReq(struct soap *soap, struct _ns1__presetControlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__presetControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__lensControlRes))
		soap_serialize__ns1__lensControlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__lensControlRes(struct soap *soap, const char *tag, int id, struct _ns1__lensControlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__lensControlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__lensControlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__lensControlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__lensControlRes(struct soap *soap, const char *tag, struct _ns1__lensControlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__lensControlRes **)soap_malloc(soap, sizeof(struct _ns1__lensControlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__lensControlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__lensControlRes, sizeof(struct _ns1__lensControlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__lensControlRes);
	if (soap_out_PointerTo_ns1__lensControlRes(soap, tag?tag:"ns1:lensControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__lensControlRes(struct soap *soap, struct _ns1__lensControlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__lensControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__lensControlReq))
		soap_serialize__ns1__lensControlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__lensControlReq(struct soap *soap, const char *tag, int id, struct _ns1__lensControlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__lensControlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__lensControlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__lensControlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__lensControlReq(struct soap *soap, const char *tag, struct _ns1__lensControlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__lensControlReq **)soap_malloc(soap, sizeof(struct _ns1__lensControlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__lensControlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__lensControlReq, sizeof(struct _ns1__lensControlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__lensControlReq);
	if (soap_out_PointerTo_ns1__lensControlReq(soap, tag?tag:"ns1:lensControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__lensControlReq(struct soap *soap, struct _ns1__lensControlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__lensControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ptzControlRes))
		soap_serialize__ns1__ptzControlRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ptzControlRes(struct soap *soap, const char *tag, int id, struct _ns1__ptzControlRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ptzControlRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ptzControlRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ptzControlRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__ptzControlRes(struct soap *soap, const char *tag, struct _ns1__ptzControlRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ptzControlRes **)soap_malloc(soap, sizeof(struct _ns1__ptzControlRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ptzControlRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ptzControlRes, sizeof(struct _ns1__ptzControlRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ptzControlRes);
	if (soap_out_PointerTo_ns1__ptzControlRes(soap, tag?tag:"ns1:ptzControlRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__ptzControlRes(struct soap *soap, struct _ns1__ptzControlRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ptzControlRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ptzControlReq))
		soap_serialize__ns1__ptzControlReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ptzControlReq(struct soap *soap, const char *tag, int id, struct _ns1__ptzControlReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ptzControlReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ptzControlReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ptzControlReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__ptzControlReq(struct soap *soap, const char *tag, struct _ns1__ptzControlReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ptzControlReq **)soap_malloc(soap, sizeof(struct _ns1__ptzControlReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ptzControlReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ptzControlReq, sizeof(struct _ns1__ptzControlReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ptzControlReq);
	if (soap_out_PointerTo_ns1__ptzControlReq(soap, tag?tag:"ns1:ptzControlReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__ptzControlReq(struct soap *soap, struct _ns1__ptzControlReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ptzControlReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceRes))
		soap_serialize__ns1__nullifyDeviceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceRes **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__nullifyDeviceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceRes, sizeof(struct _ns1__nullifyDeviceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes);
	if (soap_out_PointerTo_ns1__nullifyDeviceRes(soap, tag?tag:"ns1:nullifyDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceRes(struct soap *soap, struct _ns1__nullifyDeviceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceReq))
		soap_serialize__ns1__nullifyDeviceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceReq **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__nullifyDeviceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceReq, sizeof(struct _ns1__nullifyDeviceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq);
	if (soap_out_PointerTo_ns1__nullifyDeviceReq(soap, tag?tag:"ns1:nullifyDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceReq(struct soap *soap, struct _ns1__nullifyDeviceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceRes))
		soap_serialize__ns1__addDeviceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceRes(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceRes(struct soap *soap, const char *tag, struct _ns1__addDeviceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceRes **)soap_malloc(soap, sizeof(struct _ns1__addDeviceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__addDeviceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceRes, sizeof(struct _ns1__addDeviceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceRes);
	if (soap_out_PointerTo_ns1__addDeviceRes(soap, tag?tag:"ns1:addDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceRes(struct soap *soap, struct _ns1__addDeviceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceReq))
		soap_serialize__ns1__addDeviceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceReq(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceReq(struct soap *soap, const char *tag, struct _ns1__addDeviceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceReq **)soap_malloc(soap, sizeof(struct _ns1__addDeviceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__addDeviceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceReq, sizeof(struct _ns1__addDeviceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceReq);
	if (soap_out_PointerTo_ns1__addDeviceReq(soap, tag?tag:"ns1:addDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceReq(struct soap *soap, struct _ns1__addDeviceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateChannelNameRes))
		soap_serialize__ns1__updateChannelNameRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateChannelNameRes(struct soap *soap, const char *tag, int id, struct _ns1__updateChannelNameRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateChannelNameRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateChannelNameRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateChannelNameRes(struct soap *soap, const char *tag, struct _ns1__updateChannelNameRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateChannelNameRes **)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateChannelNameRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateChannelNameRes, sizeof(struct _ns1__updateChannelNameRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateChannelNameRes);
	if (soap_out_PointerTo_ns1__updateChannelNameRes(soap, tag?tag:"ns1:updateChannelNameRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateChannelNameRes(struct soap *soap, struct _ns1__updateChannelNameRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateChannelNameRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateChannelNameReq))
		soap_serialize__ns1__updateChannelNameReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateChannelNameReq(struct soap *soap, const char *tag, int id, struct _ns1__updateChannelNameReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateChannelNameReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateChannelNameReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateChannelNameReq(struct soap *soap, const char *tag, struct _ns1__updateChannelNameReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateChannelNameReq **)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateChannelNameReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateChannelNameReq, sizeof(struct _ns1__updateChannelNameReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateChannelNameReq);
	if (soap_out_PointerTo_ns1__updateChannelNameReq(soap, tag?tag:"ns1:updateChannelNameReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateChannelNameReq(struct soap *soap, struct _ns1__updateChannelNameReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateChannelNameReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLogoutRes))
		soap_serialize__ns1__userLogoutRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLogoutRes(struct soap *soap, const char *tag, int id, struct _ns1__userLogoutRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLogoutRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLogoutRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLogoutRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLogoutRes(struct soap *soap, const char *tag, struct _ns1__userLogoutRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLogoutRes **)soap_malloc(soap, sizeof(struct _ns1__userLogoutRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLogoutRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLogoutRes, sizeof(struct _ns1__userLogoutRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLogoutRes);
	if (soap_out_PointerTo_ns1__userLogoutRes(soap, tag?tag:"ns1:userLogoutRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLogoutRes(struct soap *soap, struct _ns1__userLogoutRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLogoutRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLogoutReq))
		soap_serialize__ns1__userLogoutReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLogoutReq(struct soap *soap, const char *tag, int id, struct _ns1__userLogoutReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLogoutReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLogoutReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLogoutReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLogoutReq(struct soap *soap, const char *tag, struct _ns1__userLogoutReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLogoutReq **)soap_malloc(soap, sizeof(struct _ns1__userLogoutReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLogoutReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLogoutReq, sizeof(struct _ns1__userLogoutReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLogoutReq);
	if (soap_out_PointerTo_ns1__userLogoutReq(soap, tag?tag:"ns1:userLogoutReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLogoutReq(struct soap *soap, struct _ns1__userLogoutReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLogoutReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLoginRes(struct soap *soap, struct _ns1__userLoginRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLoginRes))
		soap_serialize__ns1__userLoginRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLoginRes(struct soap *soap, const char *tag, int id, struct _ns1__userLoginRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLoginRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLoginRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLoginRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLoginRes(struct soap *soap, const char *tag, struct _ns1__userLoginRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLoginRes **)soap_malloc(soap, sizeof(struct _ns1__userLoginRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLoginRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLoginRes, sizeof(struct _ns1__userLoginRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLoginRes(struct soap *soap, struct _ns1__userLoginRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLoginRes);
	if (soap_out_PointerTo_ns1__userLoginRes(soap, tag?tag:"ns1:userLoginRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLoginRes(struct soap *soap, struct _ns1__userLoginRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLoginRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLoginReq(struct soap *soap, struct _ns1__userLoginReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLoginReq))
		soap_serialize__ns1__userLoginReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLoginReq(struct soap *soap, const char *tag, int id, struct _ns1__userLoginReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLoginReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLoginReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLoginReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLoginReq(struct soap *soap, const char *tag, struct _ns1__userLoginReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLoginReq **)soap_malloc(soap, sizeof(struct _ns1__userLoginReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLoginReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLoginReq, sizeof(struct _ns1__userLoginReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLoginReq(struct soap *soap, struct _ns1__userLoginReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLoginReq);
	if (soap_out_PointerTo_ns1__userLoginReq(soap, tag?tag:"ns1:userLoginReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLoginReq(struct soap *soap, struct _ns1__userLoginReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLoginReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__byeRes(struct soap *soap, struct _ns1__byeRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__byeRes))
		soap_serialize__ns1__byeRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__byeRes(struct soap *soap, const char *tag, int id, struct _ns1__byeRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__byeRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__byeRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__byeRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__byeRes(struct soap *soap, const char *tag, struct _ns1__byeRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__byeRes **)soap_malloc(soap, sizeof(struct _ns1__byeRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__byeRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__byeRes, sizeof(struct _ns1__byeRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__byeRes(struct soap *soap, struct _ns1__byeRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__byeRes);
	if (soap_out_PointerTo_ns1__byeRes(soap, tag?tag:"ns1:byeRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__byeRes(struct soap *soap, struct _ns1__byeRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__byeRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__byeReq(struct soap *soap, struct _ns1__byeReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__byeReq))
		soap_serialize__ns1__byeReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__byeReq(struct soap *soap, const char *tag, int id, struct _ns1__byeReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__byeReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__byeReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__byeReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__byeReq(struct soap *soap, const char *tag, struct _ns1__byeReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__byeReq **)soap_malloc(soap, sizeof(struct _ns1__byeReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__byeReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__byeReq, sizeof(struct _ns1__byeReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__byeReq(struct soap *soap, struct _ns1__byeReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__byeReq);
	if (soap_out_PointerTo_ns1__byeReq(soap, tag?tag:"ns1:byeReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__byeReq(struct soap *soap, struct _ns1__byeReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__byeReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__inviteRes(struct soap *soap, struct _ns1__inviteRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__inviteRes))
		soap_serialize__ns1__inviteRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__inviteRes(struct soap *soap, const char *tag, int id, struct _ns1__inviteRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__inviteRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__inviteRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__inviteRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__inviteRes(struct soap *soap, const char *tag, struct _ns1__inviteRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__inviteRes **)soap_malloc(soap, sizeof(struct _ns1__inviteRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__inviteRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__inviteRes, sizeof(struct _ns1__inviteRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__inviteRes(struct soap *soap, struct _ns1__inviteRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__inviteRes);
	if (soap_out_PointerTo_ns1__inviteRes(soap, tag?tag:"ns1:inviteRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__inviteRes(struct soap *soap, struct _ns1__inviteRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__inviteRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__inviteReq(struct soap *soap, struct _ns1__inviteReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__inviteReq))
		soap_serialize__ns1__inviteReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__inviteReq(struct soap *soap, const char *tag, int id, struct _ns1__inviteReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__inviteReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__inviteReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__inviteReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__inviteReq(struct soap *soap, const char *tag, struct _ns1__inviteReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__inviteReq **)soap_malloc(soap, sizeof(struct _ns1__inviteReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__inviteReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__inviteReq, sizeof(struct _ns1__inviteReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__inviteReq(struct soap *soap, struct _ns1__inviteReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__inviteReq);
	if (soap_out_PointerTo_ns1__inviteReq(soap, tag?tag:"ns1:inviteReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__inviteReq(struct soap *soap, struct _ns1__inviteReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__inviteReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setAuxiliaryRes))
		soap_serialize__ns1__setAuxiliaryRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, const char *tag, int id, struct _ns1__setAuxiliaryRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setAuxiliaryRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setAuxiliaryRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setAuxiliaryRes **)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setAuxiliaryRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setAuxiliaryRes, sizeof(struct _ns1__setAuxiliaryRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes);
	if (soap_out_PointerTo_ns1__setAuxiliaryRes(soap, tag?tag:"ns1:setAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__setAuxiliaryRes(struct soap *soap, struct _ns1__setAuxiliaryRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setAuxiliaryReq))
		soap_serialize__ns1__setAuxiliaryReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, const char *tag, int id, struct _ns1__setAuxiliaryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setAuxiliaryReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setAuxiliaryReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setAuxiliaryReq **)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setAuxiliaryReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setAuxiliaryReq, sizeof(struct _ns1__setAuxiliaryReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq);
	if (soap_out_PointerTo_ns1__setAuxiliaryReq(soap, tag?tag:"ns1:setAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__setAuxiliaryReq(struct soap *soap, struct _ns1__setAuxiliaryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAuxiliaryRes))
		soap_serialize__ns1__getAuxiliaryRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, const char *tag, int id, struct _ns1__getAuxiliaryRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAuxiliaryRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAuxiliaryRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAuxiliaryRes **)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAuxiliaryRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAuxiliaryRes, sizeof(struct _ns1__getAuxiliaryRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes);
	if (soap_out_PointerTo_ns1__getAuxiliaryRes(soap, tag?tag:"ns1:getAuxiliaryRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAuxiliaryRes(struct soap *soap, struct _ns1__getAuxiliaryRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAuxiliaryRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAuxiliaryReq))
		soap_serialize__ns1__getAuxiliaryReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, const char *tag, int id, struct _ns1__getAuxiliaryReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAuxiliaryReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAuxiliaryReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAuxiliaryReq **)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAuxiliaryReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAuxiliaryReq, sizeof(struct _ns1__getAuxiliaryReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq);
	if (soap_out_PointerTo_ns1__getAuxiliaryReq(soap, tag?tag:"ns1:getAuxiliaryReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAuxiliaryReq(struct soap *soap, struct _ns1__getAuxiliaryReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAuxiliaryReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBackPasswordRes))
		soap_serialize__ns1__getBackPasswordRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBackPasswordRes(struct soap *soap, const char *tag, int id, struct _ns1__getBackPasswordRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBackPasswordRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getBackPasswordRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBackPasswordRes(struct soap *soap, const char *tag, struct _ns1__getBackPasswordRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getBackPasswordRes **)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getBackPasswordRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBackPasswordRes, sizeof(struct _ns1__getBackPasswordRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBackPasswordRes);
	if (soap_out_PointerTo_ns1__getBackPasswordRes(soap, tag?tag:"ns1:getBackPasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBackPasswordRes(struct soap *soap, struct _ns1__getBackPasswordRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBackPasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBackPasswordReq))
		soap_serialize__ns1__getBackPasswordReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBackPasswordReq(struct soap *soap, const char *tag, int id, struct _ns1__getBackPasswordReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBackPasswordReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getBackPasswordReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBackPasswordReq(struct soap *soap, const char *tag, struct _ns1__getBackPasswordReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getBackPasswordReq **)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getBackPasswordReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBackPasswordReq, sizeof(struct _ns1__getBackPasswordReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBackPasswordReq);
	if (soap_out_PointerTo_ns1__getBackPasswordReq(soap, tag?tag:"ns1:getBackPasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBackPasswordReq(struct soap *soap, struct _ns1__getBackPasswordReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBackPasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountRes))
		soap_serialize__ns1__getAccountRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountRes(struct soap *soap, const char *tag, int id, struct _ns1__getAccountRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountRes(struct soap *soap, const char *tag, struct _ns1__getAccountRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountRes **)soap_malloc(soap, sizeof(struct _ns1__getAccountRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountRes, sizeof(struct _ns1__getAccountRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountRes);
	if (soap_out_PointerTo_ns1__getAccountRes(soap, tag?tag:"ns1:getAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountRes(struct soap *soap, struct _ns1__getAccountRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountReq))
		soap_serialize__ns1__getAccountReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountReq(struct soap *soap, const char *tag, int id, struct _ns1__getAccountReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountReq(struct soap *soap, const char *tag, struct _ns1__getAccountReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountReq **)soap_malloc(soap, sizeof(struct _ns1__getAccountReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountReq, sizeof(struct _ns1__getAccountReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountReq);
	if (soap_out_PointerTo_ns1__getAccountReq(soap, tag?tag:"ns1:getAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountReq(struct soap *soap, struct _ns1__getAccountReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAppleTokenRes))
		soap_serialize__ns1__updateAppleTokenRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, const char *tag, int id, struct _ns1__updateAppleTokenRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAppleTokenRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAppleTokenRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAppleTokenRes **)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAppleTokenRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAppleTokenRes, sizeof(struct _ns1__updateAppleTokenRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes);
	if (soap_out_PointerTo_ns1__updateAppleTokenRes(soap, tag?tag:"ns1:updateAppleTokenRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAppleTokenRes(struct soap *soap, struct _ns1__updateAppleTokenRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAppleTokenRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAppleTokenReq))
		soap_serialize__ns1__updateAppleTokenReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, const char *tag, int id, struct _ns1__updateAppleTokenReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAppleTokenReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAppleTokenReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAppleTokenReq **)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAppleTokenReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAppleTokenReq, sizeof(struct _ns1__updateAppleTokenReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq);
	if (soap_out_PointerTo_ns1__updateAppleTokenReq(soap, tag?tag:"ns1:updateAppleTokenReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAppleTokenReq(struct soap *soap, struct _ns1__updateAppleTokenReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAppleTokenReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceRes))
		soap_serialize__ns1__queryDeviceRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceRes(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceRes(struct soap *soap, const char *tag, struct _ns1__queryDeviceRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceRes **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDeviceRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceRes, sizeof(struct _ns1__queryDeviceRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceRes);
	if (soap_out_PointerTo_ns1__queryDeviceRes(soap, tag?tag:"ns1:queryDeviceRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceRes(struct soap *soap, struct _ns1__queryDeviceRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceReq))
		soap_serialize__ns1__queryDeviceReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceReq(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceReq(struct soap *soap, const char *tag, struct _ns1__queryDeviceReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceReq **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDeviceReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceReq, sizeof(struct _ns1__queryDeviceReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceReq);
	if (soap_out_PointerTo_ns1__queryDeviceReq(soap, tag?tag:"ns1:queryDeviceReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceReq(struct soap *soap, struct _ns1__queryDeviceReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updatePasswordRes))
		soap_serialize__ns1__updatePasswordRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updatePasswordRes(struct soap *soap, const char *tag, int id, struct _ns1__updatePasswordRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updatePasswordRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updatePasswordRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updatePasswordRes(struct soap *soap, const char *tag, struct _ns1__updatePasswordRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updatePasswordRes **)soap_malloc(soap, sizeof(struct _ns1__updatePasswordRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updatePasswordRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updatePasswordRes, sizeof(struct _ns1__updatePasswordRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updatePasswordRes);
	if (soap_out_PointerTo_ns1__updatePasswordRes(soap, tag?tag:"ns1:updatePasswordRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updatePasswordRes(struct soap *soap, struct _ns1__updatePasswordRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updatePasswordRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updatePasswordReq))
		soap_serialize__ns1__updatePasswordReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updatePasswordReq(struct soap *soap, const char *tag, int id, struct _ns1__updatePasswordReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updatePasswordReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updatePasswordReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updatePasswordReq(struct soap *soap, const char *tag, struct _ns1__updatePasswordReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updatePasswordReq **)soap_malloc(soap, sizeof(struct _ns1__updatePasswordReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updatePasswordReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updatePasswordReq, sizeof(struct _ns1__updatePasswordReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updatePasswordReq);
	if (soap_out_PointerTo_ns1__updatePasswordReq(soap, tag?tag:"ns1:updatePasswordReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updatePasswordReq(struct soap *soap, struct _ns1__updatePasswordReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updatePasswordReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountRes))
		soap_serialize__ns1__updateAccountRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountRes(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountRes(struct soap *soap, const char *tag, struct _ns1__updateAccountRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountRes **)soap_malloc(soap, sizeof(struct _ns1__updateAccountRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountRes, sizeof(struct _ns1__updateAccountRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountRes);
	if (soap_out_PointerTo_ns1__updateAccountRes(soap, tag?tag:"ns1:updateAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountRes(struct soap *soap, struct _ns1__updateAccountRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountReq))
		soap_serialize__ns1__updateAccountReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountReq(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountReq(struct soap *soap, const char *tag, struct _ns1__updateAccountReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountReq **)soap_malloc(soap, sizeof(struct _ns1__updateAccountReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountReq, sizeof(struct _ns1__updateAccountReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountReq);
	if (soap_out_PointerTo_ns1__updateAccountReq(soap, tag?tag:"ns1:updateAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountReq(struct soap *soap, struct _ns1__updateAccountReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createAccountRes))
		soap_serialize__ns1__createAccountRes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createAccountRes(struct soap *soap, const char *tag, int id, struct _ns1__createAccountRes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createAccountRes);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createAccountRes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createAccountRes ** SOAP_FMAC4 soap_in_PointerTo_ns1__createAccountRes(struct soap *soap, const char *tag, struct _ns1__createAccountRes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createAccountRes **)soap_malloc(soap, sizeof(struct _ns1__createAccountRes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__createAccountRes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountRes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createAccountRes, sizeof(struct _ns1__createAccountRes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createAccountRes);
	if (soap_out_PointerTo_ns1__createAccountRes(soap, tag?tag:"ns1:createAccountRes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountRes ** SOAP_FMAC4 soap_get_PointerTo_ns1__createAccountRes(struct soap *soap, struct _ns1__createAccountRes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createAccountRes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createAccountReq))
		soap_serialize__ns1__createAccountReq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createAccountReq(struct soap *soap, const char *tag, int id, struct _ns1__createAccountReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createAccountReq);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createAccountReq(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createAccountReq ** SOAP_FMAC4 soap_in_PointerTo_ns1__createAccountReq(struct soap *soap, const char *tag, struct _ns1__createAccountReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createAccountReq **)soap_malloc(soap, sizeof(struct _ns1__createAccountReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__createAccountReq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createAccountReq, sizeof(struct _ns1__createAccountReq), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createAccountReq);
	if (soap_out_PointerTo_ns1__createAccountReq(soap, tag?tag:"ns1:createAccountReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountReq ** SOAP_FMAC4 soap_get_PointerTo_ns1__createAccountReq(struct soap *soap, struct _ns1__createAccountReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createAccountReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__vodSearchRes_Any(struct soap *soap, struct _ns1__vodSearchRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__vodSearchRes_Any))
		soap_serialize__ns1__vodSearchRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__vodSearchRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__vodSearchRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__vodSearchRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__vodSearchRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__vodSearchRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__vodSearchRes_Any(struct soap *soap, const char *tag, struct _ns1__vodSearchRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__vodSearchRes_Any **)soap_malloc(soap, sizeof(struct _ns1__vodSearchRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__vodSearchRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__vodSearchRes_Any, sizeof(struct _ns1__vodSearchRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__vodSearchRes_Any(struct soap *soap, struct _ns1__vodSearchRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__vodSearchRes_Any);
	if (soap_out_PointerTo_ns1__vodSearchRes_Any(soap, tag?tag:"ns1:vodSearchRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__vodSearchRes_Any(struct soap *soap, struct _ns1__vodSearchRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__vodSearchRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VODRecord(struct soap *soap, struct ns1__VODRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VODRecord))
		soap_serialize_ns1__VODRecord(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VODRecord(struct soap *soap, const char *tag, int id, struct ns1__VODRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VODRecord);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VODRecord(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VODRecord ** SOAP_FMAC4 soap_in_PointerTons1__VODRecord(struct soap *soap, const char *tag, struct ns1__VODRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VODRecord **)soap_malloc(soap, sizeof(struct ns1__VODRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VODRecord(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VODRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VODRecord, sizeof(struct ns1__VODRecord), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VODRecord(struct soap *soap, struct ns1__VODRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VODRecord);
	if (soap_out_PointerTons1__VODRecord(soap, tag?tag:"ns1:VODRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VODRecord ** SOAP_FMAC4 soap_get_PointerTons1__VODRecord(struct soap *soap, struct ns1__VODRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VODRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__vodSearchReq_Any(struct soap *soap, struct _ns1__vodSearchReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__vodSearchReq_Any))
		soap_serialize__ns1__vodSearchReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__vodSearchReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__vodSearchReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__vodSearchReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__vodSearchReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__vodSearchReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__vodSearchReq_Any(struct soap *soap, const char *tag, struct _ns1__vodSearchReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__vodSearchReq_Any **)soap_malloc(soap, sizeof(struct _ns1__vodSearchReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__vodSearchReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__vodSearchReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__vodSearchReq_Any, sizeof(struct _ns1__vodSearchReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__vodSearchReq_Any(struct soap *soap, struct _ns1__vodSearchReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__vodSearchReq_Any);
	if (soap_out_PointerTo_ns1__vodSearchReq_Any(soap, tag?tag:"ns1:vodSearchReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__vodSearchReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__vodSearchReq_Any(struct soap *soap, struct _ns1__vodSearchReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__vodSearchReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVODUrlRes_Any(struct soap *soap, struct _ns1__getVODUrlRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVODUrlRes_Any))
		soap_serialize__ns1__getVODUrlRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVODUrlRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getVODUrlRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVODUrlRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVODUrlRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVODUrlRes_Any(struct soap *soap, const char *tag, struct _ns1__getVODUrlRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVODUrlRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getVODUrlRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVODUrlRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVODUrlRes_Any, sizeof(struct _ns1__getVODUrlRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVODUrlRes_Any(struct soap *soap, struct _ns1__getVODUrlRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVODUrlRes_Any);
	if (soap_out_PointerTo_ns1__getVODUrlRes_Any(soap, tag?tag:"ns1:getVODUrlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVODUrlRes_Any(struct soap *soap, struct _ns1__getVODUrlRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVODUrlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVODUrlReq_Any(struct soap *soap, struct _ns1__getVODUrlReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVODUrlReq_Any))
		soap_serialize__ns1__getVODUrlReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVODUrlReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getVODUrlReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVODUrlReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVODUrlReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVODUrlReq_Any(struct soap *soap, const char *tag, struct _ns1__getVODUrlReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVODUrlReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getVODUrlReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVODUrlReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVODUrlReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVODUrlReq_Any, sizeof(struct _ns1__getVODUrlReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVODUrlReq_Any(struct soap *soap, struct _ns1__getVODUrlReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVODUrlReq_Any);
	if (soap_out_PointerTo_ns1__getVODUrlReq_Any(soap, tag?tag:"ns1:getVODUrlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVODUrlReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVODUrlReq_Any(struct soap *soap, struct _ns1__getVODUrlReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVODUrlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPlayUrlRes_Any(struct soap *soap, struct _ns1__getPlayUrlRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPlayUrlRes_Any))
		soap_serialize__ns1__getPlayUrlRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPlayUrlRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getPlayUrlRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPlayUrlRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPlayUrlRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPlayUrlRes_Any(struct soap *soap, const char *tag, struct _ns1__getPlayUrlRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPlayUrlRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPlayUrlRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPlayUrlRes_Any, sizeof(struct _ns1__getPlayUrlRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPlayUrlRes_Any(struct soap *soap, struct _ns1__getPlayUrlRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPlayUrlRes_Any);
	if (soap_out_PointerTo_ns1__getPlayUrlRes_Any(soap, tag?tag:"ns1:getPlayUrlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPlayUrlRes_Any(struct soap *soap, struct _ns1__getPlayUrlRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPlayUrlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPlayUrlReq_Any(struct soap *soap, struct _ns1__getPlayUrlReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPlayUrlReq_Any))
		soap_serialize__ns1__getPlayUrlReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPlayUrlReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getPlayUrlReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPlayUrlReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPlayUrlReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPlayUrlReq_Any(struct soap *soap, const char *tag, struct _ns1__getPlayUrlReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPlayUrlReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getPlayUrlReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPlayUrlReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPlayUrlReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPlayUrlReq_Any, sizeof(struct _ns1__getPlayUrlReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPlayUrlReq_Any(struct soap *soap, struct _ns1__getPlayUrlReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPlayUrlReq_Any);
	if (soap_out_PointerTo_ns1__getPlayUrlReq_Any(soap, tag?tag:"ns1:getPlayUrlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPlayUrlReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPlayUrlReq_Any(struct soap *soap, struct _ns1__getPlayUrlReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPlayUrlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any))
		soap_serialize__ns1__setPrivacyMaskParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setPrivacyMaskParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPrivacyMaskParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPrivacyMaskParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setPrivacyMaskParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPrivacyMaskParamRes_Any, sizeof(struct _ns1__setPrivacyMaskParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamRes_Any);
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamRes_Any(soap, tag?tag:"ns1:setPrivacyMaskParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPrivacyMaskParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any))
		soap_serialize__ns1__setPrivacyMaskParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setPrivacyMaskParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setPrivacyMaskParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setPrivacyMaskParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setPrivacyMaskParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setPrivacyMaskParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setPrivacyMaskParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setPrivacyMaskParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setPrivacyMaskParamReq_Any, sizeof(struct _ns1__setPrivacyMaskParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setPrivacyMaskParamReq_Any);
	if (soap_out_PointerTo_ns1__setPrivacyMaskParamReq_Any(soap, tag?tag:"ns1:setPrivacyMaskParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setPrivacyMaskParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__setPrivacyMaskParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setPrivacyMaskParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any))
		soap_serialize__ns1__getPrivacyMaskParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getPrivacyMaskParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPrivacyMaskParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrivacyMaskParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPrivacyMaskParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPrivacyMaskParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrivacyMaskParamRes_Any, sizeof(struct _ns1__getPrivacyMaskParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamRes_Any);
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamRes_Any(soap, tag?tag:"ns1:getPrivacyMaskParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrivacyMaskParamRes_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrivacyMaskParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PrivacyMaskRegion))
		soap_serialize_ns1__PrivacyMaskRegion(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PrivacyMaskRegion(struct soap *soap, const char *tag, int id, struct ns1__PrivacyMaskRegion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PrivacyMaskRegion);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PrivacyMaskRegion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion ** SOAP_FMAC4 soap_in_PointerTons1__PrivacyMaskRegion(struct soap *soap, const char *tag, struct ns1__PrivacyMaskRegion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PrivacyMaskRegion **)soap_malloc(soap, sizeof(struct ns1__PrivacyMaskRegion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PrivacyMaskRegion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PrivacyMaskRegion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PrivacyMaskRegion, sizeof(struct ns1__PrivacyMaskRegion), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PrivacyMaskRegion);
	if (soap_out_PointerTons1__PrivacyMaskRegion(soap, tag?tag:"ns1:PrivacyMaskRegion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PrivacyMaskRegion ** SOAP_FMAC4 soap_get_PointerTons1__PrivacyMaskRegion(struct soap *soap, struct ns1__PrivacyMaskRegion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PrivacyMaskRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any))
		soap_serialize__ns1__getPrivacyMaskParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getPrivacyMaskParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getPrivacyMaskParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getPrivacyMaskParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getPrivacyMaskParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getPrivacyMaskParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getPrivacyMaskParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getPrivacyMaskParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getPrivacyMaskParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getPrivacyMaskParamReq_Any, sizeof(struct _ns1__getPrivacyMaskParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getPrivacyMaskParamReq_Any);
	if (soap_out_PointerTo_ns1__getPrivacyMaskParamReq_Any(soap, tag?tag:"ns1:getPrivacyMaskParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getPrivacyMaskParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getPrivacyMaskParamReq_Any(struct soap *soap, struct _ns1__getPrivacyMaskParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getPrivacyMaskParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVMDParamRes_Any(struct soap *soap, struct _ns1__setVMDParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVMDParamRes_Any))
		soap_serialize__ns1__setVMDParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVMDParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setVMDParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVMDParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVMDParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVMDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setVMDParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVMDParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setVMDParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVMDParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVMDParamRes_Any, sizeof(struct _ns1__setVMDParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVMDParamRes_Any(struct soap *soap, struct _ns1__setVMDParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVMDParamRes_Any);
	if (soap_out_PointerTo_ns1__setVMDParamRes_Any(soap, tag?tag:"ns1:setVMDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVMDParamRes_Any(struct soap *soap, struct _ns1__setVMDParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVMDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVMDParamReq_Any(struct soap *soap, struct _ns1__setVMDParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVMDParamReq_Any))
		soap_serialize__ns1__setVMDParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVMDParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setVMDParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVMDParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVMDParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVMDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setVMDParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVMDParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setVMDParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVMDParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVMDParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVMDParamReq_Any, sizeof(struct _ns1__setVMDParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVMDParamReq_Any(struct soap *soap, struct _ns1__setVMDParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVMDParamReq_Any);
	if (soap_out_PointerTo_ns1__setVMDParamReq_Any(soap, tag?tag:"ns1:setVMDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVMDParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVMDParamReq_Any(struct soap *soap, struct _ns1__setVMDParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVMDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVMDParamRes_Any(struct soap *soap, struct _ns1__getVMDParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVMDParamRes_Any))
		soap_serialize__ns1__getVMDParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVMDParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getVMDParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVMDParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVMDParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVMDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getVMDParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVMDParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getVMDParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVMDParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVMDParamRes_Any, sizeof(struct _ns1__getVMDParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVMDParamRes_Any(struct soap *soap, struct _ns1__getVMDParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVMDParamRes_Any);
	if (soap_out_PointerTo_ns1__getVMDParamRes_Any(soap, tag?tag:"ns1:getVMDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVMDParamRes_Any(struct soap *soap, struct _ns1__getVMDParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVMDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VMDGrid))
		soap_serialize_ns1__VMDGrid(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VMDGrid(struct soap *soap, const char *tag, int id, struct ns1__VMDGrid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VMDGrid);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VMDGrid(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VMDGrid ** SOAP_FMAC4 soap_in_PointerTons1__VMDGrid(struct soap *soap, const char *tag, struct ns1__VMDGrid **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VMDGrid **)soap_malloc(soap, sizeof(struct ns1__VMDGrid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VMDGrid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VMDGrid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VMDGrid, sizeof(struct ns1__VMDGrid), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VMDGrid(struct soap *soap, struct ns1__VMDGrid *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VMDGrid);
	if (soap_out_PointerTons1__VMDGrid(soap, tag?tag:"ns1:VMDGrid", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VMDGrid ** SOAP_FMAC4 soap_get_PointerTons1__VMDGrid(struct soap *soap, struct ns1__VMDGrid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VMDGrid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVMDParamReq_Any(struct soap *soap, struct _ns1__getVMDParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVMDParamReq_Any))
		soap_serialize__ns1__getVMDParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVMDParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getVMDParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVMDParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVMDParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVMDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getVMDParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVMDParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getVMDParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVMDParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVMDParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVMDParamReq_Any, sizeof(struct _ns1__getVMDParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVMDParamReq_Any(struct soap *soap, struct _ns1__getVMDParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVMDParamReq_Any);
	if (soap_out_PointerTo_ns1__getVMDParamReq_Any(soap, tag?tag:"ns1:getVMDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVMDParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVMDParamReq_Any(struct soap *soap, struct _ns1__getVMDParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVMDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setTimeRes_Any(struct soap *soap, struct _ns1__setTimeRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setTimeRes_Any))
		soap_serialize__ns1__setTimeRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setTimeRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setTimeRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setTimeRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setTimeRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setTimeRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setTimeRes_Any(struct soap *soap, const char *tag, struct _ns1__setTimeRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setTimeRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setTimeRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setTimeRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setTimeRes_Any, sizeof(struct _ns1__setTimeRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setTimeRes_Any(struct soap *soap, struct _ns1__setTimeRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setTimeRes_Any);
	if (soap_out_PointerTo_ns1__setTimeRes_Any(soap, tag?tag:"ns1:setTimeRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setTimeRes_Any(struct soap *soap, struct _ns1__setTimeRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setTimeRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setTimeReq_Any(struct soap *soap, struct _ns1__setTimeReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setTimeReq_Any))
		soap_serialize__ns1__setTimeReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setTimeReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setTimeReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setTimeReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setTimeReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setTimeReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setTimeReq_Any(struct soap *soap, const char *tag, struct _ns1__setTimeReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setTimeReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setTimeReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setTimeReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setTimeReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setTimeReq_Any, sizeof(struct _ns1__setTimeReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setTimeReq_Any(struct soap *soap, struct _ns1__setTimeReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setTimeReq_Any);
	if (soap_out_PointerTo_ns1__setTimeReq_Any(soap, tag?tag:"ns1:setTimeReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setTimeReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setTimeReq_Any(struct soap *soap, struct _ns1__setTimeReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setTimeReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTimeRes_Any(struct soap *soap, struct _ns1__getTimeRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTimeRes_Any))
		soap_serialize__ns1__getTimeRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTimeRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getTimeRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTimeRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getTimeRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getTimeRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTimeRes_Any(struct soap *soap, const char *tag, struct _ns1__getTimeRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getTimeRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getTimeRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getTimeRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTimeRes_Any, sizeof(struct _ns1__getTimeRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTimeRes_Any(struct soap *soap, struct _ns1__getTimeRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTimeRes_Any);
	if (soap_out_PointerTo_ns1__getTimeRes_Any(soap, tag?tag:"ns1:getTimeRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTimeRes_Any(struct soap *soap, struct _ns1__getTimeRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTimeRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getTimeReq_Any(struct soap *soap, struct _ns1__getTimeReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getTimeReq_Any))
		soap_serialize__ns1__getTimeReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getTimeReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getTimeReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getTimeReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getTimeReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getTimeReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getTimeReq_Any(struct soap *soap, const char *tag, struct _ns1__getTimeReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getTimeReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getTimeReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getTimeReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getTimeReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getTimeReq_Any, sizeof(struct _ns1__getTimeReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getTimeReq_Any(struct soap *soap, struct _ns1__getTimeReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getTimeReq_Any);
	if (soap_out_PointerTo_ns1__getTimeReq_Any(soap, tag?tag:"ns1:getTimeReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getTimeReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getTimeReq_Any(struct soap *soap, struct _ns1__getTimeReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getTimeReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setOSDParamRes_Any(struct soap *soap, struct _ns1__setOSDParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setOSDParamRes_Any))
		soap_serialize__ns1__setOSDParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setOSDParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setOSDParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setOSDParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setOSDParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setOSDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setOSDParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setOSDParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setOSDParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setOSDParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setOSDParamRes_Any, sizeof(struct _ns1__setOSDParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setOSDParamRes_Any(struct soap *soap, struct _ns1__setOSDParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setOSDParamRes_Any);
	if (soap_out_PointerTo_ns1__setOSDParamRes_Any(soap, tag?tag:"ns1:setOSDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setOSDParamRes_Any(struct soap *soap, struct _ns1__setOSDParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setOSDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setOSDParamReq_Any(struct soap *soap, struct _ns1__setOSDParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setOSDParamReq_Any))
		soap_serialize__ns1__setOSDParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setOSDParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setOSDParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setOSDParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setOSDParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setOSDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setOSDParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setOSDParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setOSDParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setOSDParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setOSDParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setOSDParamReq_Any, sizeof(struct _ns1__setOSDParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setOSDParamReq_Any(struct soap *soap, struct _ns1__setOSDParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setOSDParamReq_Any);
	if (soap_out_PointerTo_ns1__setOSDParamReq_Any(soap, tag?tag:"ns1:setOSDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setOSDParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setOSDParamReq_Any(struct soap *soap, struct _ns1__setOSDParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setOSDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOSDParamRes_Any(struct soap *soap, struct _ns1__getOSDParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOSDParamRes_Any))
		soap_serialize__ns1__getOSDParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOSDParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getOSDParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOSDParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getOSDParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOSDParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getOSDParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getOSDParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getOSDParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getOSDParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOSDParamRes_Any, sizeof(struct _ns1__getOSDParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOSDParamRes_Any(struct soap *soap, struct _ns1__getOSDParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOSDParamRes_Any);
	if (soap_out_PointerTo_ns1__getOSDParamRes_Any(soap, tag?tag:"ns1:getOSDParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOSDParamRes_Any(struct soap *soap, struct _ns1__getOSDParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOSDParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getOSDParamReq_Any(struct soap *soap, struct _ns1__getOSDParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getOSDParamReq_Any))
		soap_serialize__ns1__getOSDParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getOSDParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getOSDParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getOSDParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getOSDParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getOSDParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getOSDParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getOSDParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getOSDParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getOSDParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getOSDParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getOSDParamReq_Any, sizeof(struct _ns1__getOSDParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getOSDParamReq_Any(struct soap *soap, struct _ns1__getOSDParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getOSDParamReq_Any);
	if (soap_out_PointerTo_ns1__getOSDParamReq_Any(soap, tag?tag:"ns1:getOSDParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getOSDParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getOSDParamReq_Any(struct soap *soap, struct _ns1__getOSDParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getOSDParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVideoParamRes_Any(struct soap *soap, struct _ns1__setVideoParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVideoParamRes_Any))
		soap_serialize__ns1__setVideoParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVideoParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setVideoParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVideoParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVideoParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVideoParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setVideoParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVideoParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setVideoParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVideoParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVideoParamRes_Any, sizeof(struct _ns1__setVideoParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVideoParamRes_Any(struct soap *soap, struct _ns1__setVideoParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVideoParamRes_Any);
	if (soap_out_PointerTo_ns1__setVideoParamRes_Any(soap, tag?tag:"ns1:setVideoParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVideoParamRes_Any(struct soap *soap, struct _ns1__setVideoParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVideoParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setVideoParamReq_Any(struct soap *soap, struct _ns1__setVideoParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setVideoParamReq_Any))
		soap_serialize__ns1__setVideoParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setVideoParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setVideoParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setVideoParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setVideoParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setVideoParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setVideoParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setVideoParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setVideoParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setVideoParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setVideoParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setVideoParamReq_Any, sizeof(struct _ns1__setVideoParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setVideoParamReq_Any(struct soap *soap, struct _ns1__setVideoParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setVideoParamReq_Any);
	if (soap_out_PointerTo_ns1__setVideoParamReq_Any(soap, tag?tag:"ns1:setVideoParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setVideoParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setVideoParamReq_Any(struct soap *soap, struct _ns1__setVideoParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setVideoParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVideoParamRes_Any(struct soap *soap, struct _ns1__getVideoParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVideoParamRes_Any))
		soap_serialize__ns1__getVideoParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVideoParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getVideoParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVideoParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVideoParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVideoParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getVideoParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVideoParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getVideoParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVideoParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVideoParamRes_Any, sizeof(struct _ns1__getVideoParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVideoParamRes_Any(struct soap *soap, struct _ns1__getVideoParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVideoParamRes_Any);
	if (soap_out_PointerTo_ns1__getVideoParamRes_Any(soap, tag?tag:"ns1:getVideoParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVideoParamRes_Any(struct soap *soap, struct _ns1__getVideoParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVideoParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__VideoStandard);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VideoStandard(struct soap *soap, const char *tag, int id, enum ns1__VideoStandard *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VideoStandard);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VideoStandard(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__VideoStandard ** SOAP_FMAC4 soap_in_PointerTons1__VideoStandard(struct soap *soap, const char *tag, enum ns1__VideoStandard **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__VideoStandard **)soap_malloc(soap, sizeof(enum ns1__VideoStandard *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VideoStandard(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__VideoStandard **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VideoStandard, sizeof(enum ns1__VideoStandard), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VideoStandard(struct soap *soap, enum ns1__VideoStandard *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VideoStandard);
	if (soap_out_PointerTons1__VideoStandard(soap, tag?tag:"ns1:VideoStandard", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__VideoStandard ** SOAP_FMAC4 soap_get_PointerTons1__VideoStandard(struct soap *soap, enum ns1__VideoStandard **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VideoStandard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getVideoParamReq_Any(struct soap *soap, struct _ns1__getVideoParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getVideoParamReq_Any))
		soap_serialize__ns1__getVideoParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getVideoParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getVideoParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getVideoParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getVideoParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getVideoParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getVideoParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getVideoParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getVideoParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getVideoParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getVideoParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getVideoParamReq_Any, sizeof(struct _ns1__getVideoParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getVideoParamReq_Any(struct soap *soap, struct _ns1__getVideoParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getVideoParamReq_Any);
	if (soap_out_PointerTo_ns1__getVideoParamReq_Any(soap, tag?tag:"ns1:getVideoParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getVideoParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getVideoParamReq_Any(struct soap *soap, struct _ns1__getVideoParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getVideoParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDevLogRes_Any(struct soap *soap, struct _ns1__queryDevLogRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDevLogRes_Any))
		soap_serialize__ns1__queryDevLogRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDevLogRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__queryDevLogRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDevLogRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDevLogRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDevLogRes_Any(struct soap *soap, const char *tag, struct _ns1__queryDevLogRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDevLogRes_Any **)soap_malloc(soap, sizeof(struct _ns1__queryDevLogRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDevLogRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDevLogRes_Any, sizeof(struct _ns1__queryDevLogRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDevLogRes_Any(struct soap *soap, struct _ns1__queryDevLogRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDevLogRes_Any);
	if (soap_out_PointerTo_ns1__queryDevLogRes_Any(soap, tag?tag:"ns1:queryDevLogRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDevLogRes_Any(struct soap *soap, struct _ns1__queryDevLogRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDevLogRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDevLog))
		soap_serialize_ns1__ArrayOfDevLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDevLog(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDevLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDevLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDevLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDevLog(struct soap *soap, const char *tag, struct ns1__ArrayOfDevLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDevLog **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDevLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfDevLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDevLog, sizeof(struct ns1__ArrayOfDevLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDevLog);
	if (soap_out_PointerTons1__ArrayOfDevLog(soap, tag?tag:"ns1:ArrayOfDevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevLog ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDevLog(struct soap *soap, struct ns1__ArrayOfDevLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDevLogReq_Any(struct soap *soap, struct _ns1__queryDevLogReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDevLogReq_Any))
		soap_serialize__ns1__queryDevLogReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDevLogReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__queryDevLogReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDevLogReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDevLogReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDevLogReq_Any(struct soap *soap, const char *tag, struct _ns1__queryDevLogReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDevLogReq_Any **)soap_malloc(soap, sizeof(struct _ns1__queryDevLogReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDevLogReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDevLogReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDevLogReq_Any, sizeof(struct _ns1__queryDevLogReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDevLogReq_Any(struct soap *soap, struct _ns1__queryDevLogReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDevLogReq_Any);
	if (soap_out_PointerTo_ns1__queryDevLogReq_Any(soap, tag?tag:"ns1:queryDevLogReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDevLogReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDevLogReq_Any(struct soap *soap, struct _ns1__queryDevLogReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDevLogReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryLogRes_Any(struct soap *soap, struct _ns1__queryLogRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryLogRes_Any))
		soap_serialize__ns1__queryLogRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryLogRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__queryLogRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryLogRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryLogRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryLogRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryLogRes_Any(struct soap *soap, const char *tag, struct _ns1__queryLogRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryLogRes_Any **)soap_malloc(soap, sizeof(struct _ns1__queryLogRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryLogRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryLogRes_Any, sizeof(struct _ns1__queryLogRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryLogRes_Any(struct soap *soap, struct _ns1__queryLogRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryLogRes_Any);
	if (soap_out_PointerTo_ns1__queryLogRes_Any(soap, tag?tag:"ns1:queryLogRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryLogRes_Any(struct soap *soap, struct _ns1__queryLogRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryLogRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfPuLog))
		soap_serialize_ns1__ArrayOfPuLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfPuLog(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfPuLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfPuLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfPuLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfPuLog(struct soap *soap, const char *tag, struct ns1__ArrayOfPuLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfPuLog **)soap_malloc(soap, sizeof(struct ns1__ArrayOfPuLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfPuLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfPuLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfPuLog, sizeof(struct ns1__ArrayOfPuLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfPuLog);
	if (soap_out_PointerTons1__ArrayOfPuLog(soap, tag?tag:"ns1:ArrayOfPuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfPuLog ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfPuLog(struct soap *soap, struct ns1__ArrayOfPuLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfPuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryLogReq_Any(struct soap *soap, struct _ns1__queryLogReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryLogReq_Any))
		soap_serialize__ns1__queryLogReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryLogReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__queryLogReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryLogReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryLogReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryLogReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryLogReq_Any(struct soap *soap, const char *tag, struct _ns1__queryLogReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryLogReq_Any **)soap_malloc(soap, sizeof(struct _ns1__queryLogReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryLogReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryLogReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryLogReq_Any, sizeof(struct _ns1__queryLogReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryLogReq_Any(struct soap *soap, struct _ns1__queryLogReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryLogReq_Any);
	if (soap_out_PointerTo_ns1__queryLogReq_Any(soap, tag?tag:"ns1:queryLogReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryLogReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryLogReq_Any(struct soap *soap, struct _ns1__queryLogReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryLogReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upgradeDevVerRes_Any(struct soap *soap, struct _ns1__upgradeDevVerRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upgradeDevVerRes_Any))
		soap_serialize__ns1__upgradeDevVerRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upgradeDevVerRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__upgradeDevVerRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upgradeDevVerRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__upgradeDevVerRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__upgradeDevVerRes_Any(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__upgradeDevVerRes_Any **)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__upgradeDevVerRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upgradeDevVerRes_Any, sizeof(struct _ns1__upgradeDevVerRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upgradeDevVerRes_Any(struct soap *soap, struct _ns1__upgradeDevVerRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__upgradeDevVerRes_Any);
	if (soap_out_PointerTo_ns1__upgradeDevVerRes_Any(soap, tag?tag:"ns1:upgradeDevVerRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__upgradeDevVerRes_Any(struct soap *soap, struct _ns1__upgradeDevVerRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upgradeDevVerRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__upgradeDevVerReq_Any(struct soap *soap, struct _ns1__upgradeDevVerReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__upgradeDevVerReq_Any))
		soap_serialize__ns1__upgradeDevVerReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__upgradeDevVerReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__upgradeDevVerReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__upgradeDevVerReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__upgradeDevVerReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__upgradeDevVerReq_Any(struct soap *soap, const char *tag, struct _ns1__upgradeDevVerReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__upgradeDevVerReq_Any **)soap_malloc(soap, sizeof(struct _ns1__upgradeDevVerReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__upgradeDevVerReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__upgradeDevVerReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__upgradeDevVerReq_Any, sizeof(struct _ns1__upgradeDevVerReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__upgradeDevVerReq_Any(struct soap *soap, struct _ns1__upgradeDevVerReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__upgradeDevVerReq_Any);
	if (soap_out_PointerTo_ns1__upgradeDevVerReq_Any(soap, tag?tag:"ns1:upgradeDevVerReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__upgradeDevVerReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__upgradeDevVerReq_Any(struct soap *soap, struct _ns1__upgradeDevVerReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__upgradeDevVerReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDevVerRes_Any(struct soap *soap, struct _ns1__getDevVerRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDevVerRes_Any))
		soap_serialize__ns1__getDevVerRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDevVerRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getDevVerRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDevVerRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDevVerRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDevVerRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDevVerRes_Any(struct soap *soap, const char *tag, struct _ns1__getDevVerRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDevVerRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getDevVerRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getDevVerRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDevVerRes_Any, sizeof(struct _ns1__getDevVerRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDevVerRes_Any(struct soap *soap, struct _ns1__getDevVerRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDevVerRes_Any);
	if (soap_out_PointerTo_ns1__getDevVerRes_Any(soap, tag?tag:"ns1:getDevVerRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDevVerRes_Any(struct soap *soap, struct _ns1__getDevVerRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDevVerRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDevVerReq_Any(struct soap *soap, struct _ns1__getDevVerReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getDevVerReq_Any))
		soap_serialize__ns1__getDevVerReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDevVerReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getDevVerReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getDevVerReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getDevVerReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getDevVerReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDevVerReq_Any(struct soap *soap, const char *tag, struct _ns1__getDevVerReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getDevVerReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getDevVerReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getDevVerReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getDevVerReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getDevVerReq_Any, sizeof(struct _ns1__getDevVerReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDevVerReq_Any(struct soap *soap, struct _ns1__getDevVerReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getDevVerReq_Any);
	if (soap_out_PointerTo_ns1__getDevVerReq_Any(soap, tag?tag:"ns1:getDevVerReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getDevVerReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDevVerReq_Any(struct soap *soap, struct _ns1__getDevVerReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getDevVerReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__rebootRes_Any(struct soap *soap, struct _ns1__rebootRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__rebootRes_Any))
		soap_serialize__ns1__rebootRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__rebootRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__rebootRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__rebootRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__rebootRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__rebootRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__rebootRes_Any(struct soap *soap, const char *tag, struct _ns1__rebootRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__rebootRes_Any **)soap_malloc(soap, sizeof(struct _ns1__rebootRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__rebootRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__rebootRes_Any, sizeof(struct _ns1__rebootRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__rebootRes_Any(struct soap *soap, struct _ns1__rebootRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__rebootRes_Any);
	if (soap_out_PointerTo_ns1__rebootRes_Any(soap, tag?tag:"ns1:rebootRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__rebootRes_Any(struct soap *soap, struct _ns1__rebootRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__rebootRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__rebootReq_Any(struct soap *soap, struct _ns1__rebootReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__rebootReq_Any))
		soap_serialize__ns1__rebootReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__rebootReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__rebootReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__rebootReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__rebootReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__rebootReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__rebootReq_Any(struct soap *soap, const char *tag, struct _ns1__rebootReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__rebootReq_Any **)soap_malloc(soap, sizeof(struct _ns1__rebootReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__rebootReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__rebootReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__rebootReq_Any, sizeof(struct _ns1__rebootReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__rebootReq_Any(struct soap *soap, struct _ns1__rebootReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__rebootReq_Any);
	if (soap_out_PointerTo_ns1__rebootReq_Any(soap, tag?tag:"ns1:rebootReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__rebootReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__rebootReq_Any(struct soap *soap, struct _ns1__rebootReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__rebootReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setCodingParamRes_Any(struct soap *soap, struct _ns1__setCodingParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setCodingParamRes_Any))
		soap_serialize__ns1__setCodingParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setCodingParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setCodingParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setCodingParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setCodingParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setCodingParamRes_Any(struct soap *soap, const char *tag, struct _ns1__setCodingParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setCodingParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setCodingParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setCodingParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setCodingParamRes_Any, sizeof(struct _ns1__setCodingParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setCodingParamRes_Any(struct soap *soap, struct _ns1__setCodingParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setCodingParamRes_Any);
	if (soap_out_PointerTo_ns1__setCodingParamRes_Any(soap, tag?tag:"ns1:setCodingParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setCodingParamRes_Any(struct soap *soap, struct _ns1__setCodingParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setCodingParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setCodingParamReq_Any(struct soap *soap, struct _ns1__setCodingParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setCodingParamReq_Any))
		soap_serialize__ns1__setCodingParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setCodingParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setCodingParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setCodingParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setCodingParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setCodingParamReq_Any(struct soap *soap, const char *tag, struct _ns1__setCodingParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setCodingParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setCodingParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setCodingParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setCodingParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setCodingParamReq_Any, sizeof(struct _ns1__setCodingParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setCodingParamReq_Any(struct soap *soap, struct _ns1__setCodingParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setCodingParamReq_Any);
	if (soap_out_PointerTo_ns1__setCodingParamReq_Any(soap, tag?tag:"ns1:setCodingParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setCodingParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setCodingParamReq_Any(struct soap *soap, struct _ns1__setCodingParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setCodingParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCodingParamRes_Any(struct soap *soap, struct _ns1__getCodingParamRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCodingParamRes_Any))
		soap_serialize__ns1__getCodingParamRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCodingParamRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getCodingParamRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCodingParamRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getCodingParamRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCodingParamRes_Any(struct soap *soap, const char *tag, struct _ns1__getCodingParamRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getCodingParamRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getCodingParamRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getCodingParamRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCodingParamRes_Any, sizeof(struct _ns1__getCodingParamRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCodingParamRes_Any(struct soap *soap, struct _ns1__getCodingParamRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCodingParamRes_Any);
	if (soap_out_PointerTo_ns1__getCodingParamRes_Any(soap, tag?tag:"ns1:getCodingParamRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCodingParamRes_Any(struct soap *soap, struct _ns1__getCodingParamRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCodingParamRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RateType(struct soap *soap, enum ns1__RateType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__RateType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RateType(struct soap *soap, const char *tag, int id, enum ns1__RateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RateType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__RateType ** SOAP_FMAC4 soap_in_PointerTons1__RateType(struct soap *soap, const char *tag, enum ns1__RateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__RateType **)soap_malloc(soap, sizeof(enum ns1__RateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__RateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RateType, sizeof(enum ns1__RateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RateType(struct soap *soap, enum ns1__RateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RateType);
	if (soap_out_PointerTons1__RateType(soap, tag?tag:"ns1:RateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RateType ** SOAP_FMAC4 soap_get_PointerTons1__RateType(struct soap *soap, enum ns1__RateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FrameSize(struct soap *soap, enum ns1__FrameSize *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__FrameSize);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FrameSize(struct soap *soap, const char *tag, int id, enum ns1__FrameSize *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FrameSize);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FrameSize(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__FrameSize ** SOAP_FMAC4 soap_in_PointerTons1__FrameSize(struct soap *soap, const char *tag, enum ns1__FrameSize **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__FrameSize **)soap_malloc(soap, sizeof(enum ns1__FrameSize *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FrameSize(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__FrameSize **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FrameSize, sizeof(enum ns1__FrameSize), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FrameSize(struct soap *soap, enum ns1__FrameSize *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FrameSize);
	if (soap_out_PointerTons1__FrameSize(soap, tag?tag:"ns1:FrameSize", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FrameSize ** SOAP_FMAC4 soap_get_PointerTons1__FrameSize(struct soap *soap, enum ns1__FrameSize **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FrameSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCodingParamReq_Any(struct soap *soap, struct _ns1__getCodingParamReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCodingParamReq_Any))
		soap_serialize__ns1__getCodingParamReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCodingParamReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getCodingParamReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCodingParamReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getCodingParamReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCodingParamReq_Any(struct soap *soap, const char *tag, struct _ns1__getCodingParamReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getCodingParamReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getCodingParamReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getCodingParamReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getCodingParamReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCodingParamReq_Any, sizeof(struct _ns1__getCodingParamReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCodingParamReq_Any(struct soap *soap, struct _ns1__getCodingParamReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCodingParamReq_Any);
	if (soap_out_PointerTo_ns1__getCodingParamReq_Any(soap, tag?tag:"ns1:getCodingParamReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getCodingParamReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCodingParamReq_Any(struct soap *soap, struct _ns1__getCodingParamReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCodingParamReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__presetControlRes_Any(struct soap *soap, struct _ns1__presetControlRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__presetControlRes_Any))
		soap_serialize__ns1__presetControlRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__presetControlRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__presetControlRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__presetControlRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__presetControlRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__presetControlRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__presetControlRes_Any(struct soap *soap, const char *tag, struct _ns1__presetControlRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__presetControlRes_Any **)soap_malloc(soap, sizeof(struct _ns1__presetControlRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__presetControlRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__presetControlRes_Any, sizeof(struct _ns1__presetControlRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__presetControlRes_Any(struct soap *soap, struct _ns1__presetControlRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__presetControlRes_Any);
	if (soap_out_PointerTo_ns1__presetControlRes_Any(soap, tag?tag:"ns1:presetControlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__presetControlRes_Any(struct soap *soap, struct _ns1__presetControlRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__presetControlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__presetControlReq_Any(struct soap *soap, struct _ns1__presetControlReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__presetControlReq_Any))
		soap_serialize__ns1__presetControlReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__presetControlReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__presetControlReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__presetControlReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__presetControlReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__presetControlReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__presetControlReq_Any(struct soap *soap, const char *tag, struct _ns1__presetControlReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__presetControlReq_Any **)soap_malloc(soap, sizeof(struct _ns1__presetControlReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__presetControlReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__presetControlReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__presetControlReq_Any, sizeof(struct _ns1__presetControlReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__presetControlReq_Any(struct soap *soap, struct _ns1__presetControlReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__presetControlReq_Any);
	if (soap_out_PointerTo_ns1__presetControlReq_Any(soap, tag?tag:"ns1:presetControlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__presetControlReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__presetControlReq_Any(struct soap *soap, struct _ns1__presetControlReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__presetControlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__lensControlRes_Any(struct soap *soap, struct _ns1__lensControlRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__lensControlRes_Any))
		soap_serialize__ns1__lensControlRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__lensControlRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__lensControlRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__lensControlRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__lensControlRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__lensControlRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__lensControlRes_Any(struct soap *soap, const char *tag, struct _ns1__lensControlRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__lensControlRes_Any **)soap_malloc(soap, sizeof(struct _ns1__lensControlRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__lensControlRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__lensControlRes_Any, sizeof(struct _ns1__lensControlRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__lensControlRes_Any(struct soap *soap, struct _ns1__lensControlRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__lensControlRes_Any);
	if (soap_out_PointerTo_ns1__lensControlRes_Any(soap, tag?tag:"ns1:lensControlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__lensControlRes_Any(struct soap *soap, struct _ns1__lensControlRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__lensControlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__lensControlReq_Any(struct soap *soap, struct _ns1__lensControlReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__lensControlReq_Any))
		soap_serialize__ns1__lensControlReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__lensControlReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__lensControlReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__lensControlReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__lensControlReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__lensControlReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__lensControlReq_Any(struct soap *soap, const char *tag, struct _ns1__lensControlReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__lensControlReq_Any **)soap_malloc(soap, sizeof(struct _ns1__lensControlReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__lensControlReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__lensControlReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__lensControlReq_Any, sizeof(struct _ns1__lensControlReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__lensControlReq_Any(struct soap *soap, struct _ns1__lensControlReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__lensControlReq_Any);
	if (soap_out_PointerTo_ns1__lensControlReq_Any(soap, tag?tag:"ns1:lensControlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__lensControlReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__lensControlReq_Any(struct soap *soap, struct _ns1__lensControlReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__lensControlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ptzControlRes_Any(struct soap *soap, struct _ns1__ptzControlRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ptzControlRes_Any))
		soap_serialize__ns1__ptzControlRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ptzControlRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__ptzControlRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ptzControlRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ptzControlRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ptzControlRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__ptzControlRes_Any(struct soap *soap, const char *tag, struct _ns1__ptzControlRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ptzControlRes_Any **)soap_malloc(soap, sizeof(struct _ns1__ptzControlRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ptzControlRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ptzControlRes_Any, sizeof(struct _ns1__ptzControlRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ptzControlRes_Any(struct soap *soap, struct _ns1__ptzControlRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ptzControlRes_Any);
	if (soap_out_PointerTo_ns1__ptzControlRes_Any(soap, tag?tag:"ns1:ptzControlRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__ptzControlRes_Any(struct soap *soap, struct _ns1__ptzControlRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ptzControlRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ptzControlReq_Any(struct soap *soap, struct _ns1__ptzControlReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ptzControlReq_Any))
		soap_serialize__ns1__ptzControlReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ptzControlReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__ptzControlReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ptzControlReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ptzControlReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ptzControlReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__ptzControlReq_Any(struct soap *soap, const char *tag, struct _ns1__ptzControlReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ptzControlReq_Any **)soap_malloc(soap, sizeof(struct _ns1__ptzControlReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ptzControlReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ptzControlReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ptzControlReq_Any, sizeof(struct _ns1__ptzControlReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ptzControlReq_Any(struct soap *soap, struct _ns1__ptzControlReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ptzControlReq_Any);
	if (soap_out_PointerTo_ns1__ptzControlReq_Any(soap, tag?tag:"ns1:ptzControlReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ptzControlReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__ptzControlReq_Any(struct soap *soap, struct _ns1__ptzControlReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ptzControlReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceRes_Any(struct soap *soap, struct _ns1__nullifyDeviceRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceRes_Any))
		soap_serialize__ns1__nullifyDeviceRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceRes_Any(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceRes_Any **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__nullifyDeviceRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceRes_Any, sizeof(struct _ns1__nullifyDeviceRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceRes_Any(struct soap *soap, struct _ns1__nullifyDeviceRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceRes_Any);
	if (soap_out_PointerTo_ns1__nullifyDeviceRes_Any(soap, tag?tag:"ns1:nullifyDeviceRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceRes_Any(struct soap *soap, struct _ns1__nullifyDeviceRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__nullifyDeviceReq_Any(struct soap *soap, struct _ns1__nullifyDeviceReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__nullifyDeviceReq_Any))
		soap_serialize__ns1__nullifyDeviceReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__nullifyDeviceReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__nullifyDeviceReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__nullifyDeviceReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__nullifyDeviceReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__nullifyDeviceReq_Any(struct soap *soap, const char *tag, struct _ns1__nullifyDeviceReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__nullifyDeviceReq_Any **)soap_malloc(soap, sizeof(struct _ns1__nullifyDeviceReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__nullifyDeviceReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__nullifyDeviceReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__nullifyDeviceReq_Any, sizeof(struct _ns1__nullifyDeviceReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__nullifyDeviceReq_Any(struct soap *soap, struct _ns1__nullifyDeviceReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__nullifyDeviceReq_Any);
	if (soap_out_PointerTo_ns1__nullifyDeviceReq_Any(soap, tag?tag:"ns1:nullifyDeviceReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__nullifyDeviceReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__nullifyDeviceReq_Any(struct soap *soap, struct _ns1__nullifyDeviceReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__nullifyDeviceReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceRes_Any(struct soap *soap, struct _ns1__addDeviceRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceRes_Any))
		soap_serialize__ns1__addDeviceRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceRes_Any(struct soap *soap, const char *tag, struct _ns1__addDeviceRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceRes_Any **)soap_malloc(soap, sizeof(struct _ns1__addDeviceRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__addDeviceRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceRes_Any, sizeof(struct _ns1__addDeviceRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceRes_Any(struct soap *soap, struct _ns1__addDeviceRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceRes_Any);
	if (soap_out_PointerTo_ns1__addDeviceRes_Any(soap, tag?tag:"ns1:addDeviceRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceRes_Any(struct soap *soap, struct _ns1__addDeviceRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addDeviceReq_Any(struct soap *soap, struct _ns1__addDeviceReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addDeviceReq_Any))
		soap_serialize__ns1__addDeviceReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addDeviceReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__addDeviceReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addDeviceReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__addDeviceReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__addDeviceReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__addDeviceReq_Any(struct soap *soap, const char *tag, struct _ns1__addDeviceReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__addDeviceReq_Any **)soap_malloc(soap, sizeof(struct _ns1__addDeviceReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__addDeviceReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__addDeviceReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addDeviceReq_Any, sizeof(struct _ns1__addDeviceReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addDeviceReq_Any(struct soap *soap, struct _ns1__addDeviceReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addDeviceReq_Any);
	if (soap_out_PointerTo_ns1__addDeviceReq_Any(soap, tag?tag:"ns1:addDeviceReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__addDeviceReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__addDeviceReq_Any(struct soap *soap, struct _ns1__addDeviceReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addDeviceReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDevice))
		soap_serialize_ns1__ArrayOfDevice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDevice(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDevice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDevice);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDevice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDevice(struct soap *soap, const char *tag, struct ns1__ArrayOfDevice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDevice **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDevice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfDevice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDevice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDevice, sizeof(struct ns1__ArrayOfDevice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDevice);
	if (soap_out_PointerTons1__ArrayOfDevice(soap, tag?tag:"ns1:ArrayOfDevice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDevice ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDevice(struct soap *soap, struct ns1__ArrayOfDevice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateChannelNameRes_Any(struct soap *soap, struct _ns1__updateChannelNameRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateChannelNameRes_Any))
		soap_serialize__ns1__updateChannelNameRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateChannelNameRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__updateChannelNameRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateChannelNameRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateChannelNameRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateChannelNameRes_Any(struct soap *soap, const char *tag, struct _ns1__updateChannelNameRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateChannelNameRes_Any **)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateChannelNameRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateChannelNameRes_Any, sizeof(struct _ns1__updateChannelNameRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateChannelNameRes_Any(struct soap *soap, struct _ns1__updateChannelNameRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateChannelNameRes_Any);
	if (soap_out_PointerTo_ns1__updateChannelNameRes_Any(soap, tag?tag:"ns1:updateChannelNameRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateChannelNameRes_Any(struct soap *soap, struct _ns1__updateChannelNameRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateChannelNameRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateChannelNameReq_Any(struct soap *soap, struct _ns1__updateChannelNameReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateChannelNameReq_Any))
		soap_serialize__ns1__updateChannelNameReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateChannelNameReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__updateChannelNameReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateChannelNameReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateChannelNameReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateChannelNameReq_Any(struct soap *soap, const char *tag, struct _ns1__updateChannelNameReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateChannelNameReq_Any **)soap_malloc(soap, sizeof(struct _ns1__updateChannelNameReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateChannelNameReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateChannelNameReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateChannelNameReq_Any, sizeof(struct _ns1__updateChannelNameReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateChannelNameReq_Any(struct soap *soap, struct _ns1__updateChannelNameReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateChannelNameReq_Any);
	if (soap_out_PointerTo_ns1__updateChannelNameReq_Any(soap, tag?tag:"ns1:updateChannelNameReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateChannelNameReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateChannelNameReq_Any(struct soap *soap, struct _ns1__updateChannelNameReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateChannelNameReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLogoutRes_Any(struct soap *soap, struct _ns1__userLogoutRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLogoutRes_Any))
		soap_serialize__ns1__userLogoutRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLogoutRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__userLogoutRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLogoutRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLogoutRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLogoutRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLogoutRes_Any(struct soap *soap, const char *tag, struct _ns1__userLogoutRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLogoutRes_Any **)soap_malloc(soap, sizeof(struct _ns1__userLogoutRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLogoutRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLogoutRes_Any, sizeof(struct _ns1__userLogoutRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLogoutRes_Any(struct soap *soap, struct _ns1__userLogoutRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLogoutRes_Any);
	if (soap_out_PointerTo_ns1__userLogoutRes_Any(soap, tag?tag:"ns1:userLogoutRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLogoutRes_Any(struct soap *soap, struct _ns1__userLogoutRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLogoutRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLogoutReq_Any(struct soap *soap, struct _ns1__userLogoutReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLogoutReq_Any))
		soap_serialize__ns1__userLogoutReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLogoutReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__userLogoutReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLogoutReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLogoutReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLogoutReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLogoutReq_Any(struct soap *soap, const char *tag, struct _ns1__userLogoutReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLogoutReq_Any **)soap_malloc(soap, sizeof(struct _ns1__userLogoutReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLogoutReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLogoutReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLogoutReq_Any, sizeof(struct _ns1__userLogoutReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLogoutReq_Any(struct soap *soap, struct _ns1__userLogoutReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLogoutReq_Any);
	if (soap_out_PointerTo_ns1__userLogoutReq_Any(soap, tag?tag:"ns1:userLogoutReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLogoutReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLogoutReq_Any(struct soap *soap, struct _ns1__userLogoutReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLogoutReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLoginRes_Any(struct soap *soap, struct _ns1__userLoginRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLoginRes_Any))
		soap_serialize__ns1__userLoginRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLoginRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__userLoginRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLoginRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLoginRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLoginRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLoginRes_Any(struct soap *soap, const char *tag, struct _ns1__userLoginRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLoginRes_Any **)soap_malloc(soap, sizeof(struct _ns1__userLoginRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLoginRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLoginRes_Any, sizeof(struct _ns1__userLoginRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLoginRes_Any(struct soap *soap, struct _ns1__userLoginRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLoginRes_Any);
	if (soap_out_PointerTo_ns1__userLoginRes_Any(soap, tag?tag:"ns1:userLoginRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLoginRes_Any(struct soap *soap, struct _ns1__userLoginRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLoginRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDev))
		soap_serialize_ns1__ArrayOfDev(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDev(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfDev *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDev);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfDev(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfDev ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDev(struct soap *soap, const char *tag, struct ns1__ArrayOfDev **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfDev **)soap_malloc(soap, sizeof(struct ns1__ArrayOfDev *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfDev(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfDev **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDev, sizeof(struct ns1__ArrayOfDev), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfDev);
	if (soap_out_PointerTons1__ArrayOfDev(soap, tag?tag:"ns1:ArrayOfDev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfDev ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDev(struct soap *soap, struct ns1__ArrayOfDev **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userLoginReq_Any(struct soap *soap, struct _ns1__userLoginReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userLoginReq_Any))
		soap_serialize__ns1__userLoginReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userLoginReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__userLoginReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userLoginReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__userLoginReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__userLoginReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__userLoginReq_Any(struct soap *soap, const char *tag, struct _ns1__userLoginReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__userLoginReq_Any **)soap_malloc(soap, sizeof(struct _ns1__userLoginReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__userLoginReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__userLoginReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userLoginReq_Any, sizeof(struct _ns1__userLoginReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userLoginReq_Any(struct soap *soap, struct _ns1__userLoginReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userLoginReq_Any);
	if (soap_out_PointerTo_ns1__userLoginReq_Any(soap, tag?tag:"ns1:userLoginReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__userLoginReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__userLoginReq_Any(struct soap *soap, struct _ns1__userLoginReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userLoginReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__byeRes_Any(struct soap *soap, struct _ns1__byeRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__byeRes_Any))
		soap_serialize__ns1__byeRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__byeRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__byeRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__byeRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__byeRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__byeRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__byeRes_Any(struct soap *soap, const char *tag, struct _ns1__byeRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__byeRes_Any **)soap_malloc(soap, sizeof(struct _ns1__byeRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__byeRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__byeRes_Any, sizeof(struct _ns1__byeRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__byeRes_Any(struct soap *soap, struct _ns1__byeRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__byeRes_Any);
	if (soap_out_PointerTo_ns1__byeRes_Any(soap, tag?tag:"ns1:byeRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__byeRes_Any(struct soap *soap, struct _ns1__byeRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__byeRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__byeReq_Any(struct soap *soap, struct _ns1__byeReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__byeReq_Any))
		soap_serialize__ns1__byeReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__byeReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__byeReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__byeReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__byeReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__byeReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__byeReq_Any(struct soap *soap, const char *tag, struct _ns1__byeReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__byeReq_Any **)soap_malloc(soap, sizeof(struct _ns1__byeReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__byeReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__byeReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__byeReq_Any, sizeof(struct _ns1__byeReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__byeReq_Any(struct soap *soap, struct _ns1__byeReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__byeReq_Any);
	if (soap_out_PointerTo_ns1__byeReq_Any(soap, tag?tag:"ns1:byeReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__byeReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__byeReq_Any(struct soap *soap, struct _ns1__byeReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__byeReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__inviteRes_Any(struct soap *soap, struct _ns1__inviteRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__inviteRes_Any))
		soap_serialize__ns1__inviteRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__inviteRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__inviteRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__inviteRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__inviteRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__inviteRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__inviteRes_Any(struct soap *soap, const char *tag, struct _ns1__inviteRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__inviteRes_Any **)soap_malloc(soap, sizeof(struct _ns1__inviteRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__inviteRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__inviteRes_Any, sizeof(struct _ns1__inviteRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__inviteRes_Any(struct soap *soap, struct _ns1__inviteRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__inviteRes_Any);
	if (soap_out_PointerTo_ns1__inviteRes_Any(soap, tag?tag:"ns1:inviteRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__inviteRes_Any(struct soap *soap, struct _ns1__inviteRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__inviteRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__inviteReq_Any(struct soap *soap, struct _ns1__inviteReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__inviteReq_Any))
		soap_serialize__ns1__inviteReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__inviteReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__inviteReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__inviteReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__inviteReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__inviteReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__inviteReq_Any(struct soap *soap, const char *tag, struct _ns1__inviteReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__inviteReq_Any **)soap_malloc(soap, sizeof(struct _ns1__inviteReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__inviteReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__inviteReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__inviteReq_Any, sizeof(struct _ns1__inviteReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__inviteReq_Any(struct soap *soap, struct _ns1__inviteReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__inviteReq_Any);
	if (soap_out_PointerTo_ns1__inviteReq_Any(soap, tag?tag:"ns1:inviteReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__inviteReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__inviteReq_Any(struct soap *soap, struct _ns1__inviteReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__inviteReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setAuxiliaryRes_Any(struct soap *soap, struct _ns1__setAuxiliaryRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setAuxiliaryRes_Any))
		soap_serialize__ns1__setAuxiliaryRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setAuxiliaryRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__setAuxiliaryRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setAuxiliaryRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setAuxiliaryRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setAuxiliaryRes_Any(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setAuxiliaryRes_Any **)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setAuxiliaryRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setAuxiliaryRes_Any, sizeof(struct _ns1__setAuxiliaryRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setAuxiliaryRes_Any(struct soap *soap, struct _ns1__setAuxiliaryRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setAuxiliaryRes_Any);
	if (soap_out_PointerTo_ns1__setAuxiliaryRes_Any(soap, tag?tag:"ns1:setAuxiliaryRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setAuxiliaryRes_Any(struct soap *soap, struct _ns1__setAuxiliaryRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setAuxiliaryRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setAuxiliaryReq_Any(struct soap *soap, struct _ns1__setAuxiliaryReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setAuxiliaryReq_Any))
		soap_serialize__ns1__setAuxiliaryReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setAuxiliaryReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__setAuxiliaryReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setAuxiliaryReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__setAuxiliaryReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__setAuxiliaryReq_Any(struct soap *soap, const char *tag, struct _ns1__setAuxiliaryReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__setAuxiliaryReq_Any **)soap_malloc(soap, sizeof(struct _ns1__setAuxiliaryReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__setAuxiliaryReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__setAuxiliaryReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setAuxiliaryReq_Any, sizeof(struct _ns1__setAuxiliaryReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setAuxiliaryReq_Any(struct soap *soap, struct _ns1__setAuxiliaryReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setAuxiliaryReq_Any);
	if (soap_out_PointerTo_ns1__setAuxiliaryReq_Any(soap, tag?tag:"ns1:setAuxiliaryReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__setAuxiliaryReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__setAuxiliaryReq_Any(struct soap *soap, struct _ns1__setAuxiliaryReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setAuxiliaryReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__AuxiliaryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuxiliaryType(struct soap *soap, const char *tag, int id, enum ns1__AuxiliaryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuxiliaryType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AuxiliaryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__AuxiliaryType ** SOAP_FMAC4 soap_in_PointerTons1__AuxiliaryType(struct soap *soap, const char *tag, enum ns1__AuxiliaryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__AuxiliaryType **)soap_malloc(soap, sizeof(enum ns1__AuxiliaryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AuxiliaryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuxiliaryType, sizeof(enum ns1__AuxiliaryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuxiliaryType);
	if (soap_out_PointerTons1__AuxiliaryType(soap, tag?tag:"ns1:AuxiliaryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryType ** SOAP_FMAC4 soap_get_PointerTons1__AuxiliaryType(struct soap *soap, enum ns1__AuxiliaryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuxiliaryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAuxiliaryRes_Any(struct soap *soap, struct _ns1__getAuxiliaryRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAuxiliaryRes_Any))
		soap_serialize__ns1__getAuxiliaryRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAuxiliaryRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getAuxiliaryRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAuxiliaryRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAuxiliaryRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAuxiliaryRes_Any(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAuxiliaryRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAuxiliaryRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAuxiliaryRes_Any, sizeof(struct _ns1__getAuxiliaryRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAuxiliaryRes_Any(struct soap *soap, struct _ns1__getAuxiliaryRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAuxiliaryRes_Any);
	if (soap_out_PointerTo_ns1__getAuxiliaryRes_Any(soap, tag?tag:"ns1:getAuxiliaryRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAuxiliaryRes_Any(struct soap *soap, struct _ns1__getAuxiliaryRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAuxiliaryRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__AuxiliaryState);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuxiliaryState(struct soap *soap, const char *tag, int id, enum ns1__AuxiliaryState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuxiliaryState);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AuxiliaryState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__AuxiliaryState ** SOAP_FMAC4 soap_in_PointerTons1__AuxiliaryState(struct soap *soap, const char *tag, enum ns1__AuxiliaryState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__AuxiliaryState **)soap_malloc(soap, sizeof(enum ns1__AuxiliaryState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AuxiliaryState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__AuxiliaryState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuxiliaryState, sizeof(enum ns1__AuxiliaryState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuxiliaryState);
	if (soap_out_PointerTons1__AuxiliaryState(soap, tag?tag:"ns1:AuxiliaryState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AuxiliaryState ** SOAP_FMAC4 soap_get_PointerTons1__AuxiliaryState(struct soap *soap, enum ns1__AuxiliaryState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuxiliaryState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAuxiliaryReq_Any(struct soap *soap, struct _ns1__getAuxiliaryReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAuxiliaryReq_Any))
		soap_serialize__ns1__getAuxiliaryReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAuxiliaryReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getAuxiliaryReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAuxiliaryReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAuxiliaryReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAuxiliaryReq_Any(struct soap *soap, const char *tag, struct _ns1__getAuxiliaryReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAuxiliaryReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getAuxiliaryReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAuxiliaryReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAuxiliaryReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAuxiliaryReq_Any, sizeof(struct _ns1__getAuxiliaryReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAuxiliaryReq_Any(struct soap *soap, struct _ns1__getAuxiliaryReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAuxiliaryReq_Any);
	if (soap_out_PointerTo_ns1__getAuxiliaryReq_Any(soap, tag?tag:"ns1:getAuxiliaryReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAuxiliaryReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAuxiliaryReq_Any(struct soap *soap, struct _ns1__getAuxiliaryReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAuxiliaryReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBackPasswordRes_Any(struct soap *soap, struct _ns1__getBackPasswordRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBackPasswordRes_Any))
		soap_serialize__ns1__getBackPasswordRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBackPasswordRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getBackPasswordRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBackPasswordRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getBackPasswordRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBackPasswordRes_Any(struct soap *soap, const char *tag, struct _ns1__getBackPasswordRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getBackPasswordRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getBackPasswordRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBackPasswordRes_Any, sizeof(struct _ns1__getBackPasswordRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBackPasswordRes_Any(struct soap *soap, struct _ns1__getBackPasswordRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBackPasswordRes_Any);
	if (soap_out_PointerTo_ns1__getBackPasswordRes_Any(soap, tag?tag:"ns1:getBackPasswordRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBackPasswordRes_Any(struct soap *soap, struct _ns1__getBackPasswordRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBackPasswordRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getBackPasswordReq_Any(struct soap *soap, struct _ns1__getBackPasswordReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getBackPasswordReq_Any))
		soap_serialize__ns1__getBackPasswordReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getBackPasswordReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getBackPasswordReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getBackPasswordReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getBackPasswordReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getBackPasswordReq_Any(struct soap *soap, const char *tag, struct _ns1__getBackPasswordReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getBackPasswordReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getBackPasswordReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getBackPasswordReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getBackPasswordReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getBackPasswordReq_Any, sizeof(struct _ns1__getBackPasswordReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getBackPasswordReq_Any(struct soap *soap, struct _ns1__getBackPasswordReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getBackPasswordReq_Any);
	if (soap_out_PointerTo_ns1__getBackPasswordReq_Any(soap, tag?tag:"ns1:getBackPasswordReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getBackPasswordReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getBackPasswordReq_Any(struct soap *soap, struct _ns1__getBackPasswordReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getBackPasswordReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountRes_Any(struct soap *soap, struct _ns1__getAccountRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountRes_Any))
		soap_serialize__ns1__getAccountRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__getAccountRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountRes_Any(struct soap *soap, const char *tag, struct _ns1__getAccountRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountRes_Any **)soap_malloc(soap, sizeof(struct _ns1__getAccountRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountRes_Any, sizeof(struct _ns1__getAccountRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountRes_Any(struct soap *soap, struct _ns1__getAccountRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountRes_Any);
	if (soap_out_PointerTo_ns1__getAccountRes_Any(soap, tag?tag:"ns1:getAccountRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountRes_Any(struct soap *soap, struct _ns1__getAccountRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getAccountReq_Any(struct soap *soap, struct _ns1__getAccountReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getAccountReq_Any))
		soap_serialize__ns1__getAccountReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getAccountReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__getAccountReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getAccountReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__getAccountReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__getAccountReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__getAccountReq_Any(struct soap *soap, const char *tag, struct _ns1__getAccountReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__getAccountReq_Any **)soap_malloc(soap, sizeof(struct _ns1__getAccountReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__getAccountReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__getAccountReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getAccountReq_Any, sizeof(struct _ns1__getAccountReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getAccountReq_Any(struct soap *soap, struct _ns1__getAccountReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getAccountReq_Any);
	if (soap_out_PointerTo_ns1__getAccountReq_Any(soap, tag?tag:"ns1:getAccountReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__getAccountReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__getAccountReq_Any(struct soap *soap, struct _ns1__getAccountReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getAccountReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAppleTokenRes_Any(struct soap *soap, struct _ns1__updateAppleTokenRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAppleTokenRes_Any))
		soap_serialize__ns1__updateAppleTokenRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAppleTokenRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__updateAppleTokenRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAppleTokenRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAppleTokenRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAppleTokenRes_Any(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAppleTokenRes_Any **)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAppleTokenRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAppleTokenRes_Any, sizeof(struct _ns1__updateAppleTokenRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAppleTokenRes_Any(struct soap *soap, struct _ns1__updateAppleTokenRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAppleTokenRes_Any);
	if (soap_out_PointerTo_ns1__updateAppleTokenRes_Any(soap, tag?tag:"ns1:updateAppleTokenRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAppleTokenRes_Any(struct soap *soap, struct _ns1__updateAppleTokenRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAppleTokenRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAppleTokenReq_Any(struct soap *soap, struct _ns1__updateAppleTokenReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAppleTokenReq_Any))
		soap_serialize__ns1__updateAppleTokenReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAppleTokenReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__updateAppleTokenReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAppleTokenReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAppleTokenReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAppleTokenReq_Any(struct soap *soap, const char *tag, struct _ns1__updateAppleTokenReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAppleTokenReq_Any **)soap_malloc(soap, sizeof(struct _ns1__updateAppleTokenReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAppleTokenReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAppleTokenReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAppleTokenReq_Any, sizeof(struct _ns1__updateAppleTokenReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAppleTokenReq_Any(struct soap *soap, struct _ns1__updateAppleTokenReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAppleTokenReq_Any);
	if (soap_out_PointerTo_ns1__updateAppleTokenReq_Any(soap, tag?tag:"ns1:updateAppleTokenReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAppleTokenReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAppleTokenReq_Any(struct soap *soap, struct _ns1__updateAppleTokenReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAppleTokenReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceRes_Any(struct soap *soap, struct _ns1__queryDeviceRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceRes_Any))
		soap_serialize__ns1__queryDeviceRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceRes_Any(struct soap *soap, const char *tag, struct _ns1__queryDeviceRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceRes_Any **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDeviceRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceRes_Any, sizeof(struct _ns1__queryDeviceRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceRes_Any(struct soap *soap, struct _ns1__queryDeviceRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceRes_Any);
	if (soap_out_PointerTo_ns1__queryDeviceRes_Any(soap, tag?tag:"ns1:queryDeviceRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceRes_Any(struct soap *soap, struct _ns1__queryDeviceRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfNodeDetails))
		soap_serialize_ns1__ArrayOfNodeDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfNodeDetails(struct soap *soap, const char *tag, int id, struct ns1__ArrayOfNodeDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfNodeDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ArrayOfNodeDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfNodeDetails(struct soap *soap, const char *tag, struct ns1__ArrayOfNodeDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ArrayOfNodeDetails **)soap_malloc(soap, sizeof(struct ns1__ArrayOfNodeDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ArrayOfNodeDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ArrayOfNodeDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfNodeDetails, sizeof(struct ns1__ArrayOfNodeDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ArrayOfNodeDetails);
	if (soap_out_PointerTons1__ArrayOfNodeDetails(soap, tag?tag:"ns1:ArrayOfNodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ArrayOfNodeDetails ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfNodeDetails(struct soap *soap, struct ns1__ArrayOfNodeDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfNodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__queryDeviceReq_Any(struct soap *soap, struct _ns1__queryDeviceReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__queryDeviceReq_Any))
		soap_serialize__ns1__queryDeviceReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__queryDeviceReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__queryDeviceReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__queryDeviceReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__queryDeviceReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__queryDeviceReq_Any(struct soap *soap, const char *tag, struct _ns1__queryDeviceReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__queryDeviceReq_Any **)soap_malloc(soap, sizeof(struct _ns1__queryDeviceReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__queryDeviceReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__queryDeviceReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__queryDeviceReq_Any, sizeof(struct _ns1__queryDeviceReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__queryDeviceReq_Any(struct soap *soap, struct _ns1__queryDeviceReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__queryDeviceReq_Any);
	if (soap_out_PointerTo_ns1__queryDeviceReq_Any(soap, tag?tag:"ns1:queryDeviceReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__queryDeviceReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__queryDeviceReq_Any(struct soap *soap, struct _ns1__queryDeviceReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__queryDeviceReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updatePasswordRes_Any(struct soap *soap, struct _ns1__updatePasswordRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updatePasswordRes_Any))
		soap_serialize__ns1__updatePasswordRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updatePasswordRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__updatePasswordRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updatePasswordRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updatePasswordRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updatePasswordRes_Any(struct soap *soap, const char *tag, struct _ns1__updatePasswordRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updatePasswordRes_Any **)soap_malloc(soap, sizeof(struct _ns1__updatePasswordRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updatePasswordRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updatePasswordRes_Any, sizeof(struct _ns1__updatePasswordRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updatePasswordRes_Any(struct soap *soap, struct _ns1__updatePasswordRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updatePasswordRes_Any);
	if (soap_out_PointerTo_ns1__updatePasswordRes_Any(soap, tag?tag:"ns1:updatePasswordRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updatePasswordRes_Any(struct soap *soap, struct _ns1__updatePasswordRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updatePasswordRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updatePasswordReq_Any(struct soap *soap, struct _ns1__updatePasswordReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updatePasswordReq_Any))
		soap_serialize__ns1__updatePasswordReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updatePasswordReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__updatePasswordReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updatePasswordReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updatePasswordReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updatePasswordReq_Any(struct soap *soap, const char *tag, struct _ns1__updatePasswordReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updatePasswordReq_Any **)soap_malloc(soap, sizeof(struct _ns1__updatePasswordReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updatePasswordReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updatePasswordReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updatePasswordReq_Any, sizeof(struct _ns1__updatePasswordReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updatePasswordReq_Any(struct soap *soap, struct _ns1__updatePasswordReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updatePasswordReq_Any);
	if (soap_out_PointerTo_ns1__updatePasswordReq_Any(soap, tag?tag:"ns1:updatePasswordReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updatePasswordReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updatePasswordReq_Any(struct soap *soap, struct _ns1__updatePasswordReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updatePasswordReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountRes_Any(struct soap *soap, struct _ns1__updateAccountRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountRes_Any))
		soap_serialize__ns1__updateAccountRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountRes_Any(struct soap *soap, const char *tag, struct _ns1__updateAccountRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountRes_Any **)soap_malloc(soap, sizeof(struct _ns1__updateAccountRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountRes_Any, sizeof(struct _ns1__updateAccountRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountRes_Any(struct soap *soap, struct _ns1__updateAccountRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountRes_Any);
	if (soap_out_PointerTo_ns1__updateAccountRes_Any(soap, tag?tag:"ns1:updateAccountRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountRes_Any(struct soap *soap, struct _ns1__updateAccountRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__updateAccountReq_Any(struct soap *soap, struct _ns1__updateAccountReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__updateAccountReq_Any))
		soap_serialize__ns1__updateAccountReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__updateAccountReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__updateAccountReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__updateAccountReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__updateAccountReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__updateAccountReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__updateAccountReq_Any(struct soap *soap, const char *tag, struct _ns1__updateAccountReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__updateAccountReq_Any **)soap_malloc(soap, sizeof(struct _ns1__updateAccountReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__updateAccountReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__updateAccountReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__updateAccountReq_Any, sizeof(struct _ns1__updateAccountReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__updateAccountReq_Any(struct soap *soap, struct _ns1__updateAccountReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__updateAccountReq_Any);
	if (soap_out_PointerTo_ns1__updateAccountReq_Any(soap, tag?tag:"ns1:updateAccountReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__updateAccountReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__updateAccountReq_Any(struct soap *soap, struct _ns1__updateAccountReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__updateAccountReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createAccountRes_Any(struct soap *soap, struct _ns1__createAccountRes_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createAccountRes_Any))
		soap_serialize__ns1__createAccountRes_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createAccountRes_Any(struct soap *soap, const char *tag, int id, struct _ns1__createAccountRes_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createAccountRes_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createAccountRes_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createAccountRes_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__createAccountRes_Any(struct soap *soap, const char *tag, struct _ns1__createAccountRes_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createAccountRes_Any **)soap_malloc(soap, sizeof(struct _ns1__createAccountRes_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__createAccountRes_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountRes_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createAccountRes_Any, sizeof(struct _ns1__createAccountRes_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createAccountRes_Any(struct soap *soap, struct _ns1__createAccountRes_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createAccountRes_Any);
	if (soap_out_PointerTo_ns1__createAccountRes_Any(soap, tag?tag:"ns1:createAccountRes-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountRes_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__createAccountRes_Any(struct soap *soap, struct _ns1__createAccountRes_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createAccountRes_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__createAccountReq_Any(struct soap *soap, struct _ns1__createAccountReq_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__createAccountReq_Any))
		soap_serialize__ns1__createAccountReq_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__createAccountReq_Any(struct soap *soap, const char *tag, int id, struct _ns1__createAccountReq_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__createAccountReq_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__createAccountReq_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__createAccountReq_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__createAccountReq_Any(struct soap *soap, const char *tag, struct _ns1__createAccountReq_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__createAccountReq_Any **)soap_malloc(soap, sizeof(struct _ns1__createAccountReq_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__createAccountReq_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__createAccountReq_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__createAccountReq_Any, sizeof(struct _ns1__createAccountReq_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__createAccountReq_Any(struct soap *soap, struct _ns1__createAccountReq_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__createAccountReq_Any);
	if (soap_out_PointerTo_ns1__createAccountReq_Any(soap, tag?tag:"ns1:createAccountReq-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__createAccountReq_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__createAccountReq_Any(struct soap *soap, struct _ns1__createAccountReq_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__createAccountReq_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__CountryAbbr2ISO3166);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, int id, enum ns1__CountryAbbr2ISO3166 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountryAbbr2ISO3166);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CountryAbbr2ISO3166(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 ** SOAP_FMAC4 soap_in_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, const char *tag, enum ns1__CountryAbbr2ISO3166 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__CountryAbbr2ISO3166 **)soap_malloc(soap, sizeof(enum ns1__CountryAbbr2ISO3166 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CountryAbbr2ISO3166(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__CountryAbbr2ISO3166 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryAbbr2ISO3166, sizeof(enum ns1__CountryAbbr2ISO3166), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CountryAbbr2ISO3166);
	if (soap_out_PointerTons1__CountryAbbr2ISO3166(soap, tag?tag:"ns1:CountryAbbr2ISO3166", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__CountryAbbr2ISO3166 ** SOAP_FMAC4 soap_get_PointerTons1__CountryAbbr2ISO3166(struct soap *soap, enum ns1__CountryAbbr2ISO3166 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryAbbr2ISO3166(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__VODRecord_Any(struct soap *soap, struct _ns1__VODRecord_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__VODRecord_Any))
		soap_serialize__ns1__VODRecord_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__VODRecord_Any(struct soap *soap, const char *tag, int id, struct _ns1__VODRecord_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__VODRecord_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__VODRecord_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__VODRecord_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__VODRecord_Any(struct soap *soap, const char *tag, struct _ns1__VODRecord_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__VODRecord_Any **)soap_malloc(soap, sizeof(struct _ns1__VODRecord_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__VODRecord_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__VODRecord_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__VODRecord_Any, sizeof(struct _ns1__VODRecord_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__VODRecord_Any(struct soap *soap, struct _ns1__VODRecord_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__VODRecord_Any);
	if (soap_out_PointerTo_ns1__VODRecord_Any(soap, tag?tag:"ns1:VODRecord-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__VODRecord_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__VODRecord_Any(struct soap *soap, struct _ns1__VODRecord_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__VODRecord_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PrivacyMaskRegion_Any(struct soap *soap, struct _ns1__PrivacyMaskRegion_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PrivacyMaskRegion_Any))
		soap_serialize__ns1__PrivacyMaskRegion_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PrivacyMaskRegion_Any(struct soap *soap, const char *tag, int id, struct _ns1__PrivacyMaskRegion_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PrivacyMaskRegion_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__PrivacyMaskRegion_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__PrivacyMaskRegion_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__PrivacyMaskRegion_Any(struct soap *soap, const char *tag, struct _ns1__PrivacyMaskRegion_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__PrivacyMaskRegion_Any **)soap_malloc(soap, sizeof(struct _ns1__PrivacyMaskRegion_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__PrivacyMaskRegion_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__PrivacyMaskRegion_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PrivacyMaskRegion_Any, sizeof(struct _ns1__PrivacyMaskRegion_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PrivacyMaskRegion_Any(struct soap *soap, struct _ns1__PrivacyMaskRegion_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PrivacyMaskRegion_Any);
	if (soap_out_PointerTo_ns1__PrivacyMaskRegion_Any(soap, tag?tag:"ns1:PrivacyMaskRegion-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__PrivacyMaskRegion_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__PrivacyMaskRegion_Any(struct soap *soap, struct _ns1__PrivacyMaskRegion_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PrivacyMaskRegion_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__VMDGrid_Any(struct soap *soap, struct _ns1__VMDGrid_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__VMDGrid_Any))
		soap_serialize__ns1__VMDGrid_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__VMDGrid_Any(struct soap *soap, const char *tag, int id, struct _ns1__VMDGrid_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__VMDGrid_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__VMDGrid_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__VMDGrid_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__VMDGrid_Any(struct soap *soap, const char *tag, struct _ns1__VMDGrid_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__VMDGrid_Any **)soap_malloc(soap, sizeof(struct _ns1__VMDGrid_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__VMDGrid_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__VMDGrid_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__VMDGrid_Any, sizeof(struct _ns1__VMDGrid_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__VMDGrid_Any(struct soap *soap, struct _ns1__VMDGrid_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__VMDGrid_Any);
	if (soap_out_PointerTo_ns1__VMDGrid_Any(soap, tag?tag:"ns1:VMDGrid-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__VMDGrid_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__VMDGrid_Any(struct soap *soap, struct _ns1__VMDGrid_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__VMDGrid_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DevLog_Any(struct soap *soap, struct _ns1__DevLog_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DevLog_Any))
		soap_serialize__ns1__DevLog_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DevLog_Any(struct soap *soap, const char *tag, int id, struct _ns1__DevLog_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DevLog_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DevLog_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DevLog_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__DevLog_Any(struct soap *soap, const char *tag, struct _ns1__DevLog_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DevLog_Any **)soap_malloc(soap, sizeof(struct _ns1__DevLog_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DevLog_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DevLog_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DevLog_Any, sizeof(struct _ns1__DevLog_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DevLog_Any(struct soap *soap, struct _ns1__DevLog_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DevLog_Any);
	if (soap_out_PointerTo_ns1__DevLog_Any(soap, tag?tag:"ns1:DevLog-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DevLog_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__DevLog_Any(struct soap *soap, struct _ns1__DevLog_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DevLog_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DevLog(struct soap *soap, struct ns1__DevLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DevLog))
		soap_serialize_ns1__DevLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DevLog(struct soap *soap, const char *tag, int id, struct ns1__DevLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DevLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__DevLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__DevLog ** SOAP_FMAC4 soap_in_PointerTons1__DevLog(struct soap *soap, const char *tag, struct ns1__DevLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__DevLog **)soap_malloc(soap, sizeof(struct ns1__DevLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__DevLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__DevLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DevLog, sizeof(struct ns1__DevLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DevLog(struct soap *soap, struct ns1__DevLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DevLog);
	if (soap_out_PointerTons1__DevLog(soap, tag?tag:"ns1:DevLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DevLog ** SOAP_FMAC4 soap_get_PointerTons1__DevLog(struct soap *soap, struct ns1__DevLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DevLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PuLog_Any(struct soap *soap, struct _ns1__PuLog_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PuLog_Any))
		soap_serialize__ns1__PuLog_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PuLog_Any(struct soap *soap, const char *tag, int id, struct _ns1__PuLog_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PuLog_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__PuLog_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__PuLog_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__PuLog_Any(struct soap *soap, const char *tag, struct _ns1__PuLog_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__PuLog_Any **)soap_malloc(soap, sizeof(struct _ns1__PuLog_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__PuLog_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__PuLog_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PuLog_Any, sizeof(struct _ns1__PuLog_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PuLog_Any(struct soap *soap, struct _ns1__PuLog_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PuLog_Any);
	if (soap_out_PointerTo_ns1__PuLog_Any(soap, tag?tag:"ns1:PuLog-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__PuLog_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__PuLog_Any(struct soap *soap, struct _ns1__PuLog_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PuLog_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PuLog(struct soap *soap, struct ns1__PuLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PuLog))
		soap_serialize_ns1__PuLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PuLog(struct soap *soap, const char *tag, int id, struct ns1__PuLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PuLog);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PuLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PuLog ** SOAP_FMAC4 soap_in_PointerTons1__PuLog(struct soap *soap, const char *tag, struct ns1__PuLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PuLog **)soap_malloc(soap, sizeof(struct ns1__PuLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PuLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PuLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PuLog, sizeof(struct ns1__PuLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PuLog(struct soap *soap, struct ns1__PuLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PuLog);
	if (soap_out_PointerTons1__PuLog(soap, tag?tag:"ns1:PuLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PuLog ** SOAP_FMAC4 soap_get_PointerTons1__PuLog(struct soap *soap, struct ns1__PuLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PuLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Device_Any(struct soap *soap, struct _ns1__Device_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Device_Any))
		soap_serialize__ns1__Device_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Device_Any(struct soap *soap, const char *tag, int id, struct _ns1__Device_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Device_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__Device_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__Device_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__Device_Any(struct soap *soap, const char *tag, struct _ns1__Device_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__Device_Any **)soap_malloc(soap, sizeof(struct _ns1__Device_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__Device_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__Device_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Device_Any, sizeof(struct _ns1__Device_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Device_Any(struct soap *soap, struct _ns1__Device_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Device_Any);
	if (soap_out_PointerTo_ns1__Device_Any(soap, tag?tag:"ns1:Device-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Device_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__Device_Any(struct soap *soap, struct _ns1__Device_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Device_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Device(struct soap *soap, struct ns1__Device *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Device))
		soap_serialize_ns1__Device(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Device(struct soap *soap, const char *tag, int id, struct ns1__Device *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Device);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Device(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Device ** SOAP_FMAC4 soap_in_PointerTons1__Device(struct soap *soap, const char *tag, struct ns1__Device **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Device **)soap_malloc(soap, sizeof(struct ns1__Device *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Device(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Device **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Device, sizeof(struct ns1__Device), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Device(struct soap *soap, struct ns1__Device *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Device);
	if (soap_out_PointerTons1__Device(soap, tag?tag:"ns1:Device", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Device ** SOAP_FMAC4 soap_get_PointerTons1__Device(struct soap *soap, struct ns1__Device **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Device(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Dev_Any(struct soap *soap, struct _ns1__Dev_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Dev_Any))
		soap_serialize__ns1__Dev_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Dev_Any(struct soap *soap, const char *tag, int id, struct _ns1__Dev_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Dev_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__Dev_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__Dev_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__Dev_Any(struct soap *soap, const char *tag, struct _ns1__Dev_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__Dev_Any **)soap_malloc(soap, sizeof(struct _ns1__Dev_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__Dev_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__Dev_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Dev_Any, sizeof(struct _ns1__Dev_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Dev_Any(struct soap *soap, struct _ns1__Dev_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Dev_Any);
	if (soap_out_PointerTo_ns1__Dev_Any(soap, tag?tag:"ns1:Dev-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__Dev_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__Dev_Any(struct soap *soap, struct _ns1__Dev_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Dev_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Dev(struct soap *soap, struct ns1__Dev *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Dev))
		soap_serialize_ns1__Dev(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Dev(struct soap *soap, const char *tag, int id, struct ns1__Dev *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Dev);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Dev(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Dev ** SOAP_FMAC4 soap_in_PointerTons1__Dev(struct soap *soap, const char *tag, struct ns1__Dev **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Dev **)soap_malloc(soap, sizeof(struct ns1__Dev *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Dev(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Dev **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Dev, sizeof(struct ns1__Dev), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Dev(struct soap *soap, struct ns1__Dev *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Dev);
	if (soap_out_PointerTons1__Dev(soap, tag?tag:"ns1:Dev", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Dev ** SOAP_FMAC4 soap_get_PointerTons1__Dev(struct soap *soap, struct ns1__Dev **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Dev(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__NodeDetails_Any(struct soap *soap, struct _ns1__NodeDetails_Any *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__NodeDetails_Any))
		soap_serialize__ns1__NodeDetails_Any(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__NodeDetails_Any(struct soap *soap, const char *tag, int id, struct _ns1__NodeDetails_Any *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__NodeDetails_Any);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__NodeDetails_Any(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__NodeDetails_Any ** SOAP_FMAC4 soap_in_PointerTo_ns1__NodeDetails_Any(struct soap *soap, const char *tag, struct _ns1__NodeDetails_Any **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__NodeDetails_Any **)soap_malloc(soap, sizeof(struct _ns1__NodeDetails_Any *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__NodeDetails_Any(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__NodeDetails_Any **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__NodeDetails_Any, sizeof(struct _ns1__NodeDetails_Any), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__NodeDetails_Any(struct soap *soap, struct _ns1__NodeDetails_Any *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__NodeDetails_Any);
	if (soap_out_PointerTo_ns1__NodeDetails_Any(soap, tag?tag:"ns1:NodeDetails-Any", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__NodeDetails_Any ** SOAP_FMAC4 soap_get_PointerTo_ns1__NodeDetails_Any(struct soap *soap, struct _ns1__NodeDetails_Any **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__NodeDetails_Any(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NodeDetails))
		soap_serialize_ns1__NodeDetails(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NodeDetails(struct soap *soap, const char *tag, int id, struct ns1__NodeDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NodeDetails);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__NodeDetails(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__NodeDetails ** SOAP_FMAC4 soap_in_PointerTons1__NodeDetails(struct soap *soap, const char *tag, struct ns1__NodeDetails **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__NodeDetails **)soap_malloc(soap, sizeof(struct ns1__NodeDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__NodeDetails(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__NodeDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NodeDetails, sizeof(struct ns1__NodeDetails), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NodeDetails(struct soap *soap, struct ns1__NodeDetails *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NodeDetails);
	if (soap_out_PointerTons1__NodeDetails(soap, tag?tag:"ns1:NodeDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__NodeDetails ** SOAP_FMAC4 soap_get_PointerTons1__NodeDetails(struct soap *soap, struct ns1__NodeDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NodeDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
